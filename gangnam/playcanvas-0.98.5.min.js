 /*
 PlayCanvas Engine v0.98.5 revision 8051c4c470ed
 http://playcanvas.com
 Copyright 2011-2012 PlayCanvas Ltd. All rights reserved.
 Do not distribute.
*/
var pc = {config: {},common: {},apps: {},data: {},unpack: function() {
        window.m4 = pc.math.mat4;
        window.v2 = pc.math.vec2;
        window.v3 = pc.math.vec3;
        window.v4 = pc.math.vec4;
        window.quat = pc.math.quat
    },makeArray: function(b) {
        var a, c = [], d = b.length;
        for (a = 0; a < d; ++a)
            c.push(b[a]);
        return c
    },type: function(b) {
        if (null == b)
            return "null";
        var a = typeof b;
        return "undefined" == a || "number" == a || "string" == a || "boolean" == a ? a : _typeLookup[Object.prototype.toString.call(b)]
    },extend: function(b, a) {
        var c, d;
        for (c in a)
            d = a[c], b[c] = "object" == pc.type(d) ? 
            pc.extend({}, d) : "array" == pc.type(d) ? pc.extend([], d) : d;
        return b
    },isDefined: function(b) {
        return void 0 !== b
    }}, _typeLookup = function() {
    var b = {}, a, c = "Array Object Function Date RegExp Float32Array".split(" ");
    for (a = 0; a < c.length; ++a)
        b["[object " + c[a] + "]"] = c[a].toLowerCase();
    return b
}();
"undefined" !== typeof exports && (exports.pc = pc);
pc.guid = function() {
    return {create: function() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(b) {
                var a = 16 * Math.random() | 0;
                return ("x" == b ? a : a & 3 | 8).toString(16)
            })
        }}
}();
pc.time = function() {
    var b = function() {
        this._isRunning = !1;
        this._b = this._a = 0
    };
    b.prototype.start = function() {
        this._isRunning = !0;
        this._a = (new Date).getTime()
    };
    b.prototype.stop = function() {
        this._isRunning = !1;
        this._b = (new Date).getTime()
    };
    b.prototype.getMilliseconds = function() {
        return this._b - this._a
    };
    return {Timer: b,now: function() {
            return (new Date).getTime()
        }}
}();
pc.extend(pc, function() {
    return {createURI: function(b) {
            var a = "";
            if ((b.authority || b.scheme) && (b.host || b.hostpath))
                throw Error("Can't have 'scheme' or 'authority' and 'host' or 'hostpath' option");
            if (b.host && b.hostpath)
                throw Error("Can't have 'host' and 'hostpath' option");
            if (b.path && b.hostpath)
                throw Error("Can't have 'path' and 'hostpath' option");
            b.scheme && (a += b.scheme + ":");
            b.authority && (a += "//" + b.authority);
            b.host && (a += b.host);
            b.path && (a += b.path);
            b.hostpath && (a += b.hostpath);
            b.query && (a += "?" + b.query);
            b.fragment && (a += "#" + b.fragment);
            return a
        },URI: function(b) {
            b = b.match(/^(([^:\/?\#]+):)?(\/\/([^\/?\#]*))?([^?\#]*)(\?([^\#]*))?(\#(.*))?/);
            this.scheme = b[2];
            this.authority = b[4];
            this.path = b[5];
            this.query = b[7];
            this.fragment = b[9];
            this.toString = function() {
                var a = "";
                this.scheme && (a += this.scheme + ":");
                this.authority && (a += "//" + this.authority);
                a += this.path;
                this.query && (a += "?" + this.query);
                this.fragment && (a += "#" + this.fragment);
                return a
            };
            this.getQuery = function() {
                var a, c, d = {};
                this.query && (a = decodeURIComponent(this.query).split("&"), 
                a.forEach(function(a) {
                    c = a.split("=");
                    d[c[0]] = c[1]
                }, this));
                return d
            };
            this.setQuery = function(a) {
                q = "";
                for (key in a)
                    a.hasOwnProperty(key) && ("" !== q && (q += "&"), q += encodeURIComponent(key) + "=" + encodeURIComponent(a[key]));
                this.query = q
            }
        }}
}());
pc.extend(pc, function() {
    return {log: {write: function(b) {
                console.log(b)
            },open: function() {
                pc.log.write(Date());
                pc.log.info("Log opened")
            },info: function(b) {
                console.info("INFO:    " + b)
            },debug: function(b) {
                console.debug("DEBUG:   " + b)
            },error: function(b) {
                console.error("ERROR:   " + b)
            },warning: function(b) {
                console.warn("WARNING: " + b)
            },alert: function(b) {
                pc.log.write("ALERT:   " + b);
                alert(b)
            },assert: function(b, a) {
                !1 === b && (pc.log.write("ASSERT:  " + a), alert("ASSERT failed: " + a))
            }}}
}());
var logINFO = pc.log.info, logDEBUG = pc.log.debug, logWARNING = pc.log.warning, logERROR = pc.log.error, logALERT = pc.log.alert, logASSERT = pc.log.assert;
Function.prototype.extendsFrom = function(b) {
    var a, c, d = function() {
    };
    a = this;
    c = function() {
        b.apply(this, arguments);
        a.apply(this, arguments);
        this.constructor = a
    };
    c._super = b.prototype;
    d.prototype = b.prototype;
    c.prototype = new d;
    return c
};
pc.extend(pc, function() {
    return {inherits: function(b, a) {
            var c = function() {
            }, d = function() {
                a.apply(this, arguments);
                b.apply(this, arguments);
                this.constructor = b
            };
            d._super = a.prototype;
            c.prototype = a.prototype;
            d.prototype = new c;
            return d
        }}
}());
Function.prototype.bind || (Function.prototype.bind = function(b) {
    if ("function" !== typeof this)
        throw new TypeError("Function.prototype.bind - what is trying to be fBound is not callable");
    var a = Array.prototype.slice.call(arguments, 1), c = this, d = function() {
    }, e = function() {
        return c.apply(this instanceof d ? this : b || window, a.concat(Array.prototype.slice.call(arguments)))
    };
    d.prototype = this.prototype;
    e.prototype = new d;
    return e
});
pc.path = function() {
    return {delimiter: "/",join: function() {
            var b, a = arguments.length, c = arguments[0];
            for (b = 0; b < a - 1; ++b) {
                var d = arguments[b], e = arguments[b + 1];
                if (!pc.isDefined(d) || !pc.isDefined(e))
                    throw Error("undefined argument to pc.path.join");
                c = e[0] === pc.path.delimiter ? e : d && e && d[d.length - 1] !== pc.path.delimiter && e[0] !== pc.path.delimiter ? c + (pc.path.delimiter + e) : c + e
            }
            return c
        },getDirectory: function(b) {
            b = b.split(pc.path.delimiter);
            return b.slice(0, b.length - 1).join(pc.path.delimiter)
        },getExtension: function(b) {
            var a = 
            b.split(".").pop();
            return a !== b ? "." + a : ""
        },isRelativePath: function(b) {
            return "/" !== b.charAt(0) && null === b.match(/:\/\//)
        },extractPath: function(b) {
            var a = ".", c = b.split("/"), d = 0;
            if (1 < c.length) {
                !1 === pc.path.isRelativePath(b) && (a = "");
                for (d = 0; d < c.length - 1; ++d)
                    a += "/" + c[d]
            }
            return a
        }}
}();
pc.string = function() {
    return {ASCII_LOWERCASE: "abcdefghijklmnopqrstuvwxyz",ASCII_UPPERCASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZ",ASCII_LETTERS: this.ASCII_LOWERCASE + this.ASCII_UPPERCASE,format: function(b) {
            var a = 0, c, d = pc.makeArray(arguments);
            d.shift();
            for (a = 0; a < d.length; a++)
                c = RegExp("\\{" + a + "\\}", "gi"), b = b.replace(c, d[a]);
            return b
        },startsWith: function(b, a) {
            return 0 === b.indexOf(a)
        },endsWith: function(b, a) {
            return -1 !== b.lastIndexOf(a, b.length - a.length)
        },toBool: function(b, a) {
            if ("true" === b)
                return !0;
            if (a) {
                if ("false" === 
                b)
                    return !1;
                throw Error("Not a boolean string");
            }
            return !1
        }}
}();
pc.extend(pc, function() {
    return {json: {parse: function(b, a) {
                return JSON.parse(b, a)
            },stringify: function(b, a, c) {
                return JSON.stringify(b, function(c, b) {
                    this[c] instanceof Float32Array && (b = pc.makeArray(this[c]));
                    return a ? a(c, b) : b
                }, c)
            }}}
}());
pc.cookie = function() {
    return {set: function(b, a, c) {
            c = c || {};
            b = b + "=" + a;
            c.path && (b += ";path=" + c.path);
            c.domain && (b += ";domain=" + c.domain);
            c.path && (b += ";path=" + c.path);
            c.secure && (b += ";secure");
            b = c.lifetime ? b + (";max-age=" + 86400 * c.lifetime) : b + ";max-age=86400";
            document.cookie = b
        },get: function(b) {
            var a, c = document.cookie.split(";").length;
            for (a = 0; a < c; a++)
                if (pc.string.startsWith(cookie[a], b))
                    return cookie.split("=")[1]
        },remove: function(b, a) {
            a.lifetime = 0;
            pc.cookie.set(b, "", a)
        }}
}();
pc.debug = function() {
    var b = null, a = null, c = null, d = null;
    return {display: function(e) {
            b || (b = document.createElement("table"), a = document.createElement("tr"), c = document.createElement("td"), d = document.createElement("td"), b.style.cssText = "position:absolute;font-family:sans-serif;font-size:12px", b.style.top = "0px", b.style.left = "0px", b.style.border = "thin solid black", document.body.appendChild(b));
            b.innerHTML = "";
            for (key in e) {
                var g = a.cloneNode(), f = c.cloneNode(), j = d.cloneNode();
                f.textContent = key;
                j.textContent = e[key];
                g.appendChild(f);
                g.appendChild(j);
                b.appendChild(g)
            }
        }}
}();
(function(b) {
    for (var a = 0, c = ["ms", "moz", "webkit", "o"], d = 0; d < c.length && !b.requestAnimationFrame; ++d)
        b.requestAnimationFrame = b[c[d] + "RequestAnimationFrame"], b.cancelAnimationFrame = b[c[d] + "CancelAnimationFrame"] || b[c[d] + "CancelRequestAnimationFrame"];
    b.requestAnimationFrame || (b.requestAnimationFrame = function(c) {
        var d = (new Date).getTime(), f = Math.max(0, 16 - (d - a)), j = b.setTimeout(function() {
            c(d + f)
        }, f);
        a = d + f;
        return j
    });
    b.cancelAnimationFrame || (b.cancelAnimationFrame = function(a) {
        clearTimeout(a)
    });
    b.requestAnimFrame = 
    b.requestAnimationFrame
})("undefined" === typeof exports ? this : exports);
pc.events = function() {
    var b = {on: function(a, c, d) {
            if ("string" != pc.type(a))
                throw new TypeError("Event name must be a string");
            var b = this._callbacks || (this._callbacks = {});
            (b[a] || (b[a] = [])).push({callback: c,scope: d || this});
            return this
        },off: function(a, c, d) {
            var b = this._callbacks;
            if (b) {
                if (c) {
                    a = b[a];
                    if (!a)
                        return this;
                    for (b = 0; b < a.length; b++)
                        if (a[b].callback === c && (!d || d === a[b].scope))
                            a.splice(b, 1), b--
                } else
                    b[a] = [];
                return this
            }
        },fire: function(a) {
            var c, d, b = pc.makeArray(arguments), g;
            b.shift();
            if (this._callbacks && 
            this._callbacks[a]) {
                g = this._callbacks[a].slice();
                d = g.length;
                for (c = 0; c < d; ++c)
                    g[c].callback.apply(g[c].scope, b)
            }
            return this
        },hasEvent: function(a) {
            return "undefined" !== typeof this._callbacks && "undefined" !== typeof this._callbacks[a] && 0 < this._callbacks[a].length
        }};
    b.bind = b.on;
    b.unbind = b.off;
    return b
}();
pc.dom = function() {
    return {getWidth: function(b) {
            return b.offsetWidth
        },getHeight: function(b) {
            return b.offsetHeight
        },setText: function(b, a) {
            b.textContent ? b.textContent = a : b.innerText && (b.innerText = a)
        },getText: function(b) {
            return b.textContent || b.innerText
        }}
}();
pc.math = {DEG_TO_RAD: Math.PI / 180,RAD_TO_DEG: 180 / Math.PI,clamp: function(b, a, c) {
        return b >= c ? c : b <= a ? a : b
    },intToBytes32: function(b) {
        return [b >> 24 & 255, b >> 16 & 255, b >> 8 & 255, b & 255]
    },intToBytes24: function(b) {
        return [b >> 16 & 255, b >> 8 & 255, b & 255]
    },bytesToInt32: function(b, a, c, d) {
        b.length && (d = b[3], c = b[2], a = b[1], b = b[0]);
        return (b << 24 | a << 16 | c << 8 | d) >>> 32
    },bytesToInt24: function(b, a, c) {
        b.length && (c = b[2], a = b[1], b = b[0]);
        return b << 16 | a << 8 | c
    },lerp: function(b, a, c) {
        return b + (a - b) * pc.math.clamp(c, 0, 1)
    },lerpAngle: function(b, a, c) {
        180 < 
        a - b && (a -= 360);
        -180 > a - b && (a += 360);
        return pc.math.lerp(b, a, pc.math.clamp(c, 0, 1))
    },pot: function(b) {
        return 0 !== b && !(b & b - 1)
    },random: function(b, a) {
        return Math.random() * (a - b) + b
    },sin: function(b) {
        return Math.sin(b * pc.math.DEG_TO_RAD)
    },cos: function(b) {
        return Math.cos(b * pc.math.DEG_TO_RAD)
    },tan: function(b) {
        return Math.tan(b * pc.math.DEG_TO_RAD)
    },asin: function(b) {
        return Math.asin(b) * pc.math.RAD_TO_DEG
    },acos: function(b) {
        return Math.acos(b) * pc.math.RAD_TO_DEG
    },atan: function(b) {
        return Math.atan(b) * pc.math.RAD_TO_DEG
    },
    atan2: function(b, a) {
        return Math.atan2(b, a) * pc.math.RAD_TO_DEG
    }};
pc.math.intToBytes = pc.math.intToBytes32;
pc.math.bytesToInt = pc.math.bytesToInt32;
pc.math.vec2 = function() {
    return {add: function(b, a, c) {
            c[0] = b[0] + a[0];
            c[1] = b[1] + a[1];
            return c
        },clone: function(b) {
            return new Float32Array(b)
        },copy: function(b, a) {
            a[0] = b[0];
            a[1] = b[1]
        },create: function(b, a) {
            var c = new Float32Array(2);
            c[0] = b;
            c[1] = a;
            return c
        },dot: function(b, a) {
            return b[0] * a[0] + b[1] * a[1]
        },length: function(b) {
            return Math.sqrt(pc.math.vec2.dot(b, b))
        },lerp: function(b, a, c, d) {
            d[0] = b[0] + c * (a[0] - b[0]);
            d[1] = b[1] + c * (a[1] - b[1]);
            return d
        },multiply: function(b, a, c) {
            c[0] = b[0] * a[0];
            c[1] = b[1] * a[1];
            return c
        },normalize: function(b, 
        a) {
            var c = pc.math.vec2.length(b);
            pc.math.vec2.scale(b, 1 / c, a);
            return a
        },scale: function(b, a, c) {
            c[0] = b[0] * a;
            c[1] = b[1] * a;
            return c
        },set: function(b, a, c) {
            b[0] = a;
            b[1] = c
        },subtract: function(b, a, c) {
            c[0] = b[0] - a[0];
            c[1] = b[1] - a[1];
            return c
        },sum: function() {
            var b, a = arguments.length - 1, c = 0, d = 0;
            for (b = 0; b < a; ++b)
                c += arguments[b][0], d += arguments[b][1];
            arguments[a][0] = c;
            arguments[a][1] = d;
            return arguments[a]
        }}
}();
pc.math.vec3 = function() {
    return {zero: new Float32Array([0, 0, 0]),one: new Float32Array([1, 1, 1]),xaxis: new Float32Array([1, 0, 0]),yaxis: new Float32Array([0, 1, 0]),zaxis: new Float32Array([0, 0, 1]),add: function(b, a, c) {
            c[0] = b[0] + a[0];
            c[1] = b[1] + a[1];
            c[2] = b[2] + a[2];
            return c
        },sum: function() {
            var b, a = arguments.length - 1, c = 0, d = 0, e = 0;
            for (b = 0; b < a; ++b)
                c += arguments[b][0], d += arguments[b][1], e += arguments[b][2];
            arguments[a][0] = c;
            arguments[a][1] = d;
            arguments[a][2] = e;
            return arguments[a]
        },clone: function(b) {
            return new Float32Array(b)
        },
        copy: function(b, a) {
            a[0] = b[0];
            a[1] = b[1];
            a[2] = b[2]
        },create: function() {
            return 3 === arguments.length ? new Float32Array(arguments) : new Float32Array(3)
        },cross: function(b, a, c) {
            c[0] = b[1] * a[2] - a[1] * b[2];
            c[1] = b[2] * a[0] - a[2] * b[0];
            c[2] = b[0] * a[1] - a[0] * b[1];
            return c
        },dot: function(b, a) {
            return b[0] * a[0] + b[1] * a[1] + b[2] * a[2]
        },length: function(b) {
            return Math.sqrt(pc.math.vec3.dot(b, b))
        },lerp: function(b, a, c, d) {
            d[0] = b[0] + c * (a[0] - b[0]);
            d[1] = b[1] + c * (a[1] - b[1]);
            d[2] = b[2] + c * (a[2] - b[2]);
            return d
        },multiply: function(b, a, c) {
            c[0] = 
            b[0] * a[0];
            c[1] = b[1] * a[1];
            c[2] = b[2] * a[2];
            return c
        },normalize: function(b, a) {
            var c = pc.math.vec3.length(b);
            pc.math.vec3.scale(b, 1 / c, a);
            return a
        },project: function(b, a, c) {
            var d = pc.math.vec3.dot(a, a), b = pc.math.vec3.dot(b, a);
            return pc.math.vec3.scale(a, b / d, c)
        },scale: function(b, a, c) {
            c[0] = b[0] * a;
            c[1] = b[1] * a;
            c[2] = b[2] * a;
            return c
        },set: function(b, a, c, d) {
            b[0] = a;
            b[1] = c;
            b[2] = d
        },subtract: function(b, a, c) {
            c[0] = b[0] - a[0];
            c[1] = b[1] - a[1];
            c[2] = b[2] - a[2];
            return c
        }}
}();
pc.math.vec4 = function() {
    return {add: function(b, a, c) {
            c[0] = b[0] + a[0];
            c[1] = b[1] + a[1];
            c[2] = b[2] + a[2];
            c[3] = b[3] + a[3];
            return c
        },clone: function(b) {
            return new Float32Array(b)
        },copy: function(b, a) {
            a[0] = b[0];
            a[1] = b[1];
            a[2] = b[2];
            a[3] = b[3]
        },create: function() {
            return 4 === arguments.length ? new Float32Array(arguments) : new Float32Array(4)
        },dot: function(b, a) {
            return b[0] * a[0] + b[1] * a[1] + b[2] * a[2] + b[3] * a[3]
        },length: function(b) {
            return Math.sqrt(pc.math.vec4.dot(b, b))
        },lerp: function(b, a, c, d) {
            d[0] = b[0] + c * (a[0] - b[0]);
            d[1] = b[1] + 
            c * (a[1] - b[1]);
            d[2] = b[2] + c * (a[2] - b[2]);
            d[3] = b[3] + c * (a[3] - b[3])
        },multiply: function(b, a, c) {
            c[0] = b[0] * a[0];
            c[1] = b[1] * a[1];
            c[2] = b[2] * a[2];
            c[3] = b[3] * a[3];
            return c
        },normalize: function(b, a) {
            var c = pc.math.vec4.length(b);
            pc.math.vec4.scale(b, 1 / c, a);
            return a
        },scale: function(b, a, c) {
            c[0] = b[0] * a;
            c[1] = b[1] * a;
            c[2] = b[2] * a;
            c[3] = b[3] * a;
            return c
        },set: function(b, a, c, d, e) {
            b[0] = a;
            b[1] = c;
            b[2] = d;
            b[3] = e
        },subtract: function(b, a, c) {
            c[0] = b[0] - a[0];
            c[1] = b[1] - a[1];
            c[2] = b[2] - a[2];
            c[3] = b[3] - a[3];
            return c
        }}
}();
pc.math.mat3 = function() {
    for (var b = [], a = 0; 3 > a; a++)
        b.push(pc.math.vec3.create());
    return {create: function() {
            if (9 === arguments.length) {
                var a = arguments;
                return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]]
            }
            return [1, 0, 0, 0, 1, 0, 0, 0, 1]
        },createFromMat4: function(a, d) {
            void 0 === d && (d = pc.math.Mat3.create());
            d[0] = a[0];
            d[1] = a[1];
            d[2] = a[2];
            d[3] = a[4];
            d[4] = a[5];
            d[5] = a[6];
            d[6] = a[8];
            d[7] = a[9];
            d[8] = a[10];
            return d
        },getScale: function(a, d) {
            void 0 === d && (d = pc.math.vec3.create());
            var e = b[0], g = b[1], f = b[2];
            pc.math.vec3.set(e, a[0], 
            a[1], a[2]);
            pc.math.vec3.set(g, a[3], a[4], a[5]);
            pc.math.vec3.set(f, a[6], a[7], a[8]);
            d[0] = pc.math.vec3.length(e);
            d[1] = pc.math.vec3.length(g);
            d[2] = pc.math.vec3.length(f);
            return d
        },toEulerXYZ: function(a, d) {
            void 0 === d && (d = pc.math.vec3.create());
            var b = pc.math.mat3.getScale(a), g, f = Math.asin(-a[2] / b[0]), j;
            g = Math.PI / 2;
            f < g ? f > -g ? (g = Math.atan2(a[5] / b[1], a[8] / b[2]), j = Math.atan2(a[1] / b[0], a[0] / b[0])) : (j = 0, g = -Math.atan2(a[3] / b[1], a[4] / b[1])) : (j = 0, g = Math.atan2(a[3] / b[1], a[4] / b[1]));
            d[0] = g;
            d[1] = f;
            d[2] = j;
            return d
        }}
}();
pc.math.mat4 = function() {
    for (var b = [], a = 0; 3 > a; a++)
        b.push(pc.math.vec3.create());
    return {clone: function(a) {
            return new Float32Array(a)
        },copy: function(a, d) {
            d[0] = a[0];
            d[1] = a[1];
            d[2] = a[2];
            d[3] = a[3];
            d[4] = a[4];
            d[5] = a[5];
            d[6] = a[6];
            d[7] = a[7];
            d[8] = a[8];
            d[9] = a[9];
            d[10] = a[10];
            d[11] = a[11];
            d[12] = a[12];
            d[13] = a[13];
            d[14] = a[14];
            d[15] = a[15];
            return d
        },create: function() {
            var a;
            1 === arguments.length && 16 === arguments[0].length ? a = new Float32Array(arguments[0]) : 16 === arguments.length ? a = new Float32Array(arguments) : (a = new Float32Array(16), 
            a[0] = 1, a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[5] = 1, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[10] = 1, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1);
            return a
        },multiply: function(a, d, b) {
            void 0 === b && (b = pc.math.mat4.create());
            var g = a[0], f = a[1], j = a[2], k = a[3], l = a[4], m = a[5], h = a[6], n = a[7], r = a[8], s = a[9], v = a[10], u = a[11], x = a[12], w = a[13], G = a[14], a = a[15], y = d[0], z = d[1], A = d[2], B = d[3];
            b[0] = g * y + l * z + r * A + x * B;
            b[1] = f * y + m * z + s * A + w * B;
            b[2] = j * y + h * z + v * A + G * B;
            b[3] = k * y + n * z + u * A + a * B;
            y = d[4];
            z = d[5];
            A = d[6];
            B = d[7];
            b[4] = g * y + l * z + r * A + x * B;
            b[5] = f * y + m * z + s * A + w * B;
            b[6] = 
            j * y + h * z + v * A + G * B;
            b[7] = k * y + n * z + u * A + a * B;
            y = d[8];
            z = d[9];
            A = d[10];
            B = d[11];
            b[8] = g * y + l * z + r * A + x * B;
            b[9] = f * y + m * z + s * A + w * B;
            b[10] = j * y + h * z + v * A + G * B;
            b[11] = k * y + n * z + u * A + a * B;
            y = d[12];
            z = d[13];
            A = d[14];
            B = d[15];
            b[12] = g * y + l * z + r * A + x * B;
            b[13] = f * y + m * z + s * A + w * B;
            b[14] = j * y + h * z + v * A + G * B;
            b[15] = k * y + n * z + u * A + a * B;
            return b
        },multiplyVec3: function(a, d, b, g) {
            void 0 === g && (g = pc.math.vec3.create());
            var f, j;
            f = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + d * b[12];
            j = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + d * b[13];
            a = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + d * b[14];
            g[0] = f;
            g[1] = j;
            g[2] = a;
            return g
        },makeLookAt: function(a, d, e, g) {
            void 0 === g && (g = pc.math.mat4.create());
            var f = b[0], j = b[1], k = b[2];
            pc.math.vec3.subtract(a, d, k);
            pc.math.vec3.normalize(k, k);
            pc.math.vec3.normalize(e, j);
            pc.math.vec3.cross(j, k, f);
            pc.math.vec3.normalize(f, f);
            pc.math.vec3.cross(k, f, j);
            g[0] = f[0];
            g[1] = f[1];
            g[2] = f[2];
            g[3] = 0;
            g[4] = j[0];
            g[5] = j[1];
            g[6] = j[2];
            g[7] = 0;
            g[8] = k[0];
            g[9] = k[1];
            g[10] = k[2];
            g[11] = 0;
            g[12] = a[0];
            g[13] = a[1];
            g[14] = a[2];
            g[15] = 1;
            return g
        },makeFrustum: function(a, d, b, g, f, j, k) {
            void 0 === k && (k = pc.math.mat4.create());
            var l = 2 * f, m = d - a, h = g - b, n = j - f;
            k[0] = l / m;
            k[1] = 0;
            k[2] = 0;
            k[3] = 0;
            k[4] = 0;
            k[5] = l / h;
            k[6] = 0;
            k[7] = 0;
            k[8] = (d + a) / m;
            k[9] = (g + b) / h;
            k[10] = (-j - f) / n;
            k[11] = -1;
            k[12] = 0;
            k[13] = 0;
            k[14] = -l * j / n;
            k[15] = 0;
            return k
        },makePerspective: function(a, d, b, g, f) {
            void 0 === f && (f = pc.math.mat4.create());
            a = b * Math.tan(a * Math.PI / 360);
            d *= a;
            return pc.math.mat4.makeFrustum(-d, d, -a, a, b, g, f)
        },makeOrtho: function(a, d, b, g, f, j, k) {
            void 0 === k && (k = pc.math.mat4.create());
            k[0] = 2 / (d - a);
            k[1] = 0;
            k[2] = 0;
            k[3] = 0;
            k[4] = 0;
            k[5] = 2 / (g - b);
            k[6] = 0;
            k[7] = 0;
            k[8] = 0;
            k[9] = 0;
            k[10] = 
            -2 / (j - f);
            k[11] = 0;
            k[12] = -(d + a) / (d - a);
            k[13] = -(g + b) / (g - b);
            k[14] = -(j + f) / (j - f);
            k[15] = 1;
            return k
        },makeRotate: function(a, d, b) {
            void 0 === b && (b = pc.math.mat4.create());
            var g = d[0], f = d[1], d = d[2], a = a * pc.math.DEG_TO_RAD, j = Math.cos(a), a = Math.sin(a), k = 1 - j, l = k * g, m = k * f;
            b[0] = l * g + j;
            b[1] = l * f + a * d;
            b[2] = l * d - a * f;
            b[3] = 0;
            b[4] = l * f - a * d;
            b[5] = m * f + j;
            b[6] = m * d + a * g;
            b[7] = 0;
            b[8] = l * d + a * f;
            b[9] = m * d - g * a;
            b[10] = k * d * d + j;
            b[11] = 0;
            b[12] = 0;
            b[13] = 0;
            b[14] = 0;
            b[15] = 1;
            return b
        },makeTranslate: function(a, d, b, g) {
            void 0 === g && (g = pc.math.mat4.create());
            g[0] = 
            1;
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = 0;
            g[5] = 1;
            g[6] = 0;
            g[7] = 0;
            g[8] = 0;
            g[9] = 0;
            g[10] = 1;
            g[11] = 0;
            g[12] = a;
            g[13] = d;
            g[14] = b;
            g[15] = 1;
            return g
        },makeScale: function(a, d, b, g) {
            void 0 === g && (g = pc.math.mat4.create());
            g[0] = a;
            g[1] = 0;
            g[2] = 0;
            g[3] = 0;
            g[4] = 0;
            g[5] = d;
            g[6] = 0;
            g[7] = 0;
            g[8] = 0;
            g[9] = 0;
            g[10] = b;
            g[11] = 0;
            g[12] = 0;
            g[13] = 0;
            g[14] = 0;
            g[15] = 1;
            return g
        },transpose: function(a, d) {
            void 0 === d && (d = pc.math.mat4.create());
            if (a === d) {
                var b = 0, b = a[1];
                a[1] = a[4];
                a[4] = b;
                b = a[2];
                a[2] = a[8];
                a[8] = b;
                b = a[3];
                a[3] = a[12];
                a[12] = b;
                b = a[6];
                a[6] = a[9];
                a[9] = b;
                b = a[7];
                a[7] = a[13];
                a[13] = b;
                b = a[11];
                a[11] = a[14];
                a[14] = b
            } else
                d[0] = a[0], d[1] = a[4], d[2] = a[8], d[3] = a[12], d[4] = a[1], d[5] = a[5], d[6] = a[9], d[7] = a[13], d[8] = a[2], d[9] = a[6], d[10] = a[10], d[11] = a[14], d[12] = a[3], d[13] = a[7], d[14] = a[11], d[15] = a[15];
            return d
        },invert: function(a, d) {
            void 0 === d && (d = pc.math.mat4.create());
            var b = a[0], g = a[1], f = a[2], j = a[3], k = a[4], l = a[5], m = a[6], h = a[7], n = a[8], r = a[9], s = a[10], v = a[11], u = a[12], x = a[13], w = a[14], G = a[15], y = b * l - g * k, z = b * m - f * k, A = b * h - j * k, B = g * m - f * l, C = g * h - j * l, M = f * h - j * m, H = n * x - r * u, I = n * w - s * u, D = n * G - 
            v * u, E = r * w - s * x, F = r * G - v * x, N = s * G - v * w, L = 1 / (y * N - z * F + A * E + B * D - C * I + M * H);
            d[0] = (l * N - m * F + h * E) * L;
            d[1] = (-g * N + f * F - j * E) * L;
            d[2] = (x * M - w * C + G * B) * L;
            d[3] = (-r * M + s * C - v * B) * L;
            d[4] = (-k * N + m * D - h * I) * L;
            d[5] = (b * N - f * D + j * I) * L;
            d[6] = (-u * M + w * A - G * z) * L;
            d[7] = (n * M - s * A + v * z) * L;
            d[8] = (k * F - l * D + h * H) * L;
            d[9] = (-b * F + g * D - j * H) * L;
            d[10] = (u * C - x * A + G * y) * L;
            d[11] = (-n * C + r * A - v * y) * L;
            d[12] = (-k * E + l * I - m * H) * L;
            d[13] = (b * E - g * I + f * H) * L;
            d[14] = (-u * B + x * z - w * y) * L;
            d[15] = (n * B - r * z + s * y) * L;
            return d
        },getTranslation: function(a, d) {
            void 0 === d && (d = pc.math.vec3.create());
            d[0] = a[12];
            d[1] = a[13];
            d[2] = a[14];
            return d
        },getX: function(a, d) {
            void 0 === d && (d = pc.math.vec3.create());
            d[0] = a[0];
            d[1] = a[1];
            d[2] = a[2];
            return d
        },getY: function(a, d) {
            void 0 === d && (d = pc.math.vec3.create());
            d[0] = a[4];
            d[1] = a[5];
            d[2] = a[6];
            return d
        },getZ: function(a, d) {
            void 0 === d && (d = pc.math.vec3.create());
            d[0] = a[8];
            d[1] = a[9];
            d[2] = a[10];
            return d
        },getScale: function(a, d) {
            void 0 === d && (d = pc.math.vec3.create());
            var e = b[0], g = b[1], f = b[2];
            pc.math.vec3.set(e, a[0], a[1], a[2]);
            pc.math.vec3.set(g, a[4], a[5], a[6]);
            pc.math.vec3.set(f, a[8], 
            a[9], a[10]);
            d[0] = pc.math.vec3.length(e);
            d[1] = pc.math.vec3.length(g);
            d[2] = pc.math.vec3.length(f);
            return d
        },fromEulerXYZ: function(a, d, b, g) {
            void 0 === g && (g = pc.math.mat4.create());
            var a = a * pc.math.DEG_TO_RAD, d = d * pc.math.DEG_TO_RAD, b = b * pc.math.DEG_TO_RAD, f = Math.sin(-a), a = Math.cos(-a), j = Math.sin(-d), d = Math.cos(-d), k = Math.sin(-b), b = Math.cos(-b);
            g[0] = d * b;
            g[1] = -d * k;
            g[2] = j;
            g[4] = a * k + b * f * j;
            g[5] = a * b - f * j * k;
            g[6] = -d * f;
            g[8] = f * k - a * b * j;
            g[9] = b * f + a * j * k;
            g[10] = a * d;
            return g
        },toEulerXYZ: function(a, d) {
            void 0 === d && (d = pc.math.vec3.create());
            var b = pc.math.mat4.getScale(a), g, f = Math.asin(-a[2] / b[0]), j;
            g = Math.PI / 2;
            f < g ? f > -g ? (g = Math.atan2(a[6] / b[1], a[10] / b[2]), j = Math.atan2(a[1] / b[0], a[0] / b[0])) : (j = 0, g = -Math.atan2(a[4] / b[1], a[5] / b[1])) : (j = 0, g = Math.atan2(a[4] / b[1], a[5] / b[1]));
            d[0] = g * pc.math.RAD_TO_DEG;
            d[1] = f * pc.math.RAD_TO_DEG;
            d[2] = j * pc.math.RAD_TO_DEG;
            return d
        },toQuat: function(a, d) {
            void 0 === d && (d = pc.math.quat.create());
            var b = a[0], g = a[1], f = a[2], j = a[4], k = a[5], l = a[6], m = a[8], h = a[9], n = a[10], r = Math.sqrt(b * b + g * g + f * f), s = Math.sqrt(j * j + k * k + l * l), v = Math.sqrt(m * 
            m + h * h + n * n), b = b / r, g = g / r, f = f / r, j = j / s, k = k / s, l = l / s, m = m / v, h = h / v, n = n / v, r = b + k + n;
            0 <= r ? (b = Math.sqrt(r + 1), d[3] = 0.5 * b, b = 0.5 / b, d[0] = (l - h) * b, d[1] = (m - f) * b, d[2] = (g - j) * b) : b > k ? b > n ? (b = Math.sqrt(b - (k + n) + 1), d[0] = 0.5 * b, b = 0.5 / b, d[3] = (l - h) * b, d[1] = (g + j) * b, d[2] = (f + m) * b) : (b = Math.sqrt(n - (b + k) + 1), d[2] = 0.5 * b, b = 0.5 / b, d[3] = (g - j) * b, d[0] = (m + f) * b, d[1] = (h + l) * b) : k > n ? (b = Math.sqrt(k - (n + b) + 1), d[1] = 0.5 * b, b = 0.5 / b, d[3] = (m - f) * b, d[2] = (l + h) * b, d[0] = (j + g) * b) : (b = Math.sqrt(n - (b + k) + 1), d[2] = 0.5 * b, b = 0.5 / b, d[3] = (g - j) * b, d[0] = (m + f) * b, d[1] = (h + l) * b);
            return d
        },
        compose: function(a, b, e, g) {
            void 0 === g && (g = pc.math.mat4.create());
            var f = b[0], j = b[1], k = b[2], l = b[3], m = f + f, h = j + j, n = k + k, b = f * m, r = f * h, f = f * n, s = j * h, j = j * n, k = k * n, m = l * m, h = l * h, l = l * n;
            g[0] = (1 - (s + k)) * e[0];
            g[1] = (r + l) * e[0];
            g[2] = (f - h) * e[0];
            g[3] = 0;
            g[4] = (r - l) * e[1];
            g[5] = (1 - (b + k)) * e[1];
            g[6] = (j + m) * e[1];
            g[7] = 0;
            g[8] = (f + h) * e[2];
            g[9] = (j - m) * e[2];
            g[10] = (1 - (b + s)) * e[2];
            g[11] = 0;
            g[12] = a[0];
            g[13] = a[1];
            g[14] = a[2];
            g[15] = 1;
            return g
        }}
}();
pc.math.quat = function() {
    return {clone: function(b) {
            return new Float32Array(b)
        },conjugate: function(b, a) {
            void 0 === a && (a = pc.math.quat.create());
            a[0] = -b[0];
            a[1] = -b[1];
            a[2] = -b[2];
            a[3] = b[3];
            return a
        },copy: function(b, a) {
            a[0] = b[0];
            a[1] = b[1];
            a[2] = b[2];
            a[3] = b[3]
        },create: function() {
            var b = new Float32Array(4);
            0 === arguments.length ? (b[0] = 0, b[1] = 0, b[2] = 0, b[3] = 1) : 4 === arguments.length && (b[0] = arguments[0], b[1] = arguments[1], b[2] = arguments[2], b[3] = arguments[3]);
            return b
        },invert: function(b, a) {
            var c = b[0], d = b[1], e = b[2], g = 
            b[3], c = (c = c * c + d * d + e * e + g * g) ? 1 / c : 0;
            if (!a || b === a)
                return b[0] *= -c, b[1] *= -c, b[2] *= -c, b[3] *= c, b;
            a[0] = -b[0] * c;
            a[1] = -b[1] * c;
            a[2] = -b[2] * c;
            a[3] = b[3] * c;
            return a
        },transformVector: function(b, a, c) {
            void 0 === c && (c = pc.math.vec3.create());
            var d = a[0], e = a[1], g = a[2], a = b[0], f = b[1], j = b[2], b = b[3], k = b * d + f * g - j * e, l = b * e + j * d - a * g, m = b * g + a * e - f * d, d = -a * d - f * e - j * g;
            c[0] = k * b + d * -a + l * -j - m * -f;
            c[1] = l * b + d * -f + m * -a - k * -j;
            c[2] = m * b + d * -j + k * -f - l * -a;
            return c
        },multiply: function(b, a, c) {
            var d = b[3] * a[1] + b[1] * a[3] + b[2] * a[0] - b[0] * a[2], e = b[3] * a[2] + b[2] * 
            a[3] + b[0] * a[1] - b[1] * a[0], g = b[3] * a[3] - b[0] * a[0] - b[1] * a[1] - b[2] * a[2];
            c[0] = b[3] * a[0] + b[0] * a[3] + b[1] * a[2] - b[2] * a[1];
            c[1] = d;
            c[2] = e;
            c[3] = g
        },setFromAxisAngle: function(b, a, c) {
            var d = 0.5 * c * (Math.PI / 180), c = Math.sin(d), d = Math.cos(d);
            b[0] = c * a[0];
            b[1] = c * a[1];
            b[2] = c * a[2];
            b[3] = d
        },setFromEulers: function(b, a, c, d) {
            var a = 0.5 * a * Math.PI / 180, c = 0.5 * c * Math.PI / 180, d = 0.5 * d * Math.PI / 180, e = Math.sin(a), a = Math.cos(a), g = Math.sin(c), c = Math.cos(c), f = Math.sin(d), d = Math.cos(d);
            b[0] = e * c * d - a * g * f;
            b[1] = a * g * d + e * c * f;
            b[2] = a * c * f - e * g * d;
            b[3] = 
            a * c * d + e * g * f
        },toEulers: function(b, a) {
            void 0 === a && (a = pc.math.vec3.create());
            var c = b[0], d = b[1], e = b[2], g = b[3], f = 2 * (g * d - c * e), j;
            -0.99999 >= f ? (j = 2 * Math.atan2(c, g), f = -Math.PI / 2, c = 0) : 0.99999 <= f ? (j = 2 * Math.atan2(c, g), f = Math.PI / 2, c = 0) : (j = Math.atan2(2 * (g * c + d * e), 1 - 2 * (c * c + d * d)), f = Math.asin(f), c = Math.atan2(2 * (g * e + c * d), 1 - 2 * (d * d + e * e)));
            a[0] = j * pc.math.RAD_TO_DEG;
            a[1] = f * pc.math.RAD_TO_DEG;
            a[2] = c * pc.math.RAD_TO_DEG;
            return a
        },normalize: function(b, a) {
            a || (a = b);
            var c = b[0], d = b[1], e = b[2], g = b[3], f = Math.sqrt(c * c + d * d + e * e + g * g);
            if (0 === f)
                return a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 0, a;
            f = 1 / f;
            a[0] = c * f;
            a[1] = d * f;
            a[2] = e * f;
            a[3] = g * f;
            return a
        },toMat3: function(b, a) {
            void 0 === a && (a = pc.math.mat4.create());
            var c = b[0] * b[0] + b[1] * b[1] + b[2] * b[2] + b[3] * b[3], d = 0 == c ? 0 : 2 / c, e = b[0] * d, c = b[1] * d, g = b[2] * d, d = b[3] * e, f = b[3] * c, j = b[3] * g, k = b[0] * e, l = b[1] * c, m = b[2] * g, g = b[1] * g, e = b[2] * e, c = b[0] * c;
            a[0] = 1 - (l + m);
            a[1] = c - j;
            a[2] = e + f;
            a[3] = c + j;
            a[4] = 1 - (k + m);
            a[5] = g - d;
            a[6] = e - f;
            a[7] = g + d;
            a[8] = 1 - (k + l);
            return a
        },toMat4: function(b, a) {
            void 0 === a && (a = pc.math.mat4.create());
            var c = b[0] * b[0] + 
            b[1] * b[1] + b[2] * b[2] + b[3] * b[3], d = 0 < c ? 2 / c : 0, e = b[0] * d, c = b[1] * d, g = b[2] * d, d = b[3] * e, f = b[3] * c, j = b[3] * g, k = b[0] * e, l = b[1] * c, m = b[2] * g, g = b[1] * g, e = b[2] * e, c = b[0] * c;
            a[0] = 1 - (l + m);
            a[1] = c + j;
            a[2] = e - f;
            a[3] = 0;
            a[4] = c - j;
            a[5] = 1 - (k + m);
            a[6] = g + d;
            a[7] = 0;
            a[8] = e + f;
            a[9] = g - d;
            a[10] = 1 - (k + l);
            a[11] = 0;
            a[12] = 0;
            a[13] = 0;
            a[14] = 0;
            a[15] = 1;
            return a
        },slerp: function(b, a, c, d) {
            void 0 === d && (d = pc.math.quat.create());
            var e = b[0] * a[0] + b[1] * a[1] + b[2] * a[2] + b[3] * a[3], g = 0 > e;
            g && (e = -e);
            var f = 1 - c;
            if (!(1 <= e)) {
                var e = Math.acos(e), j = 1 / Math.sin(e), f = Math.sin(e * 
                f) * j, c = Math.sin(e * c) * j;
                g && (c = -c)
            }
            d[0] = f * b[0] + c * a[0];
            d[1] = f * b[1] + c * a[1];
            d[2] = f * b[2] + c * a[2];
            d[3] = f * b[3] + c * a[3];
            return d
        }}
}();
pc.shape = function() {
    var b = function() {
    };
    b.prototype = {containsPoint: function() {
            throw Error("Shape hasn't implemented containsPoint");
        }};
    return {Shape: b,Type: {CONE: "Cone",CYLINDER: "Cylinder",CIRCLE: "Circle",RECT: "Rect"}}
}();
pc.shape.intersection = function() {
    return {aabbAabb: function(b, a) {
            var c = b.getMax(), d = b.getMin(), e = a.getMax(), g = a.getMin();
            return d[0] <= e[0] && c[0] >= g[0] && d[1] <= e[1] && c[1] >= g[1] && d[2] <= e[2] && c[2] >= g[2]
        },rayAabb: function(b, a, c) {
            var d = pc.math.vec3.create(), e, g = pc.math.vec3.create();
            e = pc.math.vec3.create();
            var f;
            pc.math.vec3.subtract(b, c.center, d);
            b = pc.math.vec3.create(Math.abs(d[0]), Math.abs(d[1]), Math.abs(d[2]));
            pc.math.vec3.multiply(d, a, e);
            for (f = 0; 3 > f; ++f)
                if (b[f] > c.halfExtents[f] && 0 <= e[f])
                    return !1;
            e = pc.math.vec3.create(Math.abs(a[0]), 
            Math.abs(a[1]), Math.abs(a[2]));
            pc.math.vec3.cross(a, d, g);
            g[0] = Math.abs(g[0]);
            g[1] = Math.abs(g[1]);
            g[2] = Math.abs(g[2]);
            return g[0] > c.halfExtents[1] * e[2] + c.halfExtents[2] * e[1] || g[1] > c.halfExtents[0] * e[2] + c.halfExtents[2] * e[0] || g[2] > c.halfExtents[0] * e[1] + c.halfExtents[1] * e[0] ? !1 : !0
        },raySphere: function(b, a, c, d) {
            var e = pc.math.vec3.create(), g = 0, f = 0, j = 0, j = 0, d = d || {};
            pc.math.vec3.subtract(b, c.center, e);
            if (pc.math.vec3.dot(e, e) < c.radius * c.radius)
                return d.success = !0, d.t = 0, !0;
            g = pc.math.vec3.dot(a, a);
            f = 2 * pc.math.vec3.dot(a, 
            e);
            j = pc.math.vec3.dot(c.center, c.center);
            j += pc.math.vec3.dot(b, b);
            j -= 2 * pc.math.vec3.dot(c.center, b);
            j -= c.radius * c.radius;
            j = f * f - 4 * g * j;
            if (0 > j)
                return d.success = !1, d.t = 0, !1;
            d.success = !0;
            d.t = (-f - Math.sqrt(j)) / (2 * g);
            return !0
        },rayTriangle: function(b, a, c, d) {
            var e = pc.math.vec3.create();
            pc.math.vec3.sub(b, c.v0, e);
            var e = -pc.math.vec3.dot(c.n, e), g = pc.math.vec3.dot(c.n, a);
            if (1E-8 > Math.fabs(g))
                return 0 === e ? 2 : 0;
            e /= g;
            if (0 > e)
                return 0;
            g = pc.math.vec3.create();
            pc.math.vec3.scale(a, e, g);
            pc.math.vec3.add(b, g, d);
            b = pc.math.vec3.create();
            pc.math.vec3.sub(d, c.v0, b);
            d = pc.math.vec3.dot(b, c.u);
            b = pc.math.vec3.dot(b, c.v);
            a = (c.uv * b - c.vv * d) / c.d;
            if (0 > a || 1 < a)
                return 0;
            c = (c.uv * d - c.uu * b) / c.d;
            return 0 > c || 1 < a + c ? 0 : 1
        }}
}();
pc.extend(pc.shape, function() {
    pc.shape.Type.AABB = "Aabb";
    var b = function(a, b) {
        this.center = a || pc.math.vec3.create(0, 0, 0);
        this.halfExtents = b || pc.math.vec3.create(0.5, 0.5, 0.5);
        this.type = pc.shape.Type.AABB
    }, b = pc.inherits(b, pc.shape.Shape);
    b.prototype.add = function(a) {
        var b = this.center, d = this.halfExtents, e = b[0] - d[0], g = b[0] + d[0], f = b[1] - d[1], j = b[1] + d[1], k = b[2] - d[2], l = b[2] + d[2], m = a.center, h = a.halfExtents, a = m[0] - h[0], n = m[0] + h[0], r = m[1] - h[1], s = m[1] + h[1], v = m[2] - h[2], m = m[2] + h[2];
        a < e && (e = a);
        n > g && (g = n);
        r < f && (f = r);
        s > j && (j = s);
        v < k && (k = v);
        m > l && (l = m);
        b[0] = 0.5 * (e + g);
        b[1] = 0.5 * (f + j);
        b[2] = 0.5 * (k + l);
        d[0] = 0.5 * (g - e);
        d[1] = 0.5 * (j - f);
        d[2] = 0.5 * (l - k)
    };
    b.prototype.copy = function(a) {
        pc.math.vec3.copy(a.center, this.center);
        pc.math.vec3.copy(a.halfExtents, this.halfExtents);
        this.type = a.type
    };
    b.prototype.setMinMax = function(a, b) {
        this.center[0] = 0.5 * (a[0] + b[0]);
        this.center[1] = 0.5 * (a[1] + b[1]);
        this.center[2] = 0.5 * (a[2] + b[2]);
        this.halfExtents[0] = 0.5 * (b[0] - a[0]);
        this.halfExtents[1] = 0.5 * (b[1] - a[1]);
        this.halfExtents[2] = 0.5 * (b[2] - a[2])
    };
    b.prototype.getMin = 
    function() {
        var a = pc.math.vec3.create(0, 0, 0);
        pc.math.vec3.subtract(this.center, this.halfExtents, a);
        return a
    };
    b.prototype.getMax = function() {
        var a = pc.math.vec3.create(0, 0, 0);
        pc.math.vec3.add(this.center, this.halfExtents, a);
        return a
    };
    b.prototype.containsPoint = function(a) {
        var b = this.getMin(), d = this.getMax(), e;
        for (e = 0; 3 > e; ++e)
            if (a[e] < b[e] || a[e] > d[e])
                return !1;
        return !0
    };
    b.prototype.setFromTransformedAabb = function(a, b) {
        var d = this.center, e = this.halfExtents, g = a.center, f = a.halfExtents, j = b[0], k = b[4], l = b[8], m = 
        b[1], h = b[5], n = b[9], r = b[2], s = b[6], v = b[10], u = Math.abs(j), x = Math.abs(k), w = Math.abs(l), G = Math.abs(m), y = Math.abs(h), z = Math.abs(n), A = Math.abs(r), B = Math.abs(s), C = Math.abs(v);
        d[0] = b[12] + j * g[0] + k * g[1] + l * g[2];
        d[1] = b[13] + m * g[0] + h * g[1] + n * g[2];
        d[2] = b[14] + r * g[0] + s * g[1] + v * g[2];
        e[0] = u * f[0] + x * f[1] + w * f[2];
        e[1] = G * f[0] + y * f[1] + z * f[2];
        e[2] = A * f[0] + B * f[1] + C * f[2]
    };
    b.prototype.compute = function(a) {
        for (var b = pc.math.vec3.create(a[0], a[1], a[2]), d = pc.math.vec3.create(a[0], a[1], a[2]), e = a.length / 3, g = 1; g < e; g++)
            a[3 * g + 0] < b[0] && (b[0] = 
            a[3 * g + 0]), a[3 * g + 1] < b[1] && (b[1] = a[3 * g + 1]), a[3 * g + 2] < b[2] && (b[2] = a[3 * g + 2]), a[3 * g + 0] > d[0] && (d[0] = a[3 * g + 0]), a[3 * g + 1] > d[1] && (d[1] = a[3 * g + 1]), a[3 * g + 2] > d[2] && (d[2] = a[3 * g + 2]);
        this.setMinMax(b, d)
    };
    return {Aabb: b}
}());
pc.extend(pc.shape, function() {
    pc.shape.Type.BOX = "Box";
    var b = function(a, b) {
        a || (a = pc.math.mat4.create());
        b || (b = pc.math.vec3.create(0.5, 0.5, 0.5));
        this.transform = a;
        this.halfExtents = b;
        this.type = pc.shape.Type.BOX
    }, b = pc.inherits(b, pc.shape.Shape);
    b.prototype.containsPoint = function(a) {
        var b = pc.math.vec3.clone(a);
        pc.math.mat4.getTranslation(this.transform);
        var d = this.getHalfExtents(), e = [-0.5, -0.5, -0.5];
        max = [0.5, 0.5, 0.5];
        var g = pc.math.mat4.clone(this.transform), d = pc.math.mat4.makeScale(2 * d[0], 2 * d[1], 2 * d[2]);
        pc.math.mat4.multiply(g, d, g);
        g = pc.math.mat4.invert(g);
        pc.math.mat4.multiplyVec3(a, 1, g, b);
        for (i = 0; 3 > i; ++i)
            if (b[i] < e[i] || b[i] > max[i])
                return !1;
        return !0
    };
    b.prototype.getHalfExtents = function() {
        return this.halfExtents
    };
    return {Box: b}
}());
pc.extend(pc.shape, function() {
    pc.shape.Type.FRUSTUM = "Frustum";
    var b = pc.math.mat4.create(), a = pc.math.mat4.makePerspective(90, 16 / 9, 0.1, 1E3), c = pc.math.mat4.create(), d = function(d, c) {
        d = d || a;
        c = c || b;
        this.planes = [];
        for (var f = 0; 6 > f; f++)
            this.planes[f] = [];
        this.update(d, c);
        this.type = pc.shape.Type.FRUSTUM
    }, d = pc.inherits(d, pc.shape.Shape);
    d.prototype.update = function(a, b) {
        pc.math.mat4.multiply(a, b, c);
        this.planes[0][0] = c[3] - c[0];
        this.planes[0][1] = c[7] - c[4];
        this.planes[0][2] = c[11] - c[8];
        this.planes[0][3] = c[15] - c[12];
        t = Math.sqrt(this.planes[0][0] * this.planes[0][0] + this.planes[0][1] * this.planes[0][1] + this.planes[0][2] * this.planes[0][2]);
        this.planes[0][0] /= t;
        this.planes[0][1] /= t;
        this.planes[0][2] /= t;
        this.planes[0][3] /= t;
        this.planes[1][0] = c[3] + c[0];
        this.planes[1][1] = c[7] + c[4];
        this.planes[1][2] = c[11] + c[8];
        this.planes[1][3] = c[15] + c[12];
        t = Math.sqrt(this.planes[1][0] * this.planes[1][0] + this.planes[1][1] * this.planes[1][1] + this.planes[1][2] * this.planes[1][2]);
        this.planes[1][0] /= t;
        this.planes[1][1] /= t;
        this.planes[1][2] /= 
        t;
        this.planes[1][3] /= t;
        this.planes[2][0] = c[3] + c[1];
        this.planes[2][1] = c[7] + c[5];
        this.planes[2][2] = c[11] + c[9];
        this.planes[2][3] = c[15] + c[13];
        t = Math.sqrt(this.planes[2][0] * this.planes[2][0] + this.planes[2][1] * this.planes[2][1] + this.planes[2][2] * this.planes[2][2]);
        this.planes[2][0] /= t;
        this.planes[2][1] /= t;
        this.planes[2][2] /= t;
        this.planes[2][3] /= t;
        this.planes[3][0] = c[3] - c[1];
        this.planes[3][1] = c[7] - c[5];
        this.planes[3][2] = c[11] - c[9];
        this.planes[3][3] = c[15] - c[13];
        t = Math.sqrt(this.planes[3][0] * this.planes[3][0] + 
        this.planes[3][1] * this.planes[3][1] + this.planes[3][2] * this.planes[3][2]);
        this.planes[3][0] /= t;
        this.planes[3][1] /= t;
        this.planes[3][2] /= t;
        this.planes[3][3] /= t;
        this.planes[4][0] = c[3] - c[2];
        this.planes[4][1] = c[7] - c[6];
        this.planes[4][2] = c[11] - c[10];
        this.planes[4][3] = c[15] - c[14];
        t = Math.sqrt(this.planes[4][0] * this.planes[4][0] + this.planes[4][1] * this.planes[4][1] + this.planes[4][2] * this.planes[4][2]);
        this.planes[4][0] /= t;
        this.planes[4][1] /= t;
        this.planes[4][2] /= t;
        this.planes[4][3] /= t;
        this.planes[5][0] = c[3] + 
        c[2];
        this.planes[5][1] = c[7] + c[6];
        this.planes[5][2] = c[11] + c[10];
        this.planes[5][3] = c[15] + c[14];
        t = Math.sqrt(this.planes[5][0] * this.planes[5][0] + this.planes[5][1] * this.planes[5][1] + this.planes[5][2] * this.planes[5][2]);
        this.planes[5][0] /= t;
        this.planes[5][1] /= t;
        this.planes[5][2] /= t;
        this.planes[5][3] /= t
    };
    d.prototype.containsPoint = function(a) {
        for (var b = 0; 6 > b; b++)
            if (0 >= this.planes[b][0] * a[0] + this.planes[b][1] * a[1] + this.planes[b][2] * a[2] + this.planes[b][3])
                return !1;
        return !0
    };
    d.prototype.containsSphere = function(a) {
        var b = 
        0, d;
        for (p = 0; 6 > p; p++) {
            d = this.planes[p][0] * a.center[0] + this.planes[p][1] * a.center[1] + this.planes[p][2] * a.center[2] + this.planes[p][3];
            if (d <= -a.radius)
                return 0;
            d > a.radius && b++
        }
        return 6 === b ? 2 : 1
    };
    return {Frustum: d}
}());
pc.extend(pc.shape, function() {
    pc.shape.Type.PLANE = "Plane";
    var b = function(a, b) {
        this.normal = b || pc.math.vec3.create(0, 0, 1);
        this.point = a || pc.math.vec3.create(0, 0, 0);
        this.d = -pc.math.vec3.dot(this.normal, this.point);
        this.type = pc.shape.Type.PLANE
    }, b = pc.inherits(b, pc.shape.Shape);
    b.prototype.containsPoint = function() {
        return !1
    };
    b.prototype.distance = function(a) {
        return pc.math.vec3.dot(this.normal, a) + this.d
    };
    b.prototype.intersect = function(a, b) {
        var d = this.distance(a), e = this.distance(b);
        return d / (d - e)
    };
    b.prototype.intersectPosition = 
    function(a, b) {
        var d = this.intersect(a, b), e = pc.math.vec3.create();
        pc.math.vec3.lerp(a, b, d, e);
        return e
    };
    return {Plane: b}
}());
pc.extend(pc.shape, function() {
    pc.shape.Type.SPHERE = "Sphere";
    var b = function(a, b) {
        this.center = a || pc.math.vec3.create(0, 0, 0);
        this.radius = b || 1;
        this.type = pc.shape.Type.SPHERE
    }, b = pc.inherits(b, pc.shape.Shape);
    b.prototype.containsPoint = function(a) {
        var b = pc.math.vec3.create();
        pc.math.vec3.subtract(a, this.center, b);
        return pc.math.vec3.length(b) < this.radius
    };
    b.prototype.compute = function(a) {
        var b, d = a.length / 3, e = pc.math.vec3.create(0, 0, 0), g = pc.math.vec3.create(0, 0, 0), f = pc.math.vec3.create(0, 0, 0);
        for (b = 0; b < d; b++)
            pc.math.vec3.set(e, 
            a[3 * b], a[3 * b + 1], a[3 * b + 2]), pc.math.vec3.add(f, e, f), 0 === b % 100 && (pc.math.vec3.scale(f, 1 / d, f), pc.math.vec3.add(g, f, g), pc.math.vec3.set(f, 0, 0, 0));
        pc.math.vec3.scale(f, 1 / d, f);
        pc.math.vec3.add(g, f, g);
        pc.math.vec3.set(f, 0, 0, 0);
        this.center = g;
        g = 0;
        f = pc.math.vec3.create(0, 0, 0);
        for (b = 0; b < d; b++) {
            pc.math.vec3.set(e, a[3 * b], a[3 * b + 1], a[3 * b + 2]);
            pc.math.vec3.subtract(e, this.center, f);
            var j = pc.math.vec3.dot(f, f);
            j > g && (g = j)
        }
        this.radius = Math.sqrt(g)
    };
    return {Sphere: b}
}());
pc.extend(pc.shape, function() {
    pc.shape.Type.TORUS = "Torus";
    var b = function(a, b, d) {
        this.transform = a;
        this.iradius = b;
        this.oradius = d;
        this.type = pc.shape.Type.TORUS
    }, b = pc.inherits(b, pc.shape.Shape);
    b.prototype.containsPoint = function() {
        throw Error("Not implemented yet");
    };
    return {Torus: b}
}());
pc.resources = function() {
    var b = function(a) {
        a = a || {};
        a.maxConcurrentRequests = a.maxConcurrentRequests || 32;
        this._loading = [];
        this._pending = [];
        this._batches = [];
        this._handlers = {};
        this._types = {};
        this._requests = {};
        this._hashes = {};
        this._canonicals = {};
        this._cache = {};
        this._batchId = this._sequence = 1;
        this._maxConcurrentRequests = a.maxConcurrentRequests;
        pc.extend(this, pc.events)
    };
    b.prototype.registerHandler = function(a, b) {
        var c = new a;
        if ("" == c.type)
            throw Error("ResourceRequests must have a type");
        this._types[c.type] = 
        a;
        this._handlers[c.type] = b;
        b.setLoader(this)
    };
    b.prototype.createFileRequest = function(a, b) {
        return new this._types[b](a)
    };
    b.prototype.registerHash = function(a, b) {
        this._hashes[b] || (this._hashes[b] = a);
        this._canonicals[a] || (this._canonicals[a] = b)
    };
    b.prototype.getHash = function(a) {
        return this._hashes[a]
    };
    b.prototype.addToCache = function(a, b) {
        var c = this.getHash(a);
        c ? this._cache[c] = b : logWARNING(pc.string.format("Could not add {0} to cache, no hash registered", a))
    };
    b.prototype.getFromCache = function(a) {
        return (a = 
        this.getHash(a)) ? this._cache[a] : null
    };
    b.prototype.getCanonicalIdentifier = function(a) {
        var b = this.getHash(a);
        return this._canonicals[b] ? this._canonicals[b] : a
    };
    b.prototype.request = function(a, b, g, f, j, k) {
        var l = null, m = this;
        "function" == typeof b && (k = j, j = f, f = g, g = b, b = 1);
        k = k || {};
        a.length || (a = [a]);
        l = new c(this._batchId++, a, b, g, f, function() {
            var a = this.getProgress();
            m.fire("batchprogress", m, l);
            j && j(a)
        });
        if (k.batch) {
            g = this.getRequestBatch(k.batch);
            if (!g)
                throw Error(pc.string.format("Cannot find batch with handle '{0}'", 
                k.batch));
            g.children.push(l);
            l.parent = g;
            l.priority = g.priority
        }
        a.forEach(function(a) {
            a.canonical = this.getCanonicalIdentifier(a.identifier);
            if (this._requests[a.canonical]) {
                var d = this._requests[a.canonical];
                d.batches.push(l);
                d.alternatives.push(a.identifier);
                d.priority = Math.min(d.priority, b)
            } else
                a.batches = [], a.batches.push(l), a.priority = l.priority, a.sequence = this._sequence++, this._requests[a.canonical] = a, this._pending.push(a.canonical)
        }, this);
        this._sort();
        this.fire("newbatch", this, l);
        this._batches.push(l);
        this._update();
        return l.handle
    };
    b.prototype.open = function(a, b, c, f, j, k) {
        a = new a;
        return this._handlers[a.type].open(b, c, f, j, k)
    };
    b.prototype.cancel = function(a) {
        for (var b = 0, c = this._batches.length, f, b = 0; b < c; ++b)
            f = this._batches[b], f.handle == a && f.requests.forEach(function(a, b) {
                b = this._pending.indexOf(a.identifier);
                0 <= b && this._pending.splice(b, 1)
            }, this)
    };
    b.prototype.getProgress = function() {
        var a, b = this._batches.length, c = 0;
        for (a = 0; a < b; a++)
            c += this._batches[a].getProgress();
        return c / b
    };
    b.prototype.getRequestBatch = 
    function(a) {
        var b, c = this._batches.length;
        for (b = 0; b < c; ++b)
            if (this._batches[b].handle == a)
                return this._batches[b];
        return null
    };
    b.prototype._sort = function() {
        this._pending.sort(function(a, b) {
            var c = this._requests[a].priority - this._requests[b].priority;
            return 0 == c ? this._requests[a].sequence - this._requests[b].sequence : c
        }.bind(this))
    };
    b.prototype._update = function() {
        for (; 0 < this._pending.length && this._loading.length < this._maxConcurrentRequests; )
            (function() {
                var a = this._requests[this._pending.shift()];
                this._loading.push(a.canonical);
                var b = {priority: a.priority,batch: a.batches[0].handle}, c = this._handlers[a.type];
                this.fire("loading", this, a);
                var f = this.getFromCache(a.canonical);
                if (f) {
                    logDEBUG(pc.string.format("Found {0} in cache", a.canonical));
                    this._completeRequest(a);
                    var j, k = a.batches.length;
                    for (j = 0; j < k; j++)
                        this._afterOpened(a, f, c, a.batches[j], b)
                } else
                    logDEBUG(pc.string.format("Cache miss: {0}", a.canonical)), c.load(a.canonical, function(b, e) {
                        this._completeRequest(a);
                        var f, j = a.batches.length;
                        for (f = 0; f < j; f++) {
                            var k = c.open(b, e);
                            this._afterOpened(a, 
                            k, c, a.batches[f], e)
                        }
                        this._update()
                    }.bind(this), function(b) {
                        this._completeRequest(a);
                        a.batches.forEach(function(c) {
                            this.fire("error", this, a, c, b);
                            c.addResourceError(a, b) && this._completeBatch(c)
                        }, this)
                    }.bind(this), function(b) {
                        a.batches.forEach(function(c) {
                            this.fire("requestprogress", this, a, c, b)
                        }, this)
                    }.bind(this), b)
            }).call(this)
    };
    b.prototype._afterOpened = function(a, b, c, f, j) {
        c.postOpen(b, function(b) {
            this.addToCache(a.canonical, b);
            b = c.clone(b);
            f.addResource(a, b) && this._completeBatch(f);
            this.fire("loaded", 
            this, a, f, b)
        }.bind(this), function(a) {
            f.error && f.error(a);
            f.parent && f.parent.error(a)
        }, function(a) {
            f.progress && f.progress(a)
        }, j)
    };
    b.prototype._completeRequest = function(a) {
        delete this._requests[a.canonical];
        this._loading.splice(this._loading.indexOf(a.canonical), 1)
    };
    b.prototype._completeBatch = function(a) {
        this._batches.splice(this._batches.indexOf(a), 1);
        this.fire("batchcomplete", this, a)
    };
    var a = function() {
    };
    a.prototype = {setLoader: function(a) {
            this._loader = a
        },getFromCache: function(a) {
            var b = this._loader.getHash(a), 
            c = null;
            b && (c = this._loader.getFromCache(b)) && console.log("Found in cache: " + a);
            return c
        },addToCache: function(a, b) {
            var c = this._loader.getHash(a);
            c ? (logDEBUG("Added to cache: " + a), this._loader.addToCache(c, b)) : logWARNING(pc.string.format("Could not add resource {0} to cache, no hash stored", a))
        },load: function() {
            throw Error("Not implemented");
        },open: function() {
            throw Error("Not implemented");
        },postOpen: function(a, b) {
            b(a)
        },clone: function(a) {
            return a
        }};
    var c = function(a, b, c, f, j, k) {
        this.handle = a;
        this.requests = 
        b;
        this.count = 0;
        this.resources = {};
        this.errors = {};
        this.parent = null;
        this.children = [];
        this.priority = c;
        this.success = f;
        this.error = j;
        this.progress = k;
        this.errored = this.completed = !1
    };
    c.prototype.addResource = function(a, b) {
        this.resources[a.identifier] = b;
        var c, f = a.alternatives.length;
        for (c = 0; c < f; c++)
            this.resources[a.alternatives[c]] = b;
        this.count += 1;
        return this._update()
    };
    c.prototype.addResourceError = function(a, b) {
        this.errored = !0;
        this.errors[a.identifier] = b;
        var c, f = a.alternatives.length;
        for (c = 0; c < f; c++)
            this.errors[a.alternatives[c]] = 
            b;
        this.count += 1;
        return this._update()
    };
    c.prototype.getProgress = function() {
        return this._getCount() / this._getTotal()
    };
    c.prototype.isComplete = function() {
        var a, b = this.children.length;
        for (a = 0; a < b; ++a)
            if (!this.children[a].isComplete())
                return !1;
        return this.count == this.requests.length
    };
    c.prototype._updateProgress = function() {
        this.progress && this.progress(this.getProgress())
    };
    c.prototype._update = function() {
        this._updateProgress();
        return this.isComplete() ? (this.completed = !0, this.errored ? (this.error && this.error(this.errors, 
        this.resources), this.parent && this.parent.error(this.errors, this.resources)) : this.success && this.success(this.resources), this.parent && !this.parent.completed && this.parent._update(), !0) : !1
    };
    c.prototype._getCount = function() {
        var a = this.count, b, c = this.children.length;
        for (b = 0; b < c; ++b)
            a += this.children[b]._getCount();
        return a
    };
    c.prototype._getTotal = function() {
        var a = this.requests.length, b, c = this.children.length;
        for (b = 0; b < c; ++b)
            a += this.children[b]._getTotal();
        return a
    };
    return {ResourceLoader: b,ResourceHandler: a,
        ResourceRequest: function(a) {
            this.canonical = this.identifier = a;
            this.alternatives = []
        }}
}();
pc.extend(pc.resources, function() {
    var b = function(a, b) {
        b.on("newbatch", this.handleNewBatch, this);
        b.on("loading", this.handleLoading, this);
        b.on("loaded", this.handleLoaded, this);
        b.on("error", this.handleError, this);
        b.on("batchprogress", this.handleBatchProgress, this);
        this.addCss();
        this._element = a;
        this._domCreate()
    };
    b.prototype.addCss = function() {
        var a = document.createElement("style");
        document.getElementsByTagName("head")[0].appendChild(a);
        if (a.styleSheet)
            a.styleSheet.cssText = ".pc-resourceloaderdisplay-root {\n   font-family: sans-serif;\n   font-size: 0.7em;\n   color: #aaa;\n   border-collapse: collapse;\n   position: absolute;\n   top: 10px;\n   left: 10px;\n   background-color: black;\n   opacity: 0.6;\n}\n.pc-resourceloaderdisplay-root td {\n   border: 1px solid #aaa;\n}\n.pc-resourceloaderdisplay-subtable {\n   border-collapse: collapse;\n}";
        else {
            var b = document.createTextNode(".pc-resourceloaderdisplay-root {\n   font-family: sans-serif;\n   font-size: 0.7em;\n   color: #aaa;\n   border-collapse: collapse;\n   position: absolute;\n   top: 10px;\n   left: 10px;\n   background-color: black;\n   opacity: 0.6;\n}\n.pc-resourceloaderdisplay-root td {\n   border: 1px solid #aaa;\n}\n.pc-resourceloaderdisplay-subtable {\n   border-collapse: collapse;\n}");
            a.appendChild(b)
        }
    };
    b.prototype._domCreate = function() {
        this._rootTable = document.createElement("table");
        this._rootTable.setAttribute("class", "pc-resourceloaderdisplay-root");
        this._element.appendChild(this._rootTable)
    };
    b.prototype._domAddBatch = function(a) {
        var b = document.createElement("tr"), d = document.createElement("td");
        d.textContent = a.handle;
        var e = document.createElement("td");
        e.id = "pc-resourceloaderdisplay-batchprogress-" + a.handle;
        e.textContent = "0%";
        b.appendChild(d);
        b.appendChild(e);
        var d = document.createElement("tr"), e = document.createElement("td"), g = document.createElement("table");
        g.setAttribute("class", 
        "pc-resourceloaderdisplay-subtable");
        g.id = "pc-resourceloaderdisplay-subtable-" + a.handle;
        e.appendChild(g);
        d.appendChild(e);
        this._rootTable.appendChild(b);
        this._rootTable.appendChild(d)
    };
    b.prototype._sanitizeId = function(a) {
        return a.replace(/\//, "").replace(/\./, "")
    };
    b.prototype.handleNewBatch = function(a, b) {
        this._domAddBatch(b)
    };
    b.prototype.handleLoading = function(a, b) {
        var d, e = b.batches.length;
        for (d = 0; d < e; d++) {
            var g = b.batches[d].handle, f = document.getElementById("pc-resourceloaderdisplay-subtable-" + g), 
            j = document.createElement("tr"), k = document.createElement("td");
            if ("" === b.identifier || !b.identifier)
                debugger;
            k.textContent = b.identifier;
            j.appendChild(k);
            k = document.createElement("td");
            k.id = "pc-resourceloaderdisplay-progress-" + g + "-" + this._sanitizeId(b.identifier);
            k.textContent = "0%";
            j.appendChild(k);
            f.appendChild(j)
        }
    };
    b.prototype.handleLoaded = function(a, b, d) {
        if (a = document.getElementById("pc-resourceloaderdisplay-progress-" + d.handle + "-" + this._sanitizeId(b.identifier)))
            a.textContent = "100%"
    };
    b.prototype.handleError = 
    function() {
    };
    b.prototype.handleBatchProgress = function(a, b) {
        var d = document.getElementById("pc-resourceloaderdisplay-batchprogress-" + b.handle);
        d && (d.textContent = 100 * b.getProgress() + "%")
    };
    return {ResourceLoaderDisplay: b}
}());
pc.extend(pc.resources, function() {
    var b;
    b = pc.inherits(function() {
    }, pc.resources.ResourceHandler);
    b.prototype.load = function(a, b, e) {
        var g = new Image;
        g.onload = function() {
            b(g)
        };
        g.onerror = function(a) {
            e(pc.string.format("Error loading Image from: '{0}'", a.srcElement.src))
        };
        if (a.charAt(0) == '/') a = a.substr(1);
        g.src = a
    };
    b.prototype.open = function(a) {
        return a
    };
    var a;
    a = pc.inherits(function() {
    }, pc.resources.ResourceRequest);
    a.prototype.type = "image";
    return {ImageResourceHandler: b,ImageRequest: a}
}());
pc.extend(pc.resources, function() {
    var b = function(a) {
        this.cache = {};
        this.loader = a
    };
    b.prototype = {getTexture: function(a) {
            return (a = this.loader.getHash(a)) && this.cache[a] ? this.cache[a] : null
        },addTexture: function(a, b) {
            var d = this.loader.getHash(a);
            d && (this.cache[d] = b)
        }};
    return {TextureCache: b}
}());
pc.gfx = {ADDRESS_REPEAT: 0,ADDRESS_CLAMP_TO_EDGE: 1,ADDRESS_MIRRORED_REPEAT: 2,BLENDMODE_ZERO: 0,BLENDMODE_ONE: 1,BLENDMODE_SRC_COLOR: 2,BLENDMODE_ONE_MINUS_SRC_COLOR: 3,BLENDMODE_DST_COLOR: 4,BLENDMODE_ONE_MINUS_DST_COLOR: 5,BLENDMODE_SRC_ALPHA: 6,BLENDMODE_SRC_ALPHA_SATURATE: 7,BLENDMODE_ONE_MINUS_SRC_ALPHA: 8,BLENDMODE_DST_ALPHA: 9,BLENDMODE_ONE_MINUS_DST_ALPHA: 10,BUFFER_STATIC: 0,BUFFER_DYNAMIC: 1,BUFFER_STREAM: 2,CLEARFLAG_COLOR: 1,CLEARFLAG_DEPTH: 2,CLEARFLAG_STENCIL: 4,FILTER_NEAREST: 0,FILTER_LINEAR: 1,FILTER_NEAREST_MIPMAP_NEAREST: 2,
    FILTER_NEAREST_MIPMAP_LINEAR: 3,FILTER_LINEAR_MIPMAP_NEAREST: 4,FILTER_LINEAR_MIPMAP_LINEAR: 5,INDEXFORMAT_UINT8: 0,INDEXFORMAT_UINT16: 1,INDEXFORMAT_UINT32: 2,PIXELFORMAT_A8: 0,PIXELFORMAT_L8: 1,PIXELFORMAT_L8_A8: 2,PIXELFORMAT_R5_G6_B5: 3,PIXELFORMAT_R5_G5_B5_A1: 4,PIXELFORMAT_R4_G4_B4_A4: 5,PIXELFORMAT_R8_G8_B8: 6,PIXELFORMAT_R8_G8_B8_A8: 7,PIXELFORMAT_DXT1: 8,PIXELFORMAT_DXT3: 9,PIXELFORMAT_DXT5: 10,PRIMITIVE_POINTS: 0,PRIMITIVE_LINES: 1,PRIMITIVE_LINESTRIP: 2,PRIMITIVE_TRIANGLES: 3,PRIMITIVE_TRISTRIP: 4,SHADERTYPE_VERTEX: 0,
    SHADERTYPE_FRAGMENT: 1,TEXTURELOCK_READ: 1,TEXTURELOCK_WRITE: 2};
pc.extend(pc.gfx, function() {
    var b = function(a) {
        this.name = a;
        this.value = null;
        this.versionObject = new pc.gfx.VersionedObject
    };
    b.prototype = {setValue: function(a) {
            this.value = a;
            this.versionObject.increment()
        },getValue: function() {
            return this.value
        }};
    return {ScopeId: b}
}());
pc.extend(pc.gfx, function() {
    var b = function(a) {
        this.name = a;
        this.variables = {};
        this.namespaces = {}
    };
    b.prototype = {resolve: function(a) {
            !1 == this.variables.hasOwnProperty(a) && (this.variables[a] = new pc.gfx.ScopeId(a));
            return this.variables[a]
        },getSubSpace: function(a) {
            !1 == this.namespaces.hasOwnProperty(a) && (this.namespaces[a] = new pc.gfx.ScopeSpace(a), logDEBUG("Added ScopeSpace: " + a));
            return this.namespaces[a]
        }};
    return {ScopeSpace: b}
}());
pc.extend(pc.gfx, function() {
    var b = function() {
        this.revision = this.globalId = 0
    };
    b.prototype = {equals: function(a) {
            return this.globalId === a.globalId && this.revision === a.revision
        },notequals: function(a) {
            return this.globalId !== a.globalId || this.revision !== a.revision
        },copy: function(a) {
            this.globalId = a.globalId;
            this.revision = a.revision
        },reset: function() {
            this.revision = this.globalId = 0
        }};
    return {Version: b}
}());
pc.extend(pc.gfx, function() {
    var b = 0, a = function() {
        b++;
        this.version = new pc.gfx.Version;
        this.version.globalId = b
    };
    a.prototype = {increment: function() {
            this.version.revision++
        }};
    return {VersionedObject: a}
}());
function WebGLValidator(b) {
    function a(a) {
        return function() {
            var b = c.gl[a].apply(c.gl, arguments);
            c.validate(a);
            return b
        }
    }
    this.gl = b;
    var c = this, c = this, d;
    for (d in b)
        this[d] = "function" === typeof b[d] ? a(d) : b[d];
    this.errorString = {};
    this.errorString[b.NO_ERROR] = "NO_ERROR";
    this.errorString[b.INVALID_ENUM] = "INVALID_ENUM";
    this.errorString[b.INVALID_VALUE] = "INVALID_VALUE";
    this.errorString[b.INVALID_OPERATION] = "INVALID_OPERATION";
    this.errorString[b.OUT_OF_MEMORY] = "OUT_OF_MEMORY";
    this.errorString[b.INVALID_FRAMEBUFFER_OPERATION] = 
    "INVALID_FRAMEBUFFER_OPERATION"
}
WebGLValidator.prototype.validate = function(b) {
    var a = this.gl, c = a.getError();
    return c !== a.NO_ERROR ? (pc.log.error("WebGL error from " + b + ": " + this.errorString[c]), !1) : !0
};
pc.extend(pc.gfx, function() {
    function b(b, g) {
        this.index = 0;
        switch (g.dataType) {
            case pc.gfx.VertexElementType.INT8:
                this.array = new Int8Array(b, g.offset);
                break;
            case pc.gfx.VertexElementType.UINT8:
                this.array = new Uint8Array(b, g.offset);
                break;
            case pc.gfx.VertexElementType.INT16:
                this.array = new Int16Array(b, g.offset);
                break;
            case pc.gfx.VertexElementType.UINT16:
                this.array = new Uint16Array(b, g.offset);
                break;
            case pc.gfx.VertexElementType.INT32:
                this.array = new Int32Array(b, g.offset);
                break;
            case pc.gfx.VertexElementType.UINT32:
                this.array = 
                new Uint32Array(b, g.offset);
                break;
            case pc.gfx.VertexElementType.FLOAT32:
                this.array = new Float32Array(b, g.offset)
        }
        switch (g.numComponents) {
            case 1:
                this.set = a;
                break;
            case 2:
                this.set = c;
                break;
            case 3:
                this.set = d;
                break;
            case 4:
                this.set = e
        }
    }
    function a(a) {
        this.array[this.index] = a
    }
    function c(a, b) {
        this.array[this.index] = a;
        this.array[this.index + 1] = b
    }
    function d(a, b, d) {
        this.array[this.index] = a;
        this.array[this.index + 1] = b;
        this.array[this.index + 2] = d
    }
    function e(a, b, d, c) {
        this.array[this.index] = a;
        this.array[this.index + 1] = 
        b;
        this.array[this.index + 2] = d;
        this.array[this.index + 3] = c
    }
    var g = function(a) {
        this.vertexBuffer = a;
        this.buffer = this.vertexBuffer.lock();
        this.setters = [];
        this.element = {};
        for (var a = this.vertexBuffer.getFormat(), d = 0; d < a.elements.length; d++) {
            var c = a.elements[d];
            this.setters[d] = new b(this.buffer, c);
            this.element[c.scopeId.name] = this.setters[d]
        }
    };
    g.prototype = {next: function() {
            for (var a = 0, b = this.setters, d = this.setters.length, c = this.vertexBuffer.getFormat(); a < d; ) {
                var g = b[a++];
                g.index += c.size / g.array.constructor.BYTES_PER_ELEMENT
            }
        },
        end: function() {
            this.vertexBuffer.unlock()
        }};
    return {VertexIterator: g}
}());
pc.extend(pc.gfx, function() {
    var b = function() {
        this.size = 0;
        this.elements = []
    };
    b.prototype = {begin: function() {
            this.size = 0;
            this.elements = []
        },end: function() {
            for (var a = 0, b = 0, d = this.elements, e = d.length; b < e; ) {
                var g = d[b++];
                g.offset = a;
                g.stride = this.size;
                a += g.size
            }
        },addElement: function(a) {
            this.size += a.size;
            this.elements.push(a)
        }};
    return {VertexFormat: b}
}());
pc.gfx.VertexElementType = {INT8: 0,UINT8: 1,INT16: 2,UINT16: 3,INT32: 4,UINT32: 5,FLOAT32: 6};
pc.extend(pc.gfx, function() {
    var b = [];
    b[pc.gfx.VertexElementType.INT8] = 1;
    b[pc.gfx.VertexElementType.UINT8] = 1;
    b[pc.gfx.VertexElementType.INT16] = 2;
    b[pc.gfx.VertexElementType.UINT16] = 2;
    b[pc.gfx.VertexElementType.INT32] = 4;
    b[pc.gfx.VertexElementType.UINT32] = 4;
    b[pc.gfx.VertexElementType.FLOAT32] = 4;
    return {VertexElement: function(a, c, d, e) {
            this.stride = this.offset = 0;
            this.stream = -1;
            this.scopeId = pc.gfx.Device.getCurrent().scope.resolve(a);
            this.dataType = d;
            this.numComponents = c;
            this.normalize = "undefined" === typeof e ? 
            !1 : e;
            this.size = this.numComponents * b[this.dataType]
        }}
}());
pc.extend(pc.gfx, function() {
    var b = function(a, b, d) {
        this.usage = d || pc.gfx.BUFFER_STATIC;
        this.format = a;
        this.numVertices = b;
        this.numBytes = a.size * b;
        this.gl = pc.gfx.Device.getCurrent().gl;
        this.bufferId = this.gl.createBuffer();
        this.storage = new ArrayBuffer(this.numBytes)
    };
    b.prototype = {destroy: function() {
            this.gl.deleteBuffer(this.bufferId)
        },getFormat: function() {
            return this.format
        },getUsage: function() {
            return this.usage
        },getNumVertices: function() {
            return this.numVertices
        },lock: function() {
            return this.storage
        },unlock: function() {
            var a = 
            this.gl, b;
            switch (this.usage) {
                case pc.gfx.BUFFER_STATIC:
                    b = a.STATIC_DRAW;
                    break;
                case pc.gfx.BUFFER_DYNAMIC:
                    b = a.DYNAMIC_DRAW;
                    break;
                case pc.gfx.BUFFER_STREAM:
                    b = a.STREAM_DRAW
            }
            a.bindBuffer(a.ARRAY_BUFFER, this.bufferId);
            a.bufferData(a.ARRAY_BUFFER, this.storage, b)
        }};
    return {VertexBuffer: b}
}());
pc.extend(pc.gfx, function() {
    var b = function(a, b, d) {
        this.usage = d || pc.gfx.BUFFER_STATIC;
        this.format = a;
        this.numIndices = b;
        b = this.gl = pc.gfx.Device.getCurrent().gl;
        this.bufferId = b.createBuffer();
        var e;
        a === pc.gfx.INDEXFORMAT_UINT8 ? (e = 1, this.glFormat = b.UNSIGNED_BYTE) : a === pc.gfx.INDEXFORMAT_UINT16 ? (e = 2, this.glFormat = b.UNSIGNED_SHORT) : a === pc.gfx.INDEXFORMAT_UINT32 && (e = 4, this.glFormat = b.UNSIGNED_INT);
        this.storage = new ArrayBuffer(this.numIndices * e)
    };
    b.prototype = {destroy: function() {
            this.gl.deleteBuffer(this.bufferId)
        },
        getFormat: function() {
            return this.format
        },getNumIndices: function() {
            return this.numIndices
        },lock: function() {
            return this.storage
        },unlock: function() {
            var a = this.gl, b;
            switch (this.usage) {
                case pc.gfx.BUFFER_STATIC:
                    b = a.STATIC_DRAW;
                    break;
                case pc.gfx.BUFFER_DYNAMIC:
                    b = a.DYNAMIC_DRAW;
                    break;
                case pc.gfx.BUFFER_STREAM:
                    b = a.STREAM_DRAW
            }
            a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.bufferId);
            a.bufferData(a.ELEMENT_ARRAY_BUFFER, this.storage, b)
        }};
    return {IndexBuffer: b}
}());
pc.extend(pc.gfx, function() {
    var b = function(a) {
        var b = 4, d = 4, e = pc.gfx.PIXELFORMAT_R8_G8_B8_A8, g = !1;
        "undefined" !== typeof a && (b = "undefined" !== typeof a.width ? a.width : b, d = "undefined" !== typeof a.height ? a.height : d, e = "undefined" !== typeof a.format ? a.format : e, g = "undefined" !== typeof a.cubemap ? a.cubemap : g);
        this.name = null;
        this.autoMipmap = !0;
        var f = pc.gfx.Device.getCurrent();
        this._gl = a = f.gl;
        this._glTextureId = a.createTexture();
        this._glTarget = g ? a.TEXTURE_CUBE_MAP : a.TEXTURE_2D;
        this._cubemap = g;
        this._format = e;
        switch (e) {
            case pc.gfx.PIXELFORMAT_A8:
                this._glInternalFormat = 
                this._glFormat = a.ALPHA;
                this._glPixelType = a.UNSIGNED_BYTE;
                break;
            case pc.gfx.PIXELFORMAT_L8:
                this._glInternalFormat = this._glFormat = a.LUMINANCE;
                this._glPixelType = a.UNSIGNED_BYTE;
                break;
            case pc.gfx.PIXELFORMAT_L8_A8:
                this._glInternalFormat = this._glFormat = a.LUMINANCE_ALPHA;
                this._glPixelType = a.UNSIGNED_BYTE;
                break;
            case pc.gfx.PIXELFORMAT_R5_G6_B5:
                this._glInternalFormat = this._glFormat = a.RGB;
                this._glPixelType = a.UNSIGNED_SHORT_5_6_5;
                break;
            case pc.gfx.PIXELFORMAT_R5_G5_B5_A1:
                this._glInternalFormat = this._glFormat = 
                a.RGBA;
                this._glPixelType = a.UNSIGNED_SHORT_5_5_5_1;
                break;
            case pc.gfx.PIXELFORMAT_R4_G4_B4_A4:
                this._glInternalFormat = this._glFormat = a.RGBA;
                this._glPixelType = a.UNSIGNED_SHORT_4_4_4_4;
                break;
            case pc.gfx.PIXELFORMAT_R8_G8_B8:
                this._glInternalFormat = this._glFormat = a.RGB;
                this._glPixelType = a.UNSIGNED_BYTE;
                break;
            case pc.gfx.PIXELFORMAT_R8_G8_B8_A8:
                this._glInternalFormat = this._glFormat = a.RGBA;
                this._glPixelType = a.UNSIGNED_BYTE;
                break;
            case pc.gfx.PIXELFORMAT_DXT1:
                f = f.extCompressedTextureS3TC;
                this._glFormat = a.RGB;
                this._glInternalFormat = f.COMPRESSED_RGB_S3TC_DXT1_EXT;
                break;
            case pc.gfx.PIXELFORMAT_DXT3:
                f = f.extCompressedTextureS3TC;
                this._glFormat = a.RGBA;
                this._glInternalFormat = f.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                break;
            case pc.gfx.PIXELFORMAT_DXT5:
                f = f.extCompressedTextureS3TC, this._glFormat = a.RGBA, this._glInternalFormat = f.COMPRESSED_RGBA_S3TC_DXT5_EXT
        }
        this._compressed = e === pc.gfx.PIXELFORMAT_DXT1 || e === pc.gfx.PIXELFORMAT_DXT3 || e === pc.gfx.PIXELFORMAT_DXT5;
        this._width = b || 4;
        this._height = d || 4;
        this._addressv = this._addressu = 
        pc.gfx.ADDRESS_REPEAT;
        this._minFilter = pc.gfx.FILTER_NEAREST_MIPMAP_LINEAR;
        this._magFilter = pc.gfx.FILTER_LINEAR;
        this._maxAnisotropy = 1;
        this._levels = g ? [[null, null, null, null, null, null]] : [null];
        this._lockedLevel = -1;
        this.upload()
    };
    Object.defineProperty(b.prototype, "minFilter", {get: function() {
            return this._minFilter
        },set: function(a) {
            if (!pc.math.pot(this._width) || !pc.math.pot(this._height))
                a === pc.gfx.FILTER_NEAREST || a === pc.gfx.FILTER_LINEAR || (logWARNING("Invalid filter mode set on non power of two texture. Forcing linear addressing."), 
                a = pc.gfx.FILTER_LINEAR);
            this.bind();
            var b = this._gl;
            b.texParameteri(this._glTarget, b.TEXTURE_MIN_FILTER, [b.NEAREST, b.LINEAR, b.NEAREST_MIPMAP_NEAREST, b.NEAREST_MIPMAP_LINEAR, b.LINEAR_MIPMAP_NEAREST, b.LINEAR_MIPMAP_LINEAR][a]);
            this._minFilter = a
        }});
    Object.defineProperty(b.prototype, "magFilter", {get: function() {
            return this._magFilter
        },set: function(a) {
            a === pc.gfx.FILTER_NEAREST || a === pc.gfx.FILTER_LINEAR || logWARNING("Invalid maginication filter mode. Must be set to FILTER_NEAREST or FILTER_LINEAR.");
            this.bind();
            var b = this._gl;
            b.texParameteri(this._glTarget, b.TEXTURE_MAG_FILTER, [b.NEAREST, b.LINEAR, b.NEAREST_MIPMAP_NEAREST, b.NEAREST_MIPMAP_LINEAR, b.LINEAR_MIPMAP_NEAREST, b.LINEAR_MIPMAP_LINEAR][a]);
            this._magFilter = a
        }});
    Object.defineProperty(b.prototype, "addressU", {get: function() {
            return this._addressu
        },set: function(a) {
            if ((!pc.math.pot(this._width) || !pc.math.pot(this._height)) && a !== pc.gfx.ADDRESS_CLAMP_TO_EDGE)
                logWARNING("Invalid address mode in U set on non power of two texture. Forcing clamp to edge addressing."), 
                a = pc.gfx.ADDRESS_CLAMP_TO_EDGE;
            this.bind();
            var b = this._gl;
            b.texParameteri(this._glTarget, b.TEXTURE_WRAP_S, [b.REPEAT, b.CLAMP_TO_EDGE, b.MIRRORED_REPEAT][a]);
            this._addressu = a
        }});
    Object.defineProperty(b.prototype, "addressV", {get: function() {
            return this._addressv
        },set: function(a) {
            if ((!pc.math.pot(this._width) || !pc.math.pot(this._height)) && a !== pc.gfx.ADDRESS_CLAMP_TO_EDGE)
                logWARNING("Invalid address mode in V set on non power of two texture. Forcing clamp to edge addressing."), a = pc.gfx.ADDRESS_CLAMP_TO_EDGE;
            this.bind();
            var b = this._gl;
            b.texParameteri(this._glTarget, b.TEXTURE_WRAP_T, [b.REPEAT, b.CLAMP_TO_EDGE, b.MIRRORED_REPEAT][a]);
            this._addressv = a
        }});
    Object.defineProperty(b.prototype, "maxAnisotropy", {get: function() {
            return this._maxAnisotropy
        },set: function(a) {
            var b = pc.gfx.Device.getCurrent().extTextureFilterAnisotropic;
            b && (this.bind(), this._gl.texParameterf(this._glTarget, b.TEXTURE_MAX_ANISOTROPY_EXT, a), this._maxAnisotropy = a)
        }});
    Object.defineProperty(b.prototype, "width", {get: function() {
            return this._width
        }});
    Object.defineProperty(b.prototype, "height", {get: function() {
            return this._height
        }});
    Object.defineProperty(b.prototype, "format", {get: function() {
            return this._format
        }});
    pc.extend(b.prototype, {bind: function() {
            this._gl.bindTexture(this._glTarget, this._glTextureId)
        },destroy: function() {
            this._gl.deleteTexture(this._glTextureId)
        },lock: function(a) {
            a = a || {level: 0,face: 0,mode: pc.gfx.TEXTURELOCK_WRITE};
            void 0 === a.level && (a.level = 0);
            void 0 === a.face && (a.face = 0);
            void 0 === a.mode && (a.mode = pc.gfx.TEXTURELOCK_WRITE);
            this._lockedLevel = 
            a.level;
            if (null === this._levels[a.level])
                switch (this._format) {
                    case pc.gfx.PIXELFORMAT_A8:
                    case pc.gfx.PIXELFORMAT_L8:
                        this._levels[a.level] = new Uint8Array(this._width * this._height);
                        break;
                    case pc.gfx.PIXELFORMAT_L8_A8:
                        this._levels[a.level] = new Uint8Array(2 * this._width * this._height);
                        break;
                    case pc.gfx.PIXELFORMAT_R5_G6_B5:
                    case pc.gfx.PIXELFORMAT_R5_G5_B5_A1:
                    case pc.gfx.PIXELFORMAT_R4_G4_B4_A4:
                        this._levels[a.level] = new Uint16Array(this._width * this._height);
                        break;
                    case pc.gfx.PIXELFORMAT_R8_G8_B8:
                        this._levels[a.level] = 
                        new Uint8Array(3 * this._width * this._height);
                        break;
                    case pc.gfx.PIXELFORMAT_R8_G8_B8_A8:
                        this._levels[a.level] = new Uint8Array(4 * this._width * this._height);
                        break;
                    case pc.gfx.PIXELFORMAT_DXT1:
                        this._levels[a.level] = new Uint8Array(8 * Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4));
                        break;
                    case pc.gfx.PIXELFORMAT_DXT3:
                    case pc.gfx.PIXELFORMAT_DXT5:
                        this._levels[a.level] = new Uint8Array(16 * Math.floor((this._width + 3) / 4) * Math.floor((this._height + 3) / 4))
                }
            return this._levels[a.level]
        },recover: function() {
            this._glTextureId = 
            this._gl.createTexture();
            this.addressU = this._addressu;
            this.addressV = this._addressv;
            this.minFilter = this._minFilter;
            this.magFilter = this._magFilter;
            this.maxAnisotropy = this._maxAnisotropy;
            this.upload()
        },load: function(a, b, d) {
            if (this._cubemap) {
                var d = {batch: d}, e = a.map(function(a) {
                    return new pc.resources.ImageRequest(a)
                });
                b.request(e, function(b) {
                    var d = a.map(function(a) {
                        return b[a]
                    });
                    this.setSource(d)
                }.bind(this), function(a) {
                    logERROR(a)
                }, function() {
                }, d)
            } else
                d = new pc.resources.ImageRequest(a), b.request(d, 
                function(b) {
                    this.setSource(b[a])
                }.bind(this))
        },setSource: function(a) {
            if (this._cubemap) {
                logASSERT("[object Array]" === Object.prototype.toString.apply(a), "pc.gfx.Texture: setSource: supplied source is not an array");
                logASSERT(6 === a.length, "pc.gfx.Texture: setSource: supplied source does not have 6 entries.");
                for (var b = 0, d = !0, e = a[0].width, g = a[0].height, f = 0; 6 > f; f++)
                    (a[f] instanceof HTMLCanvasElement || a[f] instanceof HTMLImageElement || a[f] instanceof HTMLVideoElement) && b++, a[f].width !== e && (d = !1), a[f].height !== 
                    g && (d = !1);
                logASSERT(6 === b, "pc.gfx.Texture: setSource: Not all supplied source elements are of required type (canvas, image or video).");
                logASSERT(d, "pc.gfx.Texture: setSource: Not all supplied source elements share the same dimensions.");
                this._width = a[0].width;
                this._height = a[0].height
            } else
                logASSERT(a instanceof HTMLCanvasElement || a instanceof HTMLImageElement || a instanceof HTMLVideoElement, "pc.gfx.Texture: setSource: supplied source is not an instance of HTMLCanvasElement, HTMLImageElement or HTMLVideoElement."), 
                this._width = a.width, this._height = a.height;
            this._levels[0] = a;
            this.upload();
            this.minFilter = this._minFilter;
            this.magFilter = this._magFilter;
            this.addressu = this._addressu;
            this.addressv = this._addressv
        },unlock: function() {
            logASSERT(-1 !== this._lockedLevel, "Attempting to unlock a texture that is not locked");
            this.upload();
            this._lockedLevel = -1
        },upload: function() {
            this.bind();
            var a = this._gl;
            if (this._cubemap) {
                a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !1);
                var b = this._levels[0];
                if (b[0] instanceof HTMLCanvasElement || b[0] instanceof 
                HTMLImageElement || b[0] instanceof HTMLVideoElement)
                    for (var d = 0; 6 > d; d++)
                        a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + d, 0, this._glInternalFormat, this._glFormat, this._glPixelType, b[d]);
                else
                    for (d = 0; 6 > d; d++)
                        a.texImage2D(a.TEXTURE_CUBE_MAP_POSITIVE_X + d, 0, this._glInternalFormat, this._width, this._height, 0, this._glFormat, this._glPixelType, b[d])
            } else
                b = this._levels[0], b instanceof HTMLCanvasElement || b instanceof HTMLImageElement || b instanceof HTMLVideoElement ? 
                (a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !0), a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), a.texImage2D(a.TEXTURE_2D, 0, this._glInternalFormat, this._glFormat, this._glPixelType, b)) : (a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !1), this._compressed ? a.compressedTexImage2D(a.TEXTURE_2D, 0, this._glInternalFormat, this._width, this._height, 0, b) : a.texImage2D(a.TEXTURE_2D, 0, this._glInternalFormat, this._width, this._height, 0, this._glFormat, this._glPixelType, b));
            this.autoMipmap && (pc.math.pot(this._width) && pc.math.pot(this._height) && 
            1 === this._levels.length) && a.generateMipmap(this._glTarget)
        }});
    return {Texture: b}
}());
pc.extend(pc.gfx, function() {
    var b = function(a, b, d, e) {
        "undefined" === typeof e && (e = !1);
        if (void 0 !== a && void 0 !== b) {
            var g = pc.gfx.Device.getCurrent(), f = g.gl;
            this._width = a || 1;
            this._height = b || 1;
            this._colorBuffers = [];
            d && !g.extDepthTexture && (this._depthBuffers = []);
            this._colorTexture = new pc.gfx.Texture({width: a,height: b,format: pc.gfx.PIXELFORMAT_R8_G8_B8_A8,cubemap: e});
            this._colorTexture.upload();
            d && g.extDepthTexture && (this._depthTexture = new pc.gfx.Texture({width: a,height: b,format: pc.gfx.PIXELFORMAT_D16,cubemap: e}), 
            this._depthTexture.upload());
            a = e ? 6 : 1;
            for (b = this._activeBuffer = 0; b < a; b++)
                switch (this._colorBuffers[b] = f.createFramebuffer(), f.bindFramebuffer(f.FRAMEBUFFER, this._colorBuffers[b]), f.framebufferTexture2D(f.FRAMEBUFFER, f.COLOR_ATTACHMENT0, e ? f.TEXTURE_CUBE_MAP_POSITIVE_X + b : f.TEXTURE_2D, this._colorTexture._glTextureId, 0), d && (g.extDepthTexture ? f.framebufferTexture2D(f.FRAMEBUFFER, f.DEPTH_ATTACHMENT, e ? f.TEXTURE_CUBE_MAP_POSITIVE_X + b : f.TEXTURE_2D, this._depthTexture._glTextureId, 0) : (this._depthBuffers[b] = f.createRenderbuffer(), 
                f.bindRenderbuffer(f.RENDERBUFFER, this._depthBuffers[b]), f.renderbufferStorage(f.RENDERBUFFER, f.DEPTH_COMPONENT16, this._width, this._height), f.bindRenderbuffer(f.RENDERBUFFER, null), f.framebufferRenderbuffer(f.FRAMEBUFFER, f.DEPTH_ATTACHMENT, f.RENDERBUFFER, this._depthBuffers[b]))), f.checkFramebufferStatus(f.FRAMEBUFFER)) {
                    case f.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                        logERROR("FrameBuffer error: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                        break;
                    case f.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                        logERROR("FrameBuffer error: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                        break;
                    case f.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                        logERROR("FrameBuffer error: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                        break;
                    case f.FRAMEBUFFER_UNSUPPORTED:
                        logERROR("FrameBuffer error: FRAMEBUFFER_UNSUPPORTED")
                }
            f.bindFramebuffer(f.FRAMEBUFFER, null)
        }
    };
    b.getBackBuffer = function() {
        return new pc.gfx.FrameBuffer
    };
    b.prototype.bind = function() {
        var a = pc.gfx.Device.getCurrent().gl;
        a.bindFramebuffer(a.FRAMEBUFFER, this._colorBuffers ? this._colorBuffers[this._activeBuffer] : null)
    };
    b.prototype.setActiveBuffer = function(a) {
        this._activeBuffer = 
        a
    };
    b.prototype.getWidth = function() {
        var a = pc.gfx.Device.getCurrent().gl;
        return this._colorBuffers ? this._width : a.canvas.width
    };
    b.prototype.getHeight = function() {
        var a = pc.gfx.Device.getCurrent().gl;
        return this._colorBuffers ? this._height : a.canvas.height
    };
    b.prototype.getTexture = function() {
        return this._colorBuffers ? this._colorTexture : null
    };
    return {FrameBuffer: b}
}());
pc.extend(pc.gfx, function() {
    var b = function(a, b) {
        this._frameBuffer = a;
        b && (this._viewport = b);
        this._defaultViewport = {x: 0,y: 0,width: 0,height: 0}
    };
    b.prototype = {setViewport: function(a) {
            this._viewport = a
        },getViewport: function() {
            if (this._viewport)
                return this._viewport;
            this._defaultViewport.width = this._frameBuffer.getWidth();
            this._defaultViewport.height = this._frameBuffer.getHeight();
            return this._defaultViewport
        },setFrameBuffer: function(a) {
            this._frameBuffer = a
        },getFrameBuffer: function() {
            return this._frameBuffer
        },
        bind: function() {
            var a = pc.gfx.Device.getCurrent().gl;
            this._frameBuffer.bind();
            var b = this.getViewport();
            a.viewport(b.x, b.y, b.width, b.height);
            a.scissor(b.x, b.y, b.width, b.height)
        }};
    return {RenderTarget: b}
}());
pc.gfx.ShaderInputType = {BOOL: 0,INT: 1,FLOAT: 2,VEC2: 3,VEC3: 4,VEC4: 5,IVEC2: 6,IVEC3: 7,IVEC4: 8,BVEC2: 9,BVEC3: 10,BVEC4: 11,MAT2: 12,MAT3: 13,MAT4: 14,TEXTURE2D: 15,TEXTURECUBE: 16};
pc.gfx.ShaderInput = function(b, a, c) {
    this.locationId = c;
    this.scopeId = pc.gfx.Device.getCurrent().scope.resolve(b);
    this.version = new pc.gfx.Version;
    this.dataType = a;
    this.commitArgs = [c];
    this.valueIndex = 1;
    var d, b = pc.gfx.Device.getCurrent().gl;
    switch (a) {
        case pc.gfx.ShaderInputType.BOOL:
        case pc.gfx.ShaderInputType.INT:
            d = b.uniform1i;
            break;
        case pc.gfx.ShaderInputType.FLOAT:
            d = b.uniform1f;
            break;
        case pc.gfx.ShaderInputType.VEC2:
            d = b.uniform2fv;
            break;
        case pc.gfx.ShaderInputType.VEC3:
            d = b.uniform3fv;
            break;
        case pc.gfx.ShaderInputType.VEC4:
            d = 
            b.uniform4fv;
            break;
        case pc.gfx.ShaderInputType.BVEC2:
        case pc.gfx.ShaderInputType.IVEC2:
            d = b.uniform2iv;
            break;
        case pc.gfx.ShaderInputType.BVEC3:
        case pc.gfx.ShaderInputType.IVEC3:
            d = b.uniform3iv;
            break;
        case pc.gfx.ShaderInputType.BVEC4:
        case pc.gfx.ShaderInputType.IVEC4:
            d = b.uniform4iv;
            break;
        case pc.gfx.ShaderInputType.MAT2:
            d = b.uniformMatrix2fv;
            this.commitArgs.push(!1);
            this.valueIndex = 2;
            break;
        case pc.gfx.ShaderInputType.MAT3:
            d = b.uniformMatrix3fv;
            this.commitArgs.push(!1);
            this.valueIndex = 2;
            break;
        case pc.gfx.ShaderInputType.MAT4:
            d = 
            b.uniformMatrix4fv, this.commitArgs.push(!1), this.valueIndex = 2
    }
    this.commitFunc = d;
    this.slot = -1
};
pc.extend(pc.gfx, function() {
    var b = function(a, b) {
        this.type = a;
        this.src = b;
        var d = this.gl = pc.gfx.Device.getCurrent().gl;
        this.shaderId = d.createShader(this.type === pc.gfx.SHADERTYPE_VERTEX ? d.VERTEX_SHADER : d.FRAGMENT_SHADER);
        d.shaderSource(this.shaderId, this.src);
        d.compileShader(this.shaderId);
        d.getShaderParameter(this.shaderId, d.COMPILE_STATUS) || (d = d.getShaderInfoLog(this.shaderId), logERROR("Failed to compile " + (this.type === pc.gfx.SHADERTYPE_VERTEX ? "vertex" : "fragment") + " shader:\n" + b + "\n" + d))
    };
    b.prototype = 
    {destroy: function() {
            this.gl.deleteShader(this.shaderId)
        },getType: function() {
            return this.type
        },getSource: function() {
            return this.src
        }};
    return {Shader: b}
}());
pc.extend(pc.gfx, function() {
    var b = 0, a = function(a, d) {
        this.id = b++;
        this.attributes = [];
        this.samplers = [];
        this.uniforms = [];
        var e = this.gl = pc.gfx.Device.getCurrent().gl, g = {};
        g[e.BOOL] = pc.gfx.ShaderInputType.BOOL;
        g[e.INT] = pc.gfx.ShaderInputType.INT;
        g[e.FLOAT] = pc.gfx.ShaderInputType.FLOAT;
        g[e.FLOAT_VEC2] = pc.gfx.ShaderInputType.VEC2;
        g[e.FLOAT_VEC3] = pc.gfx.ShaderInputType.VEC3;
        g[e.FLOAT_VEC4] = pc.gfx.ShaderInputType.VEC4;
        g[e.INT_VEC2] = pc.gfx.ShaderInputType.IVEC2;
        g[e.INT_VEC3] = pc.gfx.ShaderInputType.IVEC3;
        g[e.INT_VEC4] = 
        pc.gfx.ShaderInputType.IVEC4;
        g[e.BOOL_VEC2] = pc.gfx.ShaderInputType.BVEC2;
        g[e.BOOL_VEC3] = pc.gfx.ShaderInputType.BVEC3;
        g[e.BOOL_VEC4] = pc.gfx.ShaderInputType.BVEC4;
        g[e.FLOAT_MAT2] = pc.gfx.ShaderInputType.MAT2;
        g[e.FLOAT_MAT3] = pc.gfx.ShaderInputType.MAT3;
        g[e.FLOAT_MAT4] = pc.gfx.ShaderInputType.MAT4;
        g[e.SAMPLER_2D] = pc.gfx.ShaderInputType.TEXTURE2D;
        g[e.SAMPLER_CUBE] = pc.gfx.ShaderInputType.TEXTURECUBE;
        this.programId = e.createProgram();
        e.attachShader(this.programId, a.shaderId);
        e.attachShader(this.programId, d.shaderId);
        e.linkProgram(this.programId);
        if (!e.getProgramParameter(this.programId, e.LINK_STATUS)) {
            var f = e.getProgramInfoLog(this.programId);
            logERROR("Failed to link shader program. Error: " + f)
        }
        for (var f = 0, j = e.getProgramParameter(this.programId, e.ACTIVE_ATTRIBUTES); f < j; ) {
            var k = e.getActiveAttrib(this.programId, f++), l = e.getAttribLocation(this.programId, k.name);
            this.attributes.push(new pc.gfx.ShaderInput(k.name, g[k.type], l))
        }
        f = 0;
        for (j = e.getProgramParameter(this.programId, e.ACTIVE_UNIFORMS); f < j; )
            k = e.getActiveUniform(this.programId, 
            f++), l = e.getUniformLocation(this.programId, k.name), k.type === e.SAMPLER_2D || k.type === e.SAMPLER_CUBE ? this.samplers.push(new pc.gfx.ShaderInput(k.name, g[k.type], l)) : this.uniforms.push(new pc.gfx.ShaderInput(k.name, g[k.type], l))
    };
    a.prototype = {destroy: function() {
            this.gl.deleteProgram(this.programId)
        }};
    return {Program: a}
}());
pc.extend(pc.gfx, function() {
    var b = function() {
        this._cache = {};
        this._generators = {}
    };
    b.prototype.register = function(a, b) {
        this.isRegistered(a) || (this._generators[a] = b)
    };
    b.prototype.unregister = function(a) {
        this.isRegistered(a) && delete this._generators[a]
    };
    b.prototype.isRegistered = function(a) {
        return void 0 !== this._generators[a]
    };
    b.prototype.getProgram = function(a, b) {
        var d = this._generators[a];
        if (void 0 === d)
            return logERROR("No program library functions registered for: " + a), null;
        var e = d.generateKey(b), g = this._cache[e];
        g || (g = d.generateVertexShader(b), d = d.generateFragmentShader(b), logDEBUG("\n" + e + ": vertex shader\n" + g), logDEBUG("\n" + e + ": fragment shader\n" + d), g = new pc.gfx.Shader(pc.gfx.SHADERTYPE_VERTEX, g), d = new pc.gfx.Shader(pc.gfx.SHADERTYPE_FRAGMENT, d), g = this._cache[e] = new pc.gfx.Program(g, d));
        return g
    };
    return {ProgramLibrary: b}
}());
pc.gfx.PrimType = {POINTS: 0,LINES: 1,LINE_STRIP: 2,TRIANGLES: 3,TRIANGLE_STRIP: 4};
pc.gfx.BlendMode = {ZERO: 0,ONE: 1,SRC_COLOR: 2,ONE_MINUS_SRC_COLOR: 3,DST_COLOR: 4,ONE_MINUS_DST_COLOR: 5,SRC_ALPHA: 6,SRC_ALPHA_SATURATE: 7,ONE_MINUS_SRC_ALPHA: 8,DST_ALPHA: 9,ONE_MINUS_DST_ALPHA: 10};
pc.gfx.DepthFunc = {LEQUAL: 0};
pc.gfx.FrontFace = {CW: 0,CCW: 1};
pc.extend(pc.gfx, function() {
    function b(a) {
        this.name = "UnsupportedBrowserError";
        this.message = a || ""
    }
    function a(a) {
        this.name = "ContextCreationError";
        this.message = a || ""
    }
    b.prototype = Error.prototype;
    a.prototype = Error.prototype;
    var c = function() {
        logWARNING("Context lost.")
    }, d = function() {
        logINFO("Context restored.")
    }, e = function(a) {
        if (!window.WebGLRenderingContext)
            throw new pc.gfx.UnsupportedBrowserError;
        for (var b = {alpha: !1}, e = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"], k = null, l = 0; l < e.length; l++) {
            try {
                k = 
                a.getContext(e[l], b)
            } catch (m) {
            }
            if (k)
                break
        }
        this.gl = k;
        if (!this.gl)
            throw new pc.gfx.ContextCreationError;
        a.addEventListener("webglcontextlost", c, !1);
        a.addEventListener("webglcontextrestored", d, !1);
        this.canvas = a;
        this.indexBuffer = this.program = null;
        this.vertexBuffers = [];
        var h = this.gl;
        logINFO("Device started");
        logINFO("WebGL version:             " + h.getParameter(h.VERSION));
        logINFO("WebGL shader version:      " + h.getParameter(h.SHADING_LANGUAGE_VERSION));
        logINFO("WebGL vendor:              " + h.getParameter(h.VENDOR));
        logINFO("WebGL renderer:            " + h.getParameter(h.RENDERER));
        logINFO("WebGL extensions:          " + h.getSupportedExtensions());
        logINFO("WebGL num texture units:   " + h.getParameter(h.MAX_TEXTURE_IMAGE_UNITS));
        logINFO("WebGL max texture size:    " + h.getParameter(h.MAX_TEXTURE_SIZE));
        logINFO("WebGL max cubemap size:    " + h.getParameter(h.MAX_CUBE_MAP_TEXTURE_SIZE));
        logINFO("WebGL max vertex attribs:  " + h.getParameter(h.MAX_VERTEX_ATTRIBS));
        logINFO("WebGL max vshader vectors: " + h.getParameter(h.MAX_VERTEX_UNIFORM_VECTORS));
        logINFO("WebGL max fshader vectors: " + h.getParameter(h.MAX_FRAGMENT_UNIFORM_VECTORS));
        logINFO("WebGL max varying vectors: " + h.getParameter(h.MAX_VARYING_VECTORS));
        this.defaultClearOptions = {color: [0, 0, 0, 1],depth: 1,flags: pc.gfx.CLEARFLAG_COLOR | pc.gfx.CLEARFLAG_COLOR};
        this.lookupPrim = [h.POINTS, h.LINES, h.LINE_STRIP, h.TRIANGLES, h.TRIANGLE_STRIP];
        this.lookupClear = [0, h.COLOR_BUFFER_BIT, h.DEPTH_BUFFER_BIT, h.COLOR_BUFFER_BIT | h.DEPTH_BUFFER_BIT, h.STENCIL_BUFFER_BIT, h.STENCIL_BUFFER_BIT | h.COLOR_BUFFER_BIT, h.STENCIL_BUFFER_BIT | 
            h.DEPTH_BUFFER_BIT, h.STENCIL_BUFFER_BIT | h.COLOR_BUFFER_BIT | h.DEPTH_BUFFER_BIT];
        this.lookup = {blendMode: [h.ZERO, h.ONE, h.SRC_COLOR, h.ONE_MINUS_SRC_COLOR, h.DST_COLOR, h.ONE_MINUS_DST_COLOR, h.SRC_ALPHA, h.SRC_ALPHA_SATURATE, h.ONE_MINUS_SRC_ALPHA, h.DST_ALPHA, h.ONE_MINUS_DST_ALPHA],elementType: [h.BYTE, h.UNSIGNED_BYTE, h.SHORT, h.UNSIGNED_SHORT, h.INT, h.UNSIGNED_INT, h.FLOAT],frontFace: [h.CW, h.CCW]};
        //h.getExtension = function(txt) { console.error(txt); return null;};
        this.extTextureFloat = h.getExtension("OES_texture_float");
        this.extDepthTexture = null;
        (this.extStandardDerivatives = 
        h.getExtension("OES_standard_derivatives")) && h.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, h.NICEST);
        this.extTextureFilterAnisotropic = h.getExtension("EXT_texture_filter_anisotropic");
        this.extTextureFilterAnisotropic || (this.extTextureFilterAnisotropic = h.getExtension("WEBKIT_EXT_texture_filter_anisotropic"));
        if (this.extCompressedTextureS3TC = h.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc")) {
            b = h.getParameter(h.COMPRESSED_TEXTURE_FORMATS);
            e = "WebGL compressed texture formats:";
            for (k = 0; k < b.length; k++)
                switch (b[k]) {
                    case this.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT:
                        e += " COMPRESSED_RGB_S3TC_DXT1_EXT";
                        break;
                    case this.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT:
                        e += " COMPRESSED_RGBA_S3TC_DXT1_EXT";
                        break;
                    case this.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT:
                        e += " COMPRESSED_RGBA_S3TC_DXT3_EXT";
                        break;
                    case this.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT:
                        e += " COMPRESSED_RGBA_S3TC_DXT5_EXT";
                        break;
                    default:
                        e += " UNKOWN(" + b[k] + ")"
                }
            logINFO(e)
        }
        b = 
        pc.gfx.FrameBuffer.getBackBuffer();
        this.renderTarget = new pc.gfx.RenderTarget(b, {x: 0,y: 0,width: a.width,height: a.height});
        this.scope = new pc.gfx.ScopeSpace("Device");
        var n = this;
        this.commitFunction = {};
        this.commitFunction[pc.gfx.ShaderInputType.BOOL] = function(a, b) {
            n.gl.uniform1i(a, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.INT] = function(a, b) {
            n.gl.uniform1i(a, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.FLOAT] = function(a, b) {
            "number" == typeof b ? n.gl.uniform1f(a, b) : n.gl.uniform1fv(a, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.VEC2] = 
        function(a, b) {
            n.gl.uniform2fv(a, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.VEC3] = function(a, b) {
            n.gl.uniform3fv(a, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.VEC4] = function(a, b) {
            n.gl.uniform4fv(a, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.IVEC2] = function(a, b) {
            n.gl.uniform2iv(a, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.BVEC2] = function(a, b) {
            n.gl.uniform2iv(a, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.IVEC3] = function(a, b) {
            n.gl.uniform3iv(a, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.BVEC3] = 
        function(a, b) {
            n.gl.uniform3iv(a, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.IVEC4] = function(a, b) {
            n.gl.uniform4iv(a, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.BVEC4] = function(a, b) {
            n.gl.uniform4iv(a, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.MAT2] = function(a, b) {
            n.gl.uniformMatrix2fv(a, !1, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.MAT3] = function(a, b) {
            n.gl.uniformMatrix3fv(a, !1, b)
        };
        this.commitFunction[pc.gfx.ShaderInputType.MAT4] = function(a, b) {
            n.gl.uniformMatrix4fv(a, !1, b)
        };
        h = this.gl;
        h.enable(h.DEPTH_TEST);
        h.depthMask(!0);
        h.depthFunc(h.LEQUAL);
        h.depthRange(0, 1);
        h.enable(h.CULL_FACE);
        h.cullFace(h.BACK);
        h.frontFace(h.CCW);
        h.disable(h.BLEND);
        h.blendFunc(h.ONE, h.ZERO);
        h.enable(h.SCISSOR_TEST);
        this.scope.resolve("fog_color").setValue([0, 0, 0]);
        this.scope.resolve("fog_density").setValue(0);
        this.scope.resolve("alpha_ref").setValue(0);
        a = function() {
            return {alphaTest: !1,alphaRef: 0,blend: !1,blendModes: {srcBlend: pc.gfx.BLENDMODE_ONE,dstBlend: pc.gfx.BLENDMODE_ZERO},colorWrite: {red: !0,green: !0,blue: !0,alpha: !0},cull: !0,
                depthTest: !0,depthWrite: !0,depthFunc: pc.gfx.DepthFunc.LEQUAL,fog: !1,fogColor: [0, 0, 0],fogDensity: 0,frontFace: pc.gfx.FrontFace.CCW}
        };
        this._globalState = a();
        this._currentState = a();
        this._localState = {};
        this._stateFuncs = {};
        this._stateFuncs.alphaTest = function(a) {
            n._currentState.alphaTest = a
        };
        this._stateFuncs.alphaRef = function(a) {
            n.scope.resolve("alpha_ref").setValue(a);
            n._currentState.alphaRef = a
        };
        this._stateFuncs.blend = function(a) {
            n._currentState.blend !== a && (a ? n.gl.enable(h.BLEND) : n.gl.disable(h.BLEND), n._currentState.blend = 
            a)
        };
        this._stateFuncs.blendModes = function(a) {
            if (n._currentState.blendModes.srcBlend !== a.srcBlend || n._currentState.blendModes.dstBlend !== a.dstBlend)
                n.gl.blendFunc(n.lookup.blendMode[a.srcBlend], n.lookup.blendMode[a.dstBlend]), n._currentState.blendModes.srcBlend = a.srcBlend, n._currentState.blendModes.dstBlend = a.dstBlend
        };
        this._stateFuncs.colorWrite = function(a) {
            if (n._currentState.colorWrite.red !== a.red || n._currentState.colorWrite.green !== a.green || n._currentState.colorWrite.blue !== a.blue || n._currentState.colorWrite.alpha !== 
            a.alpha)
                n.gl.colorMask(a.red, a.green, a.blue, a.alpha), n._currentState.colorWrite.red = a.red, n._currentState.colorWrite.green = a.green, n._currentState.colorWrite.blue = a.blue, n._currentState.colorWrite.alpha = a.alpha
        };
        this._stateFuncs.cull = function(a) {
            n._currentState.cull !== a && (a ? n.gl.enable(h.CULL_FACE) : n.gl.disable(h.CULL_FACE), n._currentState.cull = a)
        };
        this._stateFuncs.depthTest = function(a) {
            n._currentState.depthTest !== a && (a ? n.gl.enable(h.DEPTH_TEST) : n.gl.disable(h.DEPTH_TEST), n._currentState.depthTest = 
            a)
        };
        this._stateFuncs.depthWrite = function(a) {
            n._currentState.depthWrite !== a && (n.gl.depthMask(a), n._currentState.depthWrite = a)
        };
        this._stateFuncs.fog = function(a) {
            n._currentState.fog = a
        };
        this._stateFuncs.fogColor = function(a) {
            n.scope.resolve("fog_color").setValue(a);
            n._currentState.fogColor = a
        };
        this._stateFuncs.fogDensity = function(a) {
            n._currentState.fogDensity !== a && (n.scope.resolve("fog_density").setValue(a), n._currentState.fogDensity = a)
        };
        this._stateFuncs.frontFace = function(a) {
            n._currentState.frontFace !== 
            a && (n.gl.frontFace(n.lookup.frontFace[a]), n._currentState.frontFace = a)
        };
        this.programLib = new pc.gfx.ProgramLibrary;
        for (var r in pc.gfx.programlib)
            this.programLib.register(r, pc.gfx.programlib[r]);
        r = h.getParameter(h.MAX_VERTEX_UNIFORM_VECTORS);
        r = r - 16 - 8;
        r -= 1;
        r -= 16;
        this.boneLimit = Math.floor(r / 4);
        110 < this.boneLimit && (this.boneLimit = 110);
        pc.extend(this, pc.events);
        this.boundBuffer = null;
        this.precalculatedTangents = !0;
        this.textureUnits = [];
        this.attributesInvalidated = !0
    };
    e.setCurrent = function(a) {
        e._current = a
    };
    e.getCurrent = function() {
        return e._current
    };
    e.prototype = {getProgramLibrary: function() {
            return this.programLib
        },setProgramLibrary: function(a) {
            this.programLib = a
        },updateBegin: function() {
            logASSERT(null !== this.canvas, "Device has not been started");
            this.boundBuffer = null;
            this.renderTarget.bind();
            for (var a = 0; 16 > a; a++)
                this.textureUnits[a] = null
        },updateEnd: function() {
        },draw: function(a) {
            this.attributesInvalidated && (this.commitAttributes(), this.attributesInvalidated = !1);
            this.commitSamplers();
            this.commitUniforms();
            var b = this.gl;
            a.indexed ? b.drawElements(this.lookupPrim[a.type], a.count, this.indexBuffer.glFormat, 2 * a.base) : b.drawArrays(this.lookupPrim[a.type], a.base, a.count)
        },clear: function(a) {
            var b = this.defaultClearOptions, a = a || b, d = this.lookupClear[a.flags || b.flags], c = this.gl;
            if (d & c.COLOR_BUFFER_BIT) {
                var e = a.color || b.color;
                c.clearColor(e[0], e[1], e[2], e[3])
            }
            d & c.DEPTH_BUFFER_BIT && c.clearDepth(a.depth || b.depth);
            c.clear(d)
        },getGlobalState: function() {
            return this._globalState
        },updateGlobalState: function(a) {
            for (var b in a) {
                if (void 0 === 
                this._localState[b])
                    this._stateFuncs[b](a[b]);
                this._globalState[b] = a[b]
            }
        },getLocalState: function() {
            return this._localState
        },updateLocalState: function(a) {
            for (var b in a)
                this._stateFuncs[b](a[b]), this._localState[b] = a[b]
        },clearLocalState: function() {
            for (var a in this._localState)
                this._stateFuncs[a](this._globalState[a]), delete this._localState[a]
        },getCurrentState: function() {
            return this._currentState
        },setRenderTarget: function(a) {
            this.renderTarget = a
        },getRenderTarget: function() {
            return this.renderTarget
        },
        setIndexBuffer: function(a) {
            if (this.indexBuffer !== a) {
                this.indexBuffer = a;
                var b = this.gl;
                b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, a ? a.bufferId : null)
            }
        },setVertexBuffer: function(a, b) {
            if (this.vertexBuffers[b] !== a) {
                this.vertexBuffers[b] = a;
                for (var d = 0, c = a.getFormat().elements, e = c.length; d < e; ) {
                    var m = c[d++];
                    m.stream = b;
                    m.scopeId.setValue(m)
                }
                this.attributesInvalidated = !0
            }
        },setProgram: function(a) {
            a !== this.program && (this.program = a, this.gl.useProgram(a.programId), this.attributesInvalidated = !0)
        },commitAttributes: function() {
            var a, 
            b, d, c, e, m = this.program.attributes, h = this.gl;
            a = 0;
            for (b = m.length; a < b; a++)
                d = m[a], c = d.scopeId.value, null !== c && (e = this.vertexBuffers[c.stream], this.boundBuffer !== e.bufferId && (h.bindBuffer(h.ARRAY_BUFFER, e.bufferId), this.boundBuffer = e.bufferId), h.enableVertexAttribArray(d.locationId), h.vertexAttribPointer(d.locationId, c.numComponents, this.lookup.elementType[c.dataType], c.normalize, c.stride, c.offset))
        },commitSamplers: function() {
            var a = this.gl, b, d, c, e = this.program.samplers;
            b = 0;
            for (d = e.length; b < d; b++)
                c = e[b], 
                texture = c.scopeId.value, this.textureUnits[b] !== texture && (a.activeTexture(a.TEXTURE0 + b), texture.bind(), this.textureUnits[b] = texture), c.slot !== b && (a.uniform1i(c.locationId, b), c.slot = b)
        },commitUniforms: function() {
            var a, b, d, c = this.program.uniforms;
            a = 0;
            for (b = c.length; a < b; a++)
                d = c[a], d.version.notequals(d.scopeId.versionObject.version) && (d.version.copy(d.scopeId.versionObject.version), this.commitFunction[d.dataType](d.locationId, d.scopeId.value))
        },getBoneLimit: function() {
            return this.boneLimit
        },setBoneLimit: function(a) {
            this.boneLimit = 
            a
        },enableValidation: function(a) {
            !0 === a ? this.gl instanceof WebGLRenderingContext && (this.gl = new WebGLValidator(this.gl)) : this.gl instanceof WebGLValidator && (this.gl = Context.gl)
        },validate: function() {
            var a = this.gl, b = a.getError();
            return b !== a.NO_ERROR ? (Log.error("WebGL error: " + WebGLValidator.ErrorString[b]), !1) : !0
        }};
    Object.defineProperty(e.prototype, "maxSupportedMaxAnisotropy", {get: function() {
            var a = 1, b = this.extTextureFilterAnisotropic;
            b && (a = this.gl.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
            return a
        }});
    return {UnsupportedBrowserError: b,ContextCreationError: a,Device: e}
}());
pc.gfx.post = {};
pc.gfx.post.initialize = function() {
    for (var b in pc.gfx.post)
        "object" === typeof pc.gfx.post[b] && pc.gfx.post[b].initialize()
};
pc.gfx.post.bloom = function() {
    var b = [], a = null, c = null, d = null, e = {bloomThreshold: 0.25,blurAmount: 4,bloomIntensity: 1.25,baseIntensity: 1,bloomSaturation: 1,baseSaturation: 1}, g = pc.math.vec4.create(0, 0, 0, 0), f = null, j = {type: pc.gfx.PRIMITIVE_TRIANGLE_STRIP,base: 0,count: 4,indexed: !1}, k = {depthTest: !1,depthWrite: !1}, l = function(a, b, d) {
        a.setRenderTarget(b);
        a.updateBegin();
        a.updateLocalState(k);
        a.setVertexBuffer(f, 0);
        a.setProgram(d);
        a.draw(j);
        a.clearLocalState();
        a.updateEnd()
    }, m = new Float32Array(15), h = new Float32Array(30), 
    n = function(a, b, d) {
        m[0] = 1 / Math.sqrt(2 * Math.PI * d) * Math.exp(-0 / (2 * d * d));
        h[0] = 0;
        h[1] = 0;
        var c = m[0], e, g;
        e = 0;
        for (g = Math.floor(7.5); e < g; e++) {
            var f = 1 / Math.sqrt(2 * Math.PI * d) * Math.exp(-((e + 1) * (e + 1)) / (2 * d * d));
            m[2 * e] = f;
            m[2 * e + 1] = f;
            c += 2 * f;
            f = 2 * e + 1.5;
            h[4 * e] = a * f;
            h[4 * e + 1] = b * f;
            h[4 * e + 2] = -a * f;
            h[4 * e + 3] = -b * f
        }
        e = 0;
        for (g = m.length; e < g; e++)
            m[e] /= c
    };
    return {initialize: function() {
            var e = new pc.gfx.Shader(pc.gfx.SHADERTYPE_VERTEX, "attribute vec3 aPosition;\n\nvarying vec2 vUv0;\n\nvoid main(void)\n{\n    gl_Position = vec4(aPosition, 1.0);\n    vUv0 = (aPosition.xy + 1.0) * 0.5;\n}"), 
            g = new pc.gfx.Shader(pc.gfx.SHADERTYPE_FRAGMENT, "precision mediump float;\n\nvarying vec2 vUv0;\n\nuniform sampler2D uBaseTexture;\nuniform float uBloomThreshold;\n\nvoid main(void)\n{\n    vec4 color = texture2D(uBaseTexture, vUv0);\n\n    gl_FragColor = clamp((color - uBloomThreshold) / (1.0 - uBloomThreshold), 0.0, 1.0);\n}"), j = new pc.gfx.Shader(pc.gfx.SHADERTYPE_FRAGMENT, "precision mediump float;\n\n#define SAMPLE_COUNT 15\n\nvarying vec2 vUv0;\n\nuniform sampler2D uBloomTexture;\nuniform vec2 uBlurOffsets[SAMPLE_COUNT];\nuniform float uBlurWeights[SAMPLE_COUNT];\n\nvoid main(void)\n{\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < SAMPLE_COUNT; i++)\n    {\n        color += texture2D(uBloomTexture, vUv0 + uBlurOffsets[i]) * uBlurWeights[i];\n    }\n\n    gl_FragColor = color;\n}"), 
            h = new pc.gfx.Shader(pc.gfx.SHADERTYPE_FRAGMENT, "precision mediump float;\n\nvarying vec2 vUv0;\n\n#define uBloomIntensity uCombineParams.x\n#define uBaseIntensity uCombineParams.y\n#define uBloomSaturation uCombineParams.z\n#define uBaseSaturation uCombineParams.w\nuniform vec4 uCombineParams;\nuniform sampler2D uBaseTexture;\nuniform sampler2D uBloomTexture;\n\nvec4 adjust_saturation(vec4 color, float saturation)\n{\n    float grey = dot(color.rgb, vec3(0.3, 0.59, 0.11));\n\n    return mix(vec4(grey), color, saturation);\n}\n\nvoid main(void)\n{\n    vec4 bloom = texture2D(uBloomTexture, vUv0);\n    vec4 base = texture2D(uBaseTexture, vUv0);\n\n    bloom = adjust_saturation(bloom, uBloomSaturation) * uBloomIntensity;\n    base = adjust_saturation(base, uBaseSaturation) * uBaseIntensity;\n\n    base *= (1.0 - clamp(bloom, 0.0, 1.0));\n\n    gl_FragColor = base + bloom;\n}");
            a = new pc.gfx.Program(e, g);
            c = new pc.gfx.Program(e, j);
            d = new pc.gfx.Program(e, h);
            e = pc.gfx.FrameBuffer.getBackBuffer();
            width = e.getWidth();
            height = e.getHeight();
            for (e = 0; 2 > e; e++)
                g = new pc.gfx.FrameBuffer(width >> 1, height >> 1, !1), j = g.getTexture(), j.minFilter = pc.gfx.FILTER_LINEAR, j.magFilter = pc.gfx.FILTER_LINEAR, j.addressU = pc.gfx.ADDRESS_CLAMP_TO_EDGE, j.addressV = pc.gfx.ADDRESS_CLAMP_TO_EDGE, b.push(new pc.gfx.RenderTarget(g));
            e = new pc.gfx.VertexFormat;
            e.begin();
            e.addElement(new pc.gfx.VertexElement("aPosition", 
            3, pc.gfx.VertexElementType.FLOAT32));
            e.end();
            f = new pc.gfx.VertexBuffer(e, 4);
            e = new pc.gfx.VertexIterator(f);
            e.element.aPosition.set(-1, -1, 0);
            e.next();
            e.element.aPosition.set(1, -1, 0);
            e.next();
            e.element.aPosition.set(-1, 1, 0);
            e.next();
            e.element.aPosition.set(1, 1, 0);
            e.end()
        },render: function(f, j, k) {
            if (void 0 === k)
                k = k || e;
            else
                for (var u in e)
                    "undefined" == typeof k[u] && (k[u] = e[u]);
            u = pc.gfx.Device.getCurrent();
            var x = u.scope;
            x.resolve("uBloomThreshold").setValue(k.bloomThreshold);
            x.resolve("uBaseTexture").setValue(f.getFrameBuffer().getTexture());
            l(u, b[0], a);
            n(1 / b[1].getFrameBuffer().getWidth(), 0, k.blurAmount);
            x.resolve("uBlurWeights[0]").setValue(m);
            x.resolve("uBlurOffsets[0]").setValue(h);
            x.resolve("uBloomTexture").setValue(b[0].getFrameBuffer().getTexture());
            l(u, b[1], c);
            n(0, 1 / b[0].getFrameBuffer().getHeight(), k.blurAmount);
            x.resolve("uBlurWeights[0]").setValue(m);
            x.resolve("uBlurOffsets[0]").setValue(h);
            x.resolve("uBloomTexture").setValue(b[1].getFrameBuffer().getTexture());
            l(u, b[0], c);
            g[0] = k.bloomIntensity;
            g[1] = k.baseIntensity;
            g[2] = k.bloomSaturation;
            g[3] = k.baseSaturation;
            x.resolve("uCombineParams").setValue(g);
            x.resolve("uBloomTexture").setValue(b[0].getFrameBuffer().getTexture());
            x.resolve("uBaseTexture").setValue(f.getFrameBuffer().getTexture());
            l(u, j, d)
        }}
}();
pc.gfx.programlib = {getSnippet: function(b) {
        var a = "";
        switch (b) {
            case "common_main_begin":
                a += "void main(void)\n{\n";
                break;
            case "common_main_end":
                a += "}\n";
                break;
            case "fs_alpha_test_decl":
                a += "uniform float alpha_ref;\n";
                break;
            case "fs_alpha_test":
                a += "    if (gl_FragColor.a <= alpha_ref)\n    {\n";
                a += "        discard;\n";
                a += "    }\n\n";
                break;
            case "fs_clamp":
                a += "    gl_FragColor = clamp(gl_FragColor, 0.0, 1.0);\n";
                break;
            case "fs_flat_color_decl":
                a += "uniform vec4 uColor;\n";
                break;
            case "fs_flat_color":
                a += "    gl_FragColor = uColor;\n";
                break;
            case "fs_fog_decl":
                a += "uniform vec3 fog_color;\n";
                a += "uniform float fog_density;\n\n";
                break;
            case "fs_fog":
                a += "    const float LOG2 = 1.442695;\n";
                a += "    float z = gl_FragCoord.z / gl_FragCoord.w;\n";
                a += "    float fogFactor = exp2(-fog_density * fog_density * z * z * LOG2);\n";
                a += "    fogFactor = clamp(fogFactor, 0.0, 1.0);\n";
                a += "    gl_FragColor.rgb = mix(fog_color, gl_FragColor.rgb, fogFactor);\n";
                break;
            case "fs_precision":
                a += "precision mediump float;\n\n";
                break;
            case "fs_depth_write":
                pc.gfx.Device.getCurrent().extDepthTexture ? 
                a += "    gl_FragData[0] = vec4(1.0);\n" : (a += "    vec4 packedDepth = fract((gl_FragCoord.z * vec4(1.67772e+07, 65536.0, 256.0, 1.0)));\n", a += "    gl_FragData[0] = (packedDepth - (packedDepth.xxyz * vec4(0.0, 0.00390625, 0.00390625, 0.00390625)));\n");
                break;
            case "fs_height_map_funcs":
                a += "vec3 perturb_normal( vec3 N, vec3 p, vec2 uv )\n";
                a += "{\n";
                a += "    vec3 dp1 = dFdx( p );\n";
                a += "    vec3 dp2 = dFdy( p );\n";
                a += "    vec2 duv1 = dFdx( uv );\n";
                a += "    vec2 duv2 = dFdy( uv );\n\n";
                a += "    vec3 dp2perp = cross( dp2, N );\n";
                a += "    vec3 dp1perp = cross( N, dp1 );\n\n";
                a += "    const float bumpScale = 0.125;\n";
                a += "    float Hll = bumpScale * texture2D( texture_heightMap, uv ).x;\n";
                a += "    float dBx = bumpScale * texture2D( texture_heightMap, uv + duv1 ).x - Hll;\n";
                a += "    float dBy = bumpScale * texture2D( texture_heightMap, uv + duv2 ).x - Hll;\n\n";
                a += "    float fDet = dot( dp1, dp2perp );\n";
                a += "    vec3 vGrad = sign( fDet ) * ( dBx * dp2perp + dBy * dp1perp );\n";
                a += "    return normalize( abs( fDet ) * N - vGrad );\n";
                a += "}\n\n";
                break;
            case "fs_normal_map_funcs":
                pc.gfx.Device.getCurrent().precalculatedTangents || (a += "mat3 cotangent_frame( vec3 N, vec3 p, vec2 uv )\n", a += "{\n", a += "    vec3 dp1 = dFdx( p );\n", a += "    vec3 dp2 = dFdy( p );\n", a += "    vec2 duv1 = dFdx( uv );\n", a += "    vec2 duv2 = dFdy( uv );\n\n", a += "    vec3 dp2perp = cross( dp2, N );\n", a += "    vec3 dp1perp = cross( N, dp1 );\n", a += "    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n", a += "    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\n", a += 
                "    float invmax = inversesqrt( max( dot(T,T), dot(B,B) ) );\n", a += "    return mat3( T * invmax, B * invmax, N );\n", a += "}\n\n", a += "vec3 perturb_normal( vec3 N, vec3 V, vec2 uv )\n", a += "{\n", a += "    vec3 map = texture2D( texture_normalMap, uv ).xyz;\n", a += "    map = map * 255./127. - 128./127.;\n", a += "    map.xy = map.xy * material_bumpMapFactor;\n", a += "    mat3 TBN = cotangent_frame( N, -V, uv );\n", a += "    return normalize( TBN * map );\n", a += "}\n\n");
                break;
            case "vs_skin_position_decl":
                b = pc.gfx.Device.getCurrent().getBoneLimit();
                a += "attribute vec3 vertex_position;\n";
                a += "attribute vec4 vertex_boneWeights;\n";
                a += "attribute vec4 vertex_boneIndices;\n";
                a += "uniform mat4 matrix_pose[" + b + "];\n";
                a += "uniform mat4 matrix_viewProjection;\n\n";
                break;
            case "vs_skin_position":
                a += "    vec4 position, positionW;\n";
                a += "    position = vec4(vertex_position, 1.0);\n";
                a += "    positionW  = vertex_boneWeights[0] * matrix_pose[int(vertex_boneIndices[0])] * position;\n";
                a += "    positionW += vertex_boneWeights[1] * matrix_pose[int(vertex_boneIndices[1])] * position;\n";
                a += "    positionW += vertex_boneWeights[2] * matrix_pose[int(vertex_boneIndices[2])] * position;\n";
                a += "    positionW += vertex_boneWeights[3] * matrix_pose[int(vertex_boneIndices[3])] * position;\n";
                a += "    gl_Position = matrix_viewProjection * positionW;\n";
                break;
            case "vs_skin_normal":
                a += "    vec3 normalW, normalE;\n";
                a += "    vec4 normal = vec4(vertex_normal, 0.0);\n";
                a += "    normalW  = (vertex_boneWeights[0] * matrix_pose[int(vertex_boneIndices[0])] * normal).xyz;\n";
                a += "    normalW += (vertex_boneWeights[1] * matrix_pose[int(vertex_boneIndices[1])] * normal).xyz;\n";
                a += "    normalW += (vertex_boneWeights[2] * matrix_pose[int(vertex_boneIndices[2])] * normal).xyz;\n";
                a += "    normalW += (vertex_boneWeights[3] * matrix_pose[int(vertex_boneIndices[3])] * normal).xyz;\n";
                a += "    normalE = normalize((matrix_view * normalW).xyz);\n";
                break;
            case "vs_skin_tangent":
                a += "    vec3 tangentW, tangentE;\n";
                a += "    vec4 tangent = vec4(vertex_tangent, 0.0);\n";
                a += "    tangentW  = (vertex_boneWeights[0] * matrix_pose[int(vertex_boneIndices[0])] * tangent).xyz;\n";
                a += "    tangentW += (vertex_boneWeights[1] * matrix_pose[int(vertex_boneIndices[1])] * tangent).xyz;\n";
                a += "    tangentW += (vertex_boneWeights[2] * matrix_pose[int(vertex_boneIndices[2])] * tangent).xyz;\n";
                a += "    tangentW += (vertex_boneWeights[3] * matrix_pose[int(vertex_boneIndices[3])] * tangent).xyz;\n";
                a += "    tangentE = normalize((matrix_view * tangentW).xyz);\n";
                break;
            case "vs_static_position_decl":
                a += "attribute vec3 vertex_position;\n";
                a += "uniform mat4 matrix_model;\n";
                a += "uniform mat4 matrix_viewProjection;\n\n";
                break;
            case "vs_static_position":
                a += "    vec4 positionW = matrix_model * vec4(vertex_position, 1.0);\n", 
                a += "    gl_Position = matrix_viewProjection * positionW;\n"
        }
        return a
    }};
pc.gfx.programlib.basic = {generateKey: function(b) {
        var a = "basic";
        b.fog && (a += "_fog");
        b.alphaTest && (a += "_atst");
        b.vertexColors && (a += "_vcol");
        b.diffuseMap && (a += "_diff");
        return a
    },generateVertexShader: function(b) {
        var a = pc.gfx.programlib.getSnippet, c = "", c = b.skin ? c + a("vs_skin_position_decl") : c + a("vs_static_position_decl");
        b.vertexColors && (c += "attribute vec4 vertex_color;\nvarying vec4 vColor;\n");
        b.diffuseMap && (c += "attribute vec2 vertex_texCoord0;\n", c += "varying vec2 vUv0;\n");
        c += a("common_main_begin");
        c = 
        b.skin ? c + a("vs_skin_position") : c + a("vs_static_position");
        b.vertexColors && (c += "    vColor = vertex_color;\n");
        b.diffuseMap && (c += "    vUv0 = vertex_texCoord0;\n");
        return c += a("common_main_end")
    },generateFragmentShader: function(b) {
        var a = pc.gfx.programlib.getSnippet, c = a("fs_precision"), c = b.vertexColors ? c + "varying vec4 vColor;\n" : c + "uniform vec4 uColor;\n";
        b.diffuseMap && (c += "varying vec2 vUv0;\nuniform sampler2D texture_diffuseMap;\n");
        b.fog && (c += a("fs_fog_decl"));
        b.alphatest && (c += a("fs_alpha_test_decl"));
        c += a("common_main_begin");
        c = b.vertexColors ? c + "    gl_FragColor = vColor;\n" : c + "    gl_FragColor = uColor;\n";
        b.diffuseMap && (c += "    gl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n");
        b.alphatest && (c += a("fs_alpha_test"));
        c += a("fs_clamp");
        b.fog && (c += a("fs_fog"));
        return c += a("common_main_end")
    }};
pc.gfx.programlib.depth = {generateKey: function(b) {
        var a = "depth";
        b.skin && (a += "_skin");
        b.opacityMap && (a += "_opam");
        return a
    },generateVertexShader: function(b) {
        var a = pc.gfx.programlib.getSnippet, c = "", c = b.skin ? c + a("vs_skin_position_decl") : c + a("vs_static_position_decl");
        b.opacityMap && (c += "attribute vec2 vertex_texCoord0;\n\nvarying vec2 vUv0;\n\n");
        c += a("common_main_begin");
        c = b.skin ? c + a("vs_skin_position") : c + a("vs_static_position");
        b.opacityMap && (c += "    vUv0 = vertex_texCoord0;\n");
        return c += a("common_main_end")
    },
    generateFragmentShader: function(b) {
        var a = pc.gfx.programlib.getSnippet, c = a("fs_precision");
        b.opacityMap && (c += "varying vec2 vUv0;\n\nuniform sampler2D texture_opacityMap;\n\n");
        c += a("common_main_begin");
        b.opacityMap && (c += "    if (texture2D(texture_opacityMap, vUv0).r < 0.25) discard;\n\n");
        c += a("fs_depth_write");
        return c += a("common_main_end")
    }};
pc.gfx.programlib.phong = {generateKey: function(b) {
        var a = "phong";
        b.skin && (a += "_skin");
        b.fog && (a += "_fog");
        b.alphaTest && (a += "_atst");
        0 < b.numDirs && (a += "_" + b.numDirs + "dir");
        0 < b.numPnts && (a += "_" + b.numPnts + "pnt");
        0 < b.numSpts && (a += "_" + b.numSpts + "spt");
        0 < b.numSDirs && (a += "_" + b.numSDirs + "sdir");
        0 < b.numSPnts && (a += "_" + b.numSPnts + "spnt");
        0 < b.numSSpts && (a += "_" + b.numSSpts + "sspt");
        b.vertexColors && (a += "_vcol");
        a = b.diffuseMapTransform ? a + "_difx" : b.diffuseMap ? a + "_difm" : a + "_difc";
        a = b.specularMapTransform ? a + "_spex" : b.specularMap ? 
        a + "_spem" : a + "_spec";
        b.specularFactorMapTransform ? a += "_spfx" : b.specularFactorMap && (a += "_spfm");
        b.glossMapTransform ? a += "_glox" : b.glossMap && (a += "_glom");
        a = b.emissiveMapTransform ? a + "_emix" : b.emissiveMap ? a + "_emim" : a + "_emic";
        b.opacityMapTransform ? a += "_opax" : b.opacityMap && (a += "_opam");
        b.normalMapTransform ? a += "_norx" : b.normalMap && (a += "_norm");
        b.heightMapTransform ? a += "_hgtx" : b.heightMap && (a += "_hgtm");
        b.sphereMap && (a += "_sphr");
        b.cubeMap && (a += "_cube");
        b.lightMap && (a += "_lght");
        return a
    },generateVertexShader: function(b) {
        var a = 
        "", c, d = b.numDirs + b.numSDirs, e = b.numPnts + b.numSPnts, g = b.numDirs + b.numPnts + b.numSpts + (b.numSDirs + b.numSPnts + b.numSSpts), f = 0 < g, j = b.diffuseMap && !b.diffuseMapTransform || b.specularMap && !b.specularMapTransform || b.specularFactorMap && !b.specularFactorMapTransform || b.glossMap && !b.glossMapTransform || b.emissiveMap && !b.emissiveMapTransform || b.opacityMap && !b.opacityMapTransform || b.normalMap && !b.normalMapTransform || b.heightMap && !b.heightMapTransform, k = pc.gfx.Device.getCurrent().precalculatedTangents, a = a + "attribute vec3 vertex_position;\n";
        if (f || b.cubeMap || b.sphereMap)
            a += "attribute vec3 vertex_normal;\n", b.normalMap && k && (a += "attribute vec4 vertex_tangent;\n");
        if (b.diffuseMap || b.specularMap || b.specularFactorMap || b.glossMap || b.emissiveMap || b.normalMap || b.heightMap || b.opacityMap)
            a += "attribute vec2 vertex_texCoord0;\n";
        b.lightMap && (a += "attribute vec2 vertex_texCoord1;\n");
        b.vertexColors && (a += "attribute vec4 vertex_color;\n");
        b.skin && (a += "attribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\n");
        a += "\n";
        a += "uniform mat4 matrix_viewProjection;\n";
        a += "uniform mat4 matrix_model;\n";
        b.skin && (c = pc.gfx.Device.getCurrent().getBoneLimit(), a += "uniform mat4 matrix_pose[" + c + "];\n");
        for (c = 0; c < g; c++)
            if (c < d && (a += "uniform vec3 light" + c + "_direction;\n"), c >= d && (a += "uniform vec3 light" + c + "_position;\n"), c >= d + e && (a += "uniform vec3 light" + c + "_spotDirection;\n"), c >= b.numDirs && c < d || c >= d + b.numPnts && c < d + e || c >= d + e + b.numSpts && c < g)
                a += "uniform mat4 light" + c + "_shadowMatrix;\n";
        f && (a += "uniform vec3 view_position;\n");
        b.diffuseMap && b.diffuseMapTransform && (a += "uniform mat4 texture_diffuseMapTransform;\n");
        b.normalMap && b.normalMapTransform && (a += "uniform mat4 texture_normalMapTransform;\n");
        b.heightMap && b.heightMapTransform && (a += "uniform mat4 texture_heightMapTransform;\n");
        b.opacityMap && b.opacityMapTransform && (a += "uniform mat4 texture_opacityMapTransform;\n");
        b.specularMap && b.specularMapTransform && (a += "uniform mat4 texture_specularMapTransform;\n");
        b.specularFactorMap && b.specularFactorMapTransform && (a += "uniform mat4 texture_specularFactorMapTransform;\n");
        b.glossMap && b.glossMapTransform && (a += "uniform mat4 texture_glossMapTransform;\n");
        b.emissiveMap && b.emissiveMapTransform && (a += "uniform mat4 texture_emissiveMapTransform;\n");
        a += "\n";
        if (f) {
            if (!b.normalMap || !k)
                a += "varying vec3 vNormalW;\n";
            a += "varying vec3 vViewDirW;\n";
            for (c = 0; c < g; c++)
                if (a += "varying vec3 vLight" + c + "DirW;\n", c >= d + e && (a += "varying vec3 vLight" + c + "SpotDirW;\n"), c >= b.numDirs && c < d || c >= d + b.numPnts && c < d + e || c >= d + e + b.numSpts && c < g)
                    a += "varying vec4 vLight" + c + "ShadowCoord;\n"
        }
        j && (a += "varying vec2 vUv0;\n");
        b.diffuseMap && b.diffuseMapTransform && (a += "varying vec2 vUvDiffuseMap;\n");
        if (f && (b.specularMap && b.specularMapTransform && (a += "varying vec2 vUvSpecularMap;\n"), b.specularFactorMap && b.specularFactorMapTransform && (a += "varying vec2 vUvSpecularFactorMap;\n"), b.glossMap && b.glossMapTransform && (a += "varying vec2 vUvGlossMap;\n"), b.normalMap && b.normalMapTransform || b.heightMap && b.heightMapTransform))
            a += "varying vec2 vUvBumpMap;\n";
        b.emissiveMap && b.emissiveMapTransform && (a += "varying vec2 vUvEmissiveMap;\n");
        b.opacityMap && b.opacityMapTransform && (a += "varying vec2 vUvOpacityMap;\n");
        b.lightMap && 
        (a += "varying vec2 vUvLightMap;\n");
        b.vertexColors && (a += "varying vec4 vVertexColor;\n");
        a += "\n";
        a += "void main(void)\n";
        a += "{\n";
        a += "    vec4 position = vec4(vertex_position, 1.0);\n";
        if (f || b.cubeMap || b.sphereMap)
            a += "    vec4 normal   = vec4(vertex_normal, 0.0);\n", b.normalMap && k && (a += "    vec4 tangent  = vec4(vertex_tangent.xyz, 0.0);\n");
        a += "\n";
        if (b.skin) {
            if (a += "    vec4 positionW;\n", a += "    positionW  = vertex_boneWeights[0] * matrix_pose[int(vertex_boneIndices[0])] * position;\n", a += "    positionW += vertex_boneWeights[1] * matrix_pose[int(vertex_boneIndices[1])] * position;\n", 
            a += "    positionW += vertex_boneWeights[2] * matrix_pose[int(vertex_boneIndices[2])] * position;\n", a += "    positionW += vertex_boneWeights[3] * matrix_pose[int(vertex_boneIndices[3])] * position;\n\n", f || b.cubeMap || b.sphereMap)
                a += "    vec4 normalW;\n", a += "    normalW  = vertex_boneWeights[0] * matrix_pose[int(vertex_boneIndices[0])] * normal;\n", a += "    normalW += vertex_boneWeights[1] * matrix_pose[int(vertex_boneIndices[1])] * normal;\n", a += "    normalW += vertex_boneWeights[2] * matrix_pose[int(vertex_boneIndices[2])] * normal;\n", 
                a += "    normalW += vertex_boneWeights[3] * matrix_pose[int(vertex_boneIndices[3])] * normal;\n\n", b.normalMap && k && (a += "    vec4 tangentW;\n", a += "    tangentW  = vertex_boneWeights[0] * matrix_pose[int(vertex_boneIndices[0])] * tangent;\n", a += "    tangentW += vertex_boneWeights[1] * matrix_pose[int(vertex_boneIndices[1])] * tangent;\n", a += "    tangentW += vertex_boneWeights[2] * matrix_pose[int(vertex_boneIndices[2])] * tangent;\n", a += "    tangentW += vertex_boneWeights[3] * matrix_pose[int(vertex_boneIndices[3])] * tangent;\n\n")
        } else {
            a += 
            "    vec4 positionW = matrix_model * position;\n";
            if (f || b.cubeMap || b.sphereMap)
                a += "    vec4 normalW   = matrix_model * normal;\n", b.normalMap && k && (a += "    vec4 tangentW = matrix_model * tangent;\n");
            a += "\n"
        }
        if (f || b.cubeMap || b.sphereMap)
            a += "    normalW.xyz = normalize(normalW.xyz);\n", b.normalMap && k && (a += "    tangentW.xyz  = normalize(tangentW.xyz);\n"), a += "\n";
        a += "    gl_Position = matrix_viewProjection * positionW;\n\n";
        if (f) {
            if (b.normalMap && k) {
                a += "    vec3 binormalW = cross(normalW.xyz, tangentW.xyz) * vertex_tangent.w;\n";
                a += "    mat3 tbnMatrix = mat3(tangentW.x, binormalW.x, normalW.x,\n";
                a += "                          tangentW.y, binormalW.y, normalW.y,\n";
                a += "                          tangentW.z, binormalW.z, normalW.z);\n";
                a += "    vViewDirW = tbnMatrix * (view_position - positionW.xyz);\n";
                for (c = 0; c < g; c++)
                    c < d && (a += "    vLight" + c + "DirW = -(tbnMatrix * light" + c + "_direction);\n"), c >= d && (a += "    vLight" + c + "DirW = tbnMatrix * (light" + c + "_position - positionW.xyz);\n"), c >= d + e && (a += "    vLight" + c + "SpotDirW = tbnMatrix * light" + 
                    c + "_spotDirection;\n")
            } else {
                a += "    vNormalW = normalW.xyz;\n";
                a += "    vViewDirW = view_position - positionW.xyz;\n";
                for (c = 0; c < g; c++)
                    c < d && (a += "    vLight" + c + "DirW = -light" + c + "_direction;\n"), c >= d && (a += "    vLight" + c + "DirW = light" + c + "_position - positionW.xyz;\n"), c >= d + e && (a += "    vLight" + c + "SpotDirW = light" + c + "_spotDirection;\n")
            }
            for (c = 0; c < g; c++)
                if (c >= b.numDirs && c < d || c >= d + b.numPnts && c < d + e || c >= d + e + b.numSpts && c < g)
                    a += "    vLight" + c + "ShadowCoord = light" + c + "_shadowMatrix * positionW;\n";
            a += "\n"
        }
        j && 
        (a += "    vUv0 = vertex_texCoord0;\n");
        b.diffuseMap && b.diffuseMapTransform && (a += "    vUvDiffuseMap = (texture_diffuseMapTransform * vec4(vertex_texCoord0, 0, 1)).st;\n");
        f && (b.specularMap & b.specularMapTransform && (a += "    vUvSpecularMap = (texture_specularMapTransform * vec4(vertex_texCoord0, 0, 1)).st;\n"), b.specularFactorMap && b.specularFactorMapTransform && (a += "    vUvSpecularFactorMap = (texture_specularFactorMapTransform * vec4(vertex_texCoord0, 0, 1)).st;\n"), b.glossMap & b.glossMapTransform && (a += 
        "    vUvGlossMap = (texture_glossMapTransform * vec4(vertex_texCoord0, 0, 1)).st;\n"), b.normalMap && b.normalMapTransform ? a += "    vUvBumpMap = (texture_normalMapTransform * vec4(vertex_texCoord0, 0, 1)).st;\n" : b.heightMap && b.heightMapTransform && (a += "    vUvBumpMap = (texture_heightMapTransform * vec4(vertex_texCoord0, 0, 1)).st;\n"));
        b.opacityMap && b.opacityMapTransform && (a += "    vUvOpacityMap = (texture_opacityMapTransform * vec4(vertex_texCoord0, 0, 1)).st;\n");
        b.emissiveMap && b.emissiveMapTransform && 
        (a += "    vUvEmissiveMap = (texture_emissiveMapTransform * vec4(vertex_texCoord0, 0, 1)).st;\n");
        b.lightMap && (a += "    vUvLightMap = vertex_texCoord1;\n");
        return a += "}"
    },generateFragmentShader: function(b) {
        var a, c = b.numSDirs + b.numSPnts + b.numSSpts, d = b.numDirs + b.numSDirs, e = b.numPnts + b.numSPnts, g = b.numSpts + b.numSSpts, f = b.numDirs + b.numPnts + b.numSpts + c, j = 0 < f, k = b.diffuseMap && !b.diffuseMapTransform || b.specularMap && !b.specularMapTransform || b.specularFactorMap && !b.specularFactorMapTransform || b.glossMap && !b.glossMapTransform || 
        b.emissiveMap && !b.emissiveMapTransform || b.opacityMap && !b.opacityMapTransform || b.normalMap && !b.normalMapTransform || b.heightMap && !b.heightMapTransform, l = pc.gfx.Device.getCurrent().precalculatedTangents, m = pc.gfx.programlib.getSnippet, h = m("fs_precision");
        if (b.normalMap && !l || b.heightMap)
            h += "#extension GL_OES_standard_derivatives : enable\n\n";
        if (j) {
            if (!b.normalMap || !l)
                h += "varying vec3 vNormalW;\n";
            h += "varying vec3 vViewDirW;\n";
            for (a = 0; a < f; a++)
                if (h += "varying vec3 vLight" + a + "DirW;\n", a >= d + e && (h += "varying vec3 vLight" + 
                a + "SpotDirW;\n"), a >= b.numDirs && a < d || a >= d + b.numPnts && a < d + e || a >= d + e + b.numSpts && a < f)
                    h += "varying vec4 vLight" + a + "ShadowCoord;\n"
        }
        k && (h += "varying vec2 vUv0;\n");
        b.diffuseMap && b.diffuseMapTransform && (h += "varying vec2 vUvDiffuseMap;\n");
        if (j && (b.specularMap && b.specularMapTransform && (h += "varying vec2 vUvSpecularMap;\n"), b.specularFactorMap && b.specularFactorMapTransform && (h += "varying vec2 vUvSpecularFactorMap;\n"), b.glossMap && b.glossMapTransform && (h += "varying vec2 vUvGlossMap;\n"), b.normalMap && b.normalMapTransform || 
        b.heightMap && b.heightMapTransform))
            h += "varying vec2 vUvBumpMap;\n";
        b.emissiveMap && b.emissiveMapTransform && (h += "varying vec2 vUvEmissiveMap;\n");
        b.opacityMap && b.opacityMapTransform && (h += "varying vec2 vUvOpacityMap;\n");
        b.lightMap && (h += "varying vec2 vUvLightMap;\n");
        b.vertexColors && (h += "varying vec4 vVertexColor;\n");
        h += "\n";
        h = b.diffuseMap ? h + "uniform sampler2D texture_diffuseMap;\n" : h + "uniform vec3 material_ambient;\nuniform vec3 material_diffuse;\n";
        j && (h = b.specularMap ? h + "uniform sampler2D texture_specularMap;\n" : 
        h + "uniform vec3 material_specular;\n", b.specularFactorMap && (h += "uniform sampler2D texture_specularFactorMap;\n"), h = b.glossMap ? h + "uniform sampler2D texture_glossMap;\n" : h + "uniform float material_shininess;\n");
        h = b.emissiveMap ? h + "uniform sampler2D texture_emissiveMap;\n" : h + "uniform vec3 material_emissive;\n";
        b.lightMap && (h += "uniform sampler2D texture_lightMap;\n");
        if (j && (b.normalMap && (h += "uniform sampler2D texture_normalMap;\n", h += "uniform float material_bumpMapFactor;\n"), b.heightMap && (h += "uniform sampler2D texture_heightMap;\n"), 
        b.cubeMap || b.sphereMap))
            h += "uniform float material_reflectionFactor;\n", b.sphereMap ? (h += "uniform mat4 matrix_view;\n", h += "uniform sampler2D texture_sphereMap;\n") : h += "uniform samplerCube texture_cubeMap;\n";
        h = b.opacityMap ? h + "uniform sampler2D texture_opacityMap;\n" : h + "uniform float material_opacity;\n";
        h += "uniform vec3 light_globalAmbient;\n";
        for (a = 0; a < f; a++)
            if (h += "uniform vec3 light" + a + "_color;\n", a >= d && (h += "uniform float light" + a + "_radius;\n", a >= d + e && (h += "uniform float light" + a + "_innerConeAngle;\n", 
            h += "uniform float light" + a + "_outerConeAngle;\n")), a >= b.numDirs && a < d || a >= d + b.numPnts && a < d + e || a >= d + e + b.numSpts && a < f)
                h += "uniform vec3 light" + a + "_shadowParams;\n", h += "uniform sampler2D light" + a + "_shadowMap;\n";
        b.fog && (h += m("fs_fog_decl"));
        b.alphaTest && (h += m("fs_alpha_test_decl"));
        b.normalMap ? h += m("fs_normal_map_funcs") : b.heightMap && (h += m("fs_height_map_funcs"));
        h += "\n";
        0 < c && (h += "float calculateShadowFactor(const in vec4 sc, const in vec3 sp, const in sampler2D shadowMap)\n", h += "{\n", h += "    float depth;\n", 
        h += "    float depthBias = sp.z;\n", h += "    vec3 shadowCoord = sc.xyz / sc.w;\n", h += "    shadowCoord.z += depthBias;\n", h += "    bvec4 containedVec = bvec4(shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0);\n", h += "    bool contained = all(bvec2(all(containedVec), shadowCoord.z <= 1.0));\n", h += "    if (contained)\n", h += "    {\n", h += "        float shadowAccum = 0.0;\n", h += "        float xoffset = 1.0 / sp[0];\n", h += "        float yoffset = 1.0 / sp[1];\n", h += "        float dx0 = -xoffset;\n", 
        h += "        float dy0 = -yoffset;\n", h += "        float dx1 = xoffset;\n", h += "        float dy1 = yoffset;\n", h += "        mat3 shadowKernel;\n", h += "        mat3 depthKernel;\n", h += "        const vec4 bit_shift = vec4(5.96046e-08, 1.52588e-05, 0.00390625, 1.0);\n", h += "        depthKernel[0][0] = dot(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dy0)), bit_shift);\n", h += "        shadowKernel[0][0] = (depthKernel[0][0] < shadowCoord.z) ? 0.25 : 0.0;\n", h += "        depthKernel[0][1] = dot(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)), bit_shift);\n", 
        h += "        shadowKernel[0][1] = (depthKernel[0][1] < shadowCoord.z) ? 0.25 : 0.0;\n", h += "        depthKernel[0][2] = dot(texture2D(shadowMap, shadowCoord.xy + vec2(dx0, dy1)), bit_shift);\n", h += "        shadowKernel[0][2] = (depthKernel[0][2] < shadowCoord.z) ? 0.25 : 0.0;\n", h += "        depthKernel[1][0] = dot(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dy0)), bit_shift);\n", h += "        shadowKernel[1][0] = (depthKernel[1][0] < shadowCoord.z) ? 0.25 : 0.0;\n", h += "        depthKernel[1][1] = dot(texture2D(shadowMap, shadowCoord.xy), bit_shift);\n", 
        h += "        shadowKernel[1][1] = (depthKernel[1][1] < shadowCoord.z) ? 0.25 : 0.0;\n", h += "        depthKernel[1][2] = dot(texture2D(shadowMap, shadowCoord.xy + vec2(0.0, dy1)), bit_shift);\n", h += "        shadowKernel[1][2] = (depthKernel[1][2] < shadowCoord.z) ? 0.25 : 0.0;\n", h += "        depthKernel[2][0] = dot(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dy0)), bit_shift);\n", h += "        shadowKernel[2][0] = (depthKernel[2][0] < shadowCoord.z) ? 0.25 : 0.0;\n", h += "        depthKernel[2][1] = dot(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)), bit_shift);\n", 
        h += "        shadowKernel[2][1] = (depthKernel[2][1] < shadowCoord.z) ? 0.25 : 0.0;\n", h += "        depthKernel[2][2] = dot(texture2D(shadowMap, shadowCoord.xy + vec2(dx1, dy1)), bit_shift);\n", h += "        shadowKernel[2][2] = (depthKernel[2][2] < shadowCoord.z) ? 0.25 : 0.0;\n", h += "        vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * sp.xy );\n", h += "        shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n", h += "        shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n", 
        h += "        vec4 shadowValues;\n", h += "        shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n", h += "        shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n", h += "        shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n", h += "        shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n", h += "        shadowAccum = 1.0 - dot( shadowValues, vec4( 1.0 ) );\n", h += "        return shadowAccum;\n", 
        h += "    }\n", h += "    else\n", h += "    {\n", h += "        return 1.0;\n", h += "    }\n", h += "}\n\n");
        h += m("common_main_begin");
        b.diffuseMap && (h = b.diffuseMapTransform ? h + "    vec2 uvDiffuseMap = vUvDiffuseMap;\n" : h + "    vec2 uvDiffuseMap = vUv0;\n");
        if (j && (b.specularMap && (h = b.specularMapTransform ? h + "    vec2 uvSpecularMap = vUvSpecularMap;\n" : h + "    vec2 uvSpecularMap = vUv0;\n"), b.specularFactorMap && (h = b.specularFactorMapTransform ? h + "    vec2 uvSpecularFactorMap = vUvSpecularFactorMap;\n" : h + "    vec2 uvSpecularFactorMap = vUv0;\n"), 
        b.glossMap && (h = b.glossMapTransform ? h + "    vec2 uvGlossMap = vUvGlossMap;\n" : h + "    vec2 uvGlossMap = vUv0;\n"), b.normalMap || b.heightMap))
            h = b.normalMapTransform || b.heightMapTransform ? h + "    vec2 uvBumpMap = vUvBumpMap;\n" : h + "    vec2 uvBumpMap = vUv0;\n";
        b.opacityMap && (h = b.opacityMapTransform ? h + "    vec2 uvOpacityMap = vUvOpacityMap;\n" : h + "    vec2 uvOpacityMap = vUv0;\n");
        b.emissiveMap && (h = b.emissiveMapTransform ? h + "    vec2 uvEmissiveMap = vUvEmissiveMap;\n" : h + "    vec2 uvEmissiveMap = vUv0;\n");
        b.lightMap && (h += "    vec2 uvLightMap = vUvLightMap;\n");
        if (j) {
            h += "    vec3 viewDirW = normalize(vViewDirW);\n";
            if (!b.normalMap || !l)
                h += "    vec3 normalW = normalize(vNormalW);\n";
            b.normalMap && b.heightMap && (h += "    const float parallaxScale = 0.025;\n", h += "    const float parallaxBias = 0.01;\n", h += "    float height = texture2D(texture_heightMap, uvBumpMap).a * parallaxScale - parallaxBias;\n", h += "    uvBumpMap = uvBumpMap - min(height * viewDirW.xy, vec2(parallaxBias));\n", b.diffuseMap && (h += "    uvDiffuseMap = uvDiffuseMap - min(height * viewDirW.xy, vec2(parallaxBias));\n"), 
            b.specularMap && (h += "    uvSpecularMap = uvSpecularMap - min(height * viewDirW.xy, vec2(parallaxBias));\n"));
            h += "\n"
        }
        b.diffuseMap ? (h += "    vec3 diffuseColor = texture2D(texture_diffuseMap, uvDiffuseMap).rgb;\n", h += "    vec3 ambientColor = diffuseColor;\n") : (h += "    vec3 ambientColor = material_ambient;\n", h += "    vec3 diffuseColor = material_diffuse;\n");
        j && (h = b.specularMap ? h + "    vec3 specularColor = texture2D(texture_specularMap, uvSpecularMap).rgb;\n" : h + "    vec3 specularColor = material_specular;\n", 
        b.specularFactorMap && (h += "    specularColor *= texture2D(texture_specularFactorMap, uvSpecularFactorMap).rgb;\n"), h = b.glossMap ? h + "    float shininess = texture2D(texture_glossMap, uvGlossMap).r * 100.0 + 0.0001;\n" : h + "    float shininess = material_shininess + 0.0001;\n");
        h = b.emissiveMap ? h + "    vec3 emissiveColor = texture2D(texture_emissiveMap, uvEmissiveMap).rgb;\n" : h + "    vec3 emissiveColor = material_emissive;\n";
        h = b.opacityMap ? h + "    float opacity = texture2D(texture_opacityMap, uvOpacityMap).r;\n" : 
        h + "    float opacity = material_opacity;\n";
        h += "\n";
        b.alphaTest && (h += m("fs_alpha_test"));
        if (j || b.lightMap)
            h += "    vec3 diffuseContrib = vec3(0.0);\n";
        if (j) {
            h += "    vec3 specularContrib = vec3(0.0);\n";
            b.normalMap ? l ? (h += "    vec3 N = normalize(texture2D(texture_normalMap, uvBumpMap).xyz * 2.0 - 1.0);\n", h += "    N = normalize(mix(vec3(0.0, 0.0, 1.0), N, material_bumpMapFactor));\n") : h += "    vec3 N = perturb_normal(normalW, viewDirW, uvBumpMap);\n" : h += "    vec3 N = normalW;\n";
            h += "    vec3 L, R;\n";
            h += "    float diffuseLight, specularLight;\n";
            0 < e + g && (h += "    float d, attenuation;\n");
            0 < g && (h += "    float cosAngle, spotEffect;\n");
            0 < c && (h += "    float shadowFactor;\n");
            h += "\n";
            for (a = 0; a < f; a++)
                c = a >= d, g = a >= d + e, k = a >= b.numDirs && a < d || a >= d + b.numPnts && a < d + e || a >= d + e + b.numSpts && a < f, h += "    L = normalize(vLight" + a + "DirW);\n", h += "    diffuseLight = max(dot(N, L), 0.0);\n", h += "    R = normalize(-reflect(L, N));\n", h += "    specularLight = pow(max(dot(R, viewDirW), 0.0), shininess);\n", c && (h += "    d = length(vLight" + 
                a + "DirW);\n", h += "    attenuation = max(((light" + a + "_radius - d) / light" + a + "_radius), 0.0);\n"), g && (h += "    cosAngle = dot(-L, vLight" + a + "SpotDirW);\n", h += "    spotEffect = smoothstep(light" + a + "_outerConeAngle, light" + a + "_innerConeAngle, cosAngle);\n"), k && (h += "    shadowFactor = calculateShadowFactor(vLight" + a + "ShadowCoord, light" + a + "_shadowParams, light" + a + "_shadowMap);\n"), h += "    diffuseContrib += light" + a + "_color * diffuseLight" + (c ? " * attenuation" : "") + (g ? " * spotEffect" : "") + (k ? " * shadowFactor" : 
                "") + ";\n", h += "    if (diffuseLight <= 0.0) specularLight = 0.0;\n", h += "    specularContrib += light" + a + "_color * specularLight" + (c ? " * attenuation" : "") + (g ? " * spotEffect" : "") + (k ? " * shadowFactor" : "") + ";\n\n"
        }
        b.lightMap && (h += "    diffuseContrib += texture2D(texture_lightMap, uvLightMap).rgb;\n");
        if (j && (b.cubeMap || b.sphereMap))
            h += "    vec3 reflectW = -reflect(viewDirW, N);\n", b.cubeMap ? h += "    vec3 reflectionColor = textureCube(texture_cubeMap, reflectW).rgb;\n" : b.sphereMap && (h += "    vec3 reflectE = (matrix_view * vec4(reflectW, 0.0)).xyz;\n", 
            h += "    float m = 2.0 * sqrt( dot(reflectE.xy, reflectE.xy) + (reflectE.z+1.0)*(reflectE.z+1.0) );\n", h += "    vec2 sphereMapUv = reflectE.xy / m + 0.5;\n", h += "    vec3 reflectionColor = texture2D(texture_sphereMap, sphereMapUv).rgb;\n"), h += "    diffuseColor = mix(diffuseColor, reflectionColor, material_reflectionFactor);\n\n";
        h += "    vec3 ambient  = ambientColor * light_globalAmbient;\n";
        if (j || b.lightMap)
            h += "    vec3 diffuse  = diffuseColor * diffuseContrib;\n";
        j && (h += "    vec3 specular = specularColor * specularContrib;\n");
        h += "    vec3 emissive = emissiveColor;\n\n";
        h += "    gl_FragColor.rgb  = ambient;\n";
        if (j || b.lightMap)
            h += "    gl_FragColor.rgb += diffuse;\n";
        j && (h += "    gl_FragColor.rgb += specular;\n");
        h += "    gl_FragColor.rgb += emissive;\n";
        h += "    gl_FragColor.a    = opacity;\n\n";
        h += m("fs_clamp");
        b.fog && (h += m("fs_fog"));
        return h += m("common_main_end")
    }};
pc.gfx.programlib.pick = {generateKey: function(b) {
        var a = "pick";
        b.skin && (a += "_skin");
        return a
    },generateVertexShader: function(b) {
        var a = pc.gfx.programlib.getSnippet, c = "", c = b.skin ? c + a("vs_skin_position_decl") : c + a("vs_static_position_decl"), c = c + a("common_main_begin"), c = b.skin ? c + a("vs_skin_position") : c + a("vs_static_position");
        return c += a("common_main_end")
    },generateFragmentShader: function() {
        var b = pc.gfx.programlib.getSnippet, a = b("fs_precision"), a = a + b("fs_flat_color_decl"), a = a + b("common_main_begin"), a = a + b("fs_flat_color");
        return a += b("common_main_end")
    }};
pc.gfx.programlib.skybox = {generateKey: function() {
        return "skybox"
    },generateVertexShader: function() {
        var b = pc.gfx.programlib.getSnippet, a;
        a = "attribute vec3 vertex_position;\nuniform mat4 matrix_projection;\n";
        a += "uniform mat4 matrix_view;\n";
        a += "uniform mat4 matrix_model;\n";
        a += "varying vec3 vViewDir;\n\n";
        a += b("common_main_begin");
        a += "    mat4 viewMat = matrix_view;\n";
        a += "    viewMat[3][0] = viewMat[3][1] = viewMat[3][2] = 0.0;\n";
        a += "    mat4 matrix_viewProjection = matrix_projection * viewMat;\n";
        a += b("vs_static_position");
        a += "    vViewDir = vertex_position;\n";
        return a += b("common_main_end")
    },generateFragmentShader: function() {
        var b = pc.gfx.programlib.getSnippet, a = b("fs_precision"), a = a + "varying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\n\n", a = a + b("common_main_begin"), a = a + "    gl_FragColor = textureCube(texture_cubeMap, normalize(vViewDir));\n";
        return a += b("common_main_end")
    }};
pc.scene = {BLEND_SUBTRACTIVE: 0,BLEND_ADDITIVE: 1,BLEND_NORMAL: 2,BLEND_NONE: 3,RENDERSTYLE_SOLID: 0,RENDERSTYLE_WIREFRAME: 1,RENDERSTYLE_POINTS: 2,LAYER_HUD: 0,LAYER_GIZMO: 1,LAYER_FX: 2,LAYER_WORLD: 3,LAYER_SKYBOX: 4};
pc.extend(pc.scene, function() {
    function b(a, b) {
        return b.key - a.key
    }
    function a(a, b) {
        var d = a.getNearClip(), c = a.getFarClip(), e = a.getFov() * Math.PI / 180, g = a.getAspectRatio(), f = a.getProjection(), j, k;
        k = f === pc.scene.Projection.PERSPECTIVE ? Math.tan(e / 2) * d : this._orthoHeight;
        j = k * g;
        b[0][0] = j;
        b[0][1] = -k;
        b[0][2] = -d;
        b[1][0] = j;
        b[1][1] = k;
        b[1][2] = -d;
        b[2][0] = -j;
        b[2][1] = k;
        b[2][2] = -d;
        b[3][0] = -j;
        b[3][1] = -k;
        b[3][2] = -d;
        f === pc.scene.Projection.PERSPECTIVE && (k = Math.tan(e / 2) * c, j = k * g);
        b[4][0] = j;
        b[4][1] = -k;
        b[4][2] = -c;
        b[5][0] = j;
        b[5][1] = k;
        b[5][2] = -c;
        b[6][0] = -j;
        b[6][1] = k;
        b[6][2] = -c;
        b[7][0] = -j;
        b[7][1] = -k;
        b[7][2] = -c;
        return b
    }
    var c = pc.math.mat4.makeScale(0.5, 0.5, 0.5), d = pc.math.mat4.makeTranslate(0.5, 0.5, 0.5), e = pc.math.mat4.multiply(d, c), g = pc.math.mat4.makeRotate(-90, [1, 0, 0]), f = pc.math.mat4.create(), j = pc.math.mat4.create(), k = pc.math.mat4.create(), l = [];
    for (i = 0; 8 > i; i++)
        l.push(pc.math.vec3.create());
    c = function() {
        this.drawCalls = [];
        this.meshInstances = [];
        this.shadowCasters = [];
        var a = pc.gfx.Device.getCurrent();
        this.modelMatrixId = a.scope.resolve("matrix_model");
        this.poseMatrixId = a.scope.resolve("matrix_pose[0]");
        this._models = [];
        this._lights = [];
        this._globalAmbient = pc.math.vec3.create(0, 0, 0);
        this._globalLights = [];
        this._localLights = [[], []];
        a = a.getProgramLibrary();
        this._depthProgStatic = a.getProgram("depth", {skin: !1,opacityMap: !1});
        this._depthProgSkin = a.getProgram("depth", {skin: !0,opacityMap: !1});
        this._depthProgStaticOp = a.getProgram("depth", {skin: !1,opacityMap: !0});
        this._depthProgSkinOp = a.getProgram("depth", {skin: !0,opacityMap: !0});
        this._shadowState = {blend: !1};
        this._shadowAabb = new pc.shape.Aabb;
        this._sceneAabb = new pc.shape.Aabb
    };
    c.prototype.getModels = function() {
        return this._models
    };
    c.prototype.addModel = function(a) {
        if (-1 === this._models.indexOf(a)) {
            this._models.push(a);
            for (var b, d = a.meshInstances.length, c = 0; c < d; c++)
                b = a.meshInstances[c], -1 === this.drawCalls.indexOf(b) && this.drawCalls.push(b), -1 === this.meshInstances.indexOf(b) && this.meshInstances.push(b), b.castShadow && -1 === this.shadowCasters.indexOf(b) && this.shadowCasters.push(b);
            a = a.getLights();
            c = 0;
            for (b = a.length; c < 
            b; c++)
                this.addLight(a[c])
        }
    };
    c.prototype.removeModel = function(a) {
        var b = this._models.indexOf(a);
        if (-1 !== b) {
            this._models.splice(b, 1);
            for (var d, c = a.meshInstances.length, e = 0; e < c; e++)
                d = a.meshInstances[e], b = this.drawCalls.indexOf(d), -1 !== b && this.drawCalls.splice(b, 1), b = this.meshInstances.indexOf(d), -1 !== b && this.meshInstances.splice(b, 1), d.castShadow && (b = this.shadowCasters.indexOf(d), -1 !== b && this.shadowCasters.splice(b, 1));
            a = a.getLights();
            e = 0;
            for (b = a.length; e < b; e++)
                this.removeLight(a[e])
        }
    };
    c.prototype.containsModel = 
    function(a) {
        return 0 <= this._models.indexOf(a)
    };
    c.prototype.addLight = function(a) {
        this._lights.push(a)
    };
    c.prototype.removeLight = function(a) {
        a = this._lights.indexOf(a);
        -1 !== a && this._lights.splice(a, 1)
    };
    c.prototype.update = function() {
        for (var a = 0, b = this._models.length; a < b; a++)
            this._models[a].getGraph().syncHierarchy()
    };
    c.prototype.render = function(d) {
        pc.scene.Scene.current = this;
        this._globalLights.length = 0;
        this._localLights[0].length = 0;
        this._localLights[1].length = 0;
        var c = this._lights, n = 0;
        for (len = c.length; n < 
        len; n++) {
            var r = c[n];
            r.getCastShadows();
            r.getEnabled() && (r.getType() === pc.scene.LightType.DIRECTIONAL ? r.getCastShadows() ? this._globalLights.push(r) : this._globalLights.unshift(r) : this._localLights[r.getType() === pc.scene.LightType.POINT ? 0 : 1].push(r))
        }
        var n, s, v = pc.gfx.Device.getCurrent(), u, x, w, G = null;
        for (n = this._models.length - 1; 0 <= n; n--) {
            var y = this._models[n].skinInstances;
            for (s = y.length - 1; 0 <= s; s--)
                y[s].updateMatrixPalette()
        }
        for (n = 0; n < c.length; n++)
            if (r = c[n], s = r.getType(), s !== pc.scene.LightType.POINT && 
            r.getCastShadows() && r.getEnabled()) {
                y = r._shadowCamera;
                if (s === pc.scene.LightType.DIRECTIONAL) {
                    s = d.getFrustumCentroid();
                    y.setPosition(s);
                    x = pc.math.mat4.getY(r.worldTransform);
                    y.translate(x[0], x[1], x[2]);
                    y.lookAt(s);
                    pc.math.mat4.copy(y.getWorldTransform(), f);
                    a(d, l);
                    s = pc.math.mat4.invert(f);
                    x = pc.math.mat4.multiply(s, d.worldTransform);
                    for (s = 0; 8 > s; s++)
                        pc.math.mat4.multiplyVec3(l[s], 1, x, l[s]);
                    x = 1E6;
                    w = -1E6;
                    u = 1E6;
                    var z = -1E6, A = 1E6, B = -1E6;
                    for (s = 0; 8 > s; s++) {
                        var C = l[s];
                        C[0] < x && (x = C[0]);
                        C[0] > w && (w = C[0]);
                        C[1] < u && 
                        (u = C[1]);
                        C[1] > z && (z = C[1]);
                        C[2] < A && (A = C[2]);
                        C[2] > B && (B = C[2])
                    }
                    y.translateLocal(0.5 * -(w + x), 0.5 * (z + u), B + 0.25 * (B - A));
                    pc.math.mat4.copy(y.getWorldTransform(), f);
                    y.setProjection(pc.scene.Projection.ORTHOGRAPHIC);
                    y.setNearClip(0);
                    y.setFarClip(1.5 * (B - A));
                    y.setAspectRatio((w - x) / (z - u));
                    y.setOrthoHeight(0.5 * (z - u))
                } else
                    s === pc.scene.LightType.SPOT && (y.setProjection(pc.scene.Projection.PERSPECTIVE), y.setNearClip(r.getAttenuationEnd() / 1E3), y.setFarClip(r.getAttenuationEnd()), y.setAspectRatio(1), y.setFov(2 * r.getOuterConeAngle()), 
                    pc.math.mat4.multiply(r.worldTransform, g, f));
                pc.math.mat4.invert(f, j);
                pc.math.mat4.multiply(y.getProjectionMatrix(), j, k);
                pc.math.mat4.multiply(e, k, r._shadowMatrix);
                pc.math.mat4.copy(f, y.worldTransform);
                y.frameBegin();
                v.extDepthTexture && v.gl.colorMask(!1, !1, !1, !1);
                v.updateLocalState(this._shadowState);
                s = 0;
                for (r = this.shadowCasters.length; s < r; s++)
                    u = this.shadowCasters[s], x = u.mesh, w = u.material, this.modelMatrixId.setValue(u.node.worldTransform), w.opacityMap && v.scope.resolve("texture_opacityMap").setValue(w.opacityMap), 
                    u.skinInstance ? (this.poseMatrixId.setValue(u.skinInstance.matrixPaletteF32), v.setProgram(w.opacityMap ? this._depthProgSkinOp : this._depthProgSkin)) : v.setProgram(w.opacityMap ? this._depthProgStaticOp : this._depthProgStatic), u = u.renderStyle, v.setVertexBuffer(x.vertexBuffer, 0), v.setIndexBuffer(x.indexBuffer[u]), v.draw(x.primitive[u]);
                v.clearLocalState();
                v.extDepthTexture && v.gl.colorMask(!0, !0, !0, !0);
                y.frameEnd()
            }
        this.drawCalls.sort(b);
        d.frameBegin();
        this.dispatchGlobalLights();
        this.dispatchLocalLights();
        n = 0;
        for (numDrawCalls = this.drawCalls.length; n < numDrawCalls; n++)
            c = this.drawCalls[n], c.command ? c.command() : (u = c, x = u.mesh, w = u.material, this.modelMatrixId.setValue(u.node.worldTransform), u.skinInstance && this.poseMatrixId.setValue(u.skinInstance.matrixPaletteF32), w !== G && (v.setProgram(w.getProgram(x)), w.setParameters(), v.clearLocalState(), v.updateLocalState(w.getState())), u = u.renderStyle, v.setVertexBuffer(x.vertexBuffer, 0), v.setIndexBuffer(x.indexBuffer[u]), v.draw(x.primitive[u]), G = w);
        v.clearLocalState();
        d.frameEnd()
    };
    c.prototype.getGlobalAmbient = function() {
        return this._globalAmbient
    };
    c.prototype.setGlobalAmbient = function() {
        3 === arguments.length ? pc.math.vec3.set(this._globalAmbient, arguments[0], arguments[1], arguments[2]) : pc.math.vec3.copy(arguments[0], this._globalAmbient)
    };
    c.prototype.dispatchGlobalLights = function() {
        var a = this._globalLights, b = a.length, d = pc.gfx.Device.getCurrent(), c = d.scope;
        c.resolve("light_globalAmbient").setValue(this._globalAmbient);
        for (var e = 0; e < b; e++) {
            var g = a[e], f = g.getWorldTransform();
            light = "light" + e;
            c.resolve(light + "_color").setValue(g._finalColor);
            g._direction[0] = -f[4];
            g._direction[1] = -f[5];
            g._direction[2] = -f[6];
            c.resolve(light + "_direction").setValue(g._direction);
            g.getCastShadows() && (f = d.extDepthTexture ? g._shadowCamera._renderTarget._frameBuffer._depthTexture : g._shadowCamera._renderTarget._frameBuffer.getTexture(), c.resolve(light + "_shadowMap").setValue(f), c.resolve(light + "_shadowMatrix").setValue(g._shadowMatrix), c.resolve(light + "_shadowParams").setValue([g._shadowWidth, g._shadowHeight, 
                g._shadowBias]))
        }
    };
    c.prototype.dispatchLocalLights = function() {
        var a, b, d, c;
        a = this._localLights;
        c = a[pc.scene.LightType.POINT - 1];
        var e = a[pc.scene.LightType.SPOT - 1], g = this._globalLights.length, f = c.length, j = e.length, k = pc.gfx.Device.getCurrent(), l = k.scope;
        for (a = 0; a < f; a++)
            d = c[a], b = d.getWorldTransform(), light = "light" + (g + a), l.resolve(light + "_radius").setValue(d._attenuationEnd), l.resolve(light + "_color").setValue(d._finalColor), d._position[0] = b[12], d._position[1] = b[13], d._position[2] = b[14], l.resolve(light + 
            "_position").setValue(d._position);
        for (a = 0; a < j; a++)
            c = e[a], b = c.getWorldTransform(), light = "light" + (g + f + a), l.resolve(light + "_innerConeAngle").setValue(c._innerConeAngleCos), l.resolve(light + "_outerConeAngle").setValue(c._outerConeAngleCos), l.resolve(light + "_radius").setValue(c._attenuationEnd), l.resolve(light + "_color").setValue(c._finalColor), c._position[0] = b[12], c._position[1] = b[13], c._position[2] = b[14], l.resolve(light + "_position").setValue(c._position), c._direction[0] = -b[4], c._direction[1] = -b[5], c._direction[2] = 
            -b[6], l.resolve(light + "_spotDirection").setValue(c._direction), c.getCastShadows() && (b = k.extDepthTexture ? c._shadowCamera._renderTarget._frameBuffer._depthTexture : c._shadowCamera._renderTarget._frameBuffer.getTexture(), l.resolve(light + "_shadowMap").setValue(b), l.resolve(light + "_shadowMatrix").setValue(c._shadowMatrix), l.resolve(light + "_shadowParams").setValue([c._shadowWidth, c._shadowHeight, c._shadowBias]))
    };
    return {Scene: c}
}());
pc.extend(pc.scene, function() {
    var b = pc.math.mat4.create(), a = pc.math.vec3.create(), c = pc.math.quat.create(), d = pc.math.quat.create(), e = [], g = function(a) {
        this._name = a || "";
        this._labels = {};
        this._graphId = -1;
        this.localPosition = pc.math.vec3.create(0, 0, 0);
        this.localRotation = pc.math.quat.create(0, 0, 0, 1);
        this.localScale = pc.math.vec3.create(1, 1, 1);
        this.localEulerAngles = pc.math.vec3.create(0, 0, 0);
        this.position = pc.math.vec3.create(0, 0, 0);
        this.rotation = pc.math.quat.create(0, 0, 0, 1);
        this.eulerAngles = pc.math.vec3.create(0, 
        0, 0);
        this.localTransform = pc.math.mat4.create();
        this.dirtyLocal = !1;
        this.worldTransform = pc.math.mat4.create();
        this.dirtyWorld = !1;
        this._parent = null;
        this._children = []
    };
    g.prototype = {_cloneInternal: function(a) {
            a._name = this._name;
            a._labels = pc.extend(this._lables, {});
            a._graphId = this._graphId;
            pc.math.vec3.copy(this.localPosition, a.localPosition);
            pc.math.quat.copy(this.localRotation, a.localRotation);
            pc.math.vec3.copy(this.localScale, a.localScale);
            pc.math.vec3.copy(this.localEulerAngles, a.localEulerAngles);
            pc.math.vec3.copy(this.position, a.position);
            pc.math.quat.copy(this.rotation, a.rotation);
            pc.math.vec3.copy(this.eulerAngles, a.eulerAngles);
            pc.math.mat4.copy(this.localTransform, a.localTransform);
            a.dirtyLocal = a.dirtyLocal;
            pc.math.mat4.copy(this.worldTransform, a.worldTransform);
            a.dirtyWorld = a.dirtyWorld
        },clone: function() {
            var a = new pc.scene.GraphNode;
            this._cloneInternal(a);
            return a
        },addGraphId: function(a) {
            this._graphId = a
        },removeGraphId: function() {
            delete this._graphId
        },find: function(a, b) {
            var d, c = this.getChildren(), 
            e = c.length, g = [];
            this[a] && (d = this[a] instanceof Function ? this[a]() : this[a], d === b && g.push(this));
            for (d = 0; d < e; ++d)
                g = g.concat(c[d].find(a, b));
            return g
        },findOne: function(a, b) {
            var d, c = this.getChildren(), e = c.length, g = null;
            if (this[a] && (d = this[a] instanceof Function ? this[a]() : this[a], d === b))
                return this;
            for (d = 0; d < e; ++d)
                if (g = c[d].findOne(a, b), null !== g)
                    return g;
            return null
        },findByName: function(a) {
            if (this._name === a)
                return this;
            for (var b = 0; b < this._children.length; b++) {
                var d = this._children[b].findByName(a);
                if (null !== 
                d)
                    return d
            }
            return null
        },findByGraphId: function(a) {
            if (this._graphId === a)
                return this;
            for (var b = 0; b < this._children.length; b++) {
                var d = this._children[b].findByGraphId(a);
                if (null !== d)
                    return d
            }
            return null
        },getRoot: function() {
            var a = this.getParent();
            if (!a)
                return this;
            for (; a.getParent(); )
                a = a.getParent();
            return a
        },getParent: function() {
            return this._parent
        },getChildren: function() {
            return this._children
        },getEulerAngles: function() {
            var a = this.getWorldTransform();
            pc.math.mat4.toEulerXYZ(a, this.eulerAngles);
            return this.eulerAngles
        },
        getLocalEulerAngles: function() {
            pc.math.quat.toEulers(this.localRotation, this.localEulerAngles);
            return this.localEulerAngles
        },getLocalPosition: function() {
            return this.localPosition
        },getLocalRotation: function() {
            return this.localRotation
        },getLocalScale: function() {
            return this.localScale
        },getLocalTransform: function() {
            this.dirtyLocal && (pc.math.mat4.compose(this.localPosition, this.localRotation, this.localScale, this.localTransform), this.dirtyLocal = !1, this.dirtyWorld = !0);
            return this.localTransform
        },getName: function() {
            return this._name
        },
        getPosition: function() {
            var a = this.getWorldTransform();
            pc.math.mat4.getTranslation(a, this.position);
            return this.position
        },getRotation: function() {
            var a = this.getWorldTransform();
            pc.math.mat4.toQuat(a, this.rotation);
            return this.rotation
        },getWorldTransform: function() {
            var a = this;
            for (e.length = 0; null !== a; )
                e.push(a), a = a._parent;
            for (a = e.length - 1; 0 <= a; a--)
                e[a].sync();
            return this.worldTransform
        },setLocalEulerAngles: function() {
            1 === arguments.length ? pc.math.quat.setFromEulers(this.localRotation, arguments[0][0], 
            arguments[0][1], arguments[0][2]) : pc.math.quat.setFromEulers(this.localRotation, arguments[0], arguments[1], arguments[2]);
            this.dirtyLocal = !0
        },setLocalPosition: function() {
            1 === arguments.length ? (this.localPosition[0] = arguments[0][0], this.localPosition[1] = arguments[0][1], this.localPosition[2] = arguments[0][2]) : (this.localPosition[0] = arguments[0], this.localPosition[1] = arguments[1], this.localPosition[2] = arguments[2]);
            this.dirtyLocal = !0
        },setLocalRotation: function(a) {
            pc.math.quat.copy(a, this.localRotation);
            this.dirtyLocal = 
            !0
        },setLocalScale: function() {
            1 === arguments.length ? (this.localScale[0] = arguments[0][0], this.localScale[1] = arguments[0][1], this.localScale[2] = arguments[0][2]) : (this.localScale[0] = arguments[0], this.localScale[1] = arguments[1], this.localScale[2] = arguments[2]);
            this.dirtyLocal = !0
        },setName: function(a) {
            this._name = a
        },setPosition: function() {
            1 === arguments.length ? (a[0] = arguments[0][0], a[1] = arguments[0][1], a[2] = arguments[0][2]) : (a[0] = arguments[0], a[1] = arguments[1], a[2] = arguments[2]);
            if (null === this._parent)
                pc.math.vec3.copy(a, 
                this.localPosition);
            else {
                var d = this._parent.getWorldTransform();
                pc.math.mat4.invert(d, b);
                pc.math.mat4.multiplyVec3(a, 1, b, this.localPosition)
            }
            this.dirtyLocal = !0
        },setRotation: function(a) {
            if (null === this._parent)
                pc.math.quat.copy(a, this.localRotation);
            else {
                var b = this._parent.getRotation();
                pc.math.quat.invert(b, c);
                pc.math.quat.multiply(c, a, this.localRotation)
            }
            this.dirtyLocal = !0
        },setEulerAngles: function() {
            1 === arguments.length ? (a[0] = arguments[0][0], a[1] = arguments[0][1], a[2] = arguments[0][2]) : (a[0] = arguments[0], 
            a[1] = arguments[1], a[2] = arguments[2]);
            pc.math.quat.setFromEulers(this.localRotation, a[0], a[1], a[2]);
            if (null !== this._parent) {
                var b = this._parent.getRotation();
                pc.math.quat.invert(b, c);
                pc.math.quat.multiply(c, this.localRotation, this.localRotation)
            }
            this.dirtyLocal = !0
        },addChild: function(a) {
            if (null != a.getParent())
                throw Error("GraphNode is already parented");
            this._children.push(a);
            a._parent = this;
            a.dirtyWorld = !0
        },removeChild: function(a) {
            var b, d = this._children.length;
            a._parent = null;
            for (b = 0; b < d; ++b)
                if (this._children[b] === 
                a) {
                    this._children.splice(b, 1);
                    break
                }
        },addLabel: function(a) {
            this._labels[a] = !0
        },getLabels: function() {
            return Object.keys(this._labels)
        },hasLabel: function(a) {
            return !!this._labels[a]
        },removeLabel: function(a) {
            delete this._labels[a]
        },findByLabel: function(a, b) {
            var d, c = this._children.length, b = b || [];
            this.hasLabel(a) && b.push(this);
            for (d = 0; d < c; ++d)
                b = this._children[d].findByLabel(a, b);
            return b
        },sync: function() {
            this.dirtyLocal && (pc.math.mat4.compose(this.localPosition, this.localRotation, this.localScale, this.localTransform), 
            this.dirtyLocal = !1, this.dirtyWorld = !0);
            if (this.dirtyWorld) {
                null === this._parent ? pc.math.mat4.copy(this.localTransform, this.worldTransform) : pc.math.mat4.multiply(this._parent.worldTransform, this.localTransform, this.worldTransform);
                this.dirtyWorld = !1;
                for (var a = 0, b = this._children.length; a < b; a++)
                    this._children[a].dirtyWorld = !0
            }
        },syncHierarchy: function() {
            this.sync();
            for (var a = 0, b = this._children.length; a < b; a++)
                this._children[a].syncHierarchy()
        },lookAt: function() {
            var b, d;
            switch (arguments.length) {
                case 1:
                    b = 
                    arguments[0];
                    d = pc.math.vec3.yaxis;
                    break;
                case 2:
                    b = arguments[0];
                    d = arguments[1];
                    break;
                case 3:
                    b = a, b[0] = arguments[0], b[1] = arguments[1], b[2] = arguments[2], d = pc.math.vec3.yaxis
            }
            b = pc.math.mat4.makeLookAt(this.localPosition, b, d);
            pc.math.mat4.toQuat(b, this.localRotation);
            this.dirtyLocal = !0
        },translate: function() {
            var a = 0, b = 0, d = 0;
            switch (arguments.length) {
                case 1:
                    a = arguments[0][0];
                    b = arguments[0][1];
                    d = arguments[0][2];
                    break;
                case 3:
                    a = arguments[0], b = arguments[1], d = arguments[2]
            }
            var c = this.getPosition();
            this.setPosition(c[0] + 
            a, c[1] + b, c[2] + d)
        },translateLocal: function() {
            switch (arguments.length) {
                case 1:
                    a[0] = arguments[0][0];
                    a[1] = arguments[0][1];
                    a[2] = arguments[0][2];
                    break;
                case 3:
                    a[0] = arguments[0], a[1] = arguments[1], a[2] = arguments[2]
            }
            pc.math.quat.transformVector(this.getLocalRotation(), a, a);
            pc.math.vec3.add(this.localPosition, a, this.localPosition);
            this.dirtyLocal = !0
        },rotate: function() {
            var a, b, e;
            3 === arguments.length ? (a = arguments[0], b = arguments[1], e = arguments[2]) : (a = arguments[0][0], b = arguments[0][1], e = arguments[0][2]);
            pc.math.quat.setFromEulers(c, 
            a, b, e);
            null === this._parent ? pc.math.quat.multiply(c, this.localRotation, this.localRotation) : (a = this.getRotation(), b = this._parent.getRotation(), pc.math.quat.invert(b, d), pc.math.quat.multiply(d, c, c), pc.math.quat.multiply(c, a, this.localRotation));
            this.dirtyLocal = !0
        },rotateLocal: function() {
            var a, b, d;
            3 === arguments.length ? (a = arguments[0], b = arguments[1], d = arguments[2]) : (a = arguments[0][0], b = arguments[0][1], d = arguments[0][2]);
            pc.math.quat.setFromEulers(c, a, b, d);
            pc.math.quat.multiply(this.localRotation, c, this.localRotation);
            this.dirtyLocal = !0
        }};
    return {GraphNode: g}
}());
pc.scene.Projection = {PERSPECTIVE: 0,ORTHOGRAPHIC: 1};
pc.extend(pc.scene, function() {
    var b = pc.math.vec3, a = pc.math.mat4, c = function() {
        this._projection = pc.scene.Projection.PERSPECTIVE;
        this._nearClip = 0.1;
        this._farClip = 1E4;
        this._fov = 45;
        this._orthoHeight = 10;
        this._aspect = 16 / 9;
        this._upNode = this._lookAtNode = null;
        var d = pc.gfx.Device.getCurrent().scope;
        this._projId = d.resolve("matrix_projection");
        this._viewId = d.resolve("matrix_view");
        this._viewInvId = d.resolve("matrix_viewInverse");
        this._viewProjId = d.resolve("matrix_viewProjection");
        this._viewPosId = d.resolve("view_position");
        this._nearClipId = d.resolve("camera_near");
        this._farClipId = d.resolve("camera_far");
        this._projMatDirty = !0;
        this._projMat = a.create();
        this._viewMat = a.create();
        this._viewProjMat = a.create();
        this._viewPosition = b.create(0, 0, 0);
        this._frustum = new pc.shape.Frustum(this._projMat, this._viewMat);
        this._renderTarget = new pc.gfx.RenderTarget(pc.gfx.FrameBuffer.getBackBuffer());
        this._clearOptions = {color: [186 / 255, 186 / 255, 177 / 255, 1],depth: 1,flags: pc.gfx.CLEARFLAG_COLOR | pc.gfx.CLEARFLAG_DEPTH}
    }, c = pc.inherits(c, pc.scene.GraphNode);
    c.prototype._cloneInternal = function(a) {
        c._super._cloneInternal.call(this, a);
        a.setProjection(this.getProjection());
        a.setNearClip(this.getNearClip());
        a.setFarClip(this.getFarClip());
        a.setFov(this.getFov());
        a.setAspectRatio(this.getAspectRatio());
        a.setLookAtNode(this.getLookAtNode());
        a.setUpNode(this.getUpNode());
        a.setRenderTarget(this.getRenderTarget());
        a.setClearOptions(this.getClearOptions())
    };
    c.prototype.clone = function() {
        var a = new pc.scene.CameraNode;
        this._cloneInternal(a);
        return a
    };
    c.prototype.getFrustumCentroid = 
    function() {
        var a = pc.math.vec3.create(0, 0, 0.5 * -(this._farClip + this._nearClip));
        pc.math.mat4.multiplyVec3(a, 1, this.getWorldTransform(), a);
        return a
    };
    c.prototype.worldToScreen = function(a) {
        var b, c = this.getWorldTransform(), f = pc.math.mat4.invert(c), j = pc.math.mat4.create(), c = this._renderTarget.getWidth(), k = this._renderTarget.getHeight(), l = Vector4.create();
        b = pc.math.mat4.makePerspective(this._fov, c / k, this._nearClip, this._farClip);
        pc.math.mat4.multiply(b, f, j);
        pc.math.mat4.multiplyVec3(a, 1, j, l);
        a = l[3] || 1;
        l[0] = 
        c / 2 + c / 2 * l[0] / a;
        l[1] = k - (k / 2 + k / 2 * l[1] / a);
        l[2] /= a;
        return l
    };
    c.prototype.screenToWorld = function(d, c, g, f) {
        "undefined" === typeof f && (f = b.create());
        var j = this.getProjectionMatrix(), k = this.getWorldTransform();
        a.invert(k, this._viewMat);
        a.multiply(j, this._viewMat, this._viewProjMat);
        var j = a.invert(this._viewProjMat), l = pc.gfx.Device.getCurrent(), k = parseFloat(l.canvas.style.width), l = parseFloat(l.canvas.style.height), c = b.create(2 * (d / k) - 1, 2 * ((l - c) / l) - 1, 1), d = a.multiplyVec3(c, 1, j);
        b.scale(d, 1 / (c[0] * j[3] + c[1] * j[7] + 
        c[2] * j[11] + j[15]), d);
        c = this.getPosition();
        g /= this._farClip;
        f[0] = c[0] + g * (d[0] - c[0]);
        f[1] = c[1] + g * (d[1] - c[1]);
        f[2] = c[2] + g * (d[2] - c[2]);
        return f
    };
    c.prototype.frameBegin = function(b) {
        var b = void 0 === b ? !0 : b, c = pc.gfx.Device.getCurrent();
        c.setRenderTarget(this._renderTarget);
        c.updateBegin();
        b && c.clear(this._clearOptions);
        b = this.getWorldTransform();
        if (null !== this._lookAtNode) {
            b = pc.math.mat4.getTranslation(b);
            c = pc.math.mat4.getTranslation(this._lookAtNode.getWorldTransform());
            if (null !== this._upNode) {
                var g = pc.math.mat4.getTranslation(this._upNode.getWorldTransform()), 
                f = pc.math.vec3.create();
                pc.math.vec3.subtract(g, b, f);
                pc.math.vec3.normalize(f, f)
            } else
                f = pc.math.vec3.create(0, 1, 0);
            b = pc.math.mat4.makeLookAt(b, c, f)
        }
        c = this.getProjectionMatrix();
        this._projId.setValue(c);
        a.invert(b, this._viewMat);
        this._viewId.setValue(this._viewMat);
        a.multiply(c, this._viewMat, this._viewProjMat);
        this._viewProjId.setValue(this._viewProjMat);
        this._viewInvId.setValue(b);
        this._viewPosition[0] = b[12];
        this._viewPosition[1] = b[13];
        this._viewPosition[2] = b[14];
        this._viewPosId.setValue(this._viewPosition);
        this._nearClipId.setValue(this._nearClip);
        this._farClipId.setValue(this._farClip);
        this._frustum.update(c, this._viewMat)
    };
    c.prototype.frameEnd = function() {
        pc.gfx.Device.getCurrent().updateEnd()
    };
    c.prototype.getAspectRatio = function() {
        return this._aspect
    };
    c.prototype.getClearOptions = function() {
        return this._clearOptions
    };
    c.prototype.getFarClip = function() {
        return this._farClip
    };
    c.prototype.getFov = function() {
        return this._fov
    };
    c.prototype.getFrustum = function() {
        return this._frustum
    };
    c.prototype.getNearClip = 
    function() {
        return this._nearClip
    };
    c.prototype.getOrthoHeight = function() {
        return this._orthoHeight
    };
    c.prototype.getProjection = function() {
        return this._projection
    };
    c.prototype.getProjectionMatrix = function() {
        if (this._projMatDirty) {
            if (this._projection === pc.scene.Projection.PERSPECTIVE)
                a.makePerspective(this._fov, this._aspect, this._nearClip, this._farClip, this._projMat);
            else {
                var b = this._orthoHeight, c = b * this._aspect;
                a.makeOrtho(-c, c, -b, b, this._nearClip, this._farClip, this._projMat)
            }
            this._projMatDirty = !1
        }
        return this._projMat
    };
    c.prototype.getRenderTarget = function() {
        return this._renderTarget
    };
    c.prototype.setAspectRatio = function(a) {
        this._aspect = a;
        this._projMatDirty = !0
    };
    c.prototype.setClearOptions = function(a) {
        this._clearOptions = a
    };
    c.prototype.setFarClip = function(a) {
        this._farClip = a;
        this._projMatDirty = !0
    };
    c.prototype.setFov = function(a) {
        this._fov = a;
        this._projMatDirty = !0
    };
    c.prototype.setNearClip = function(a) {
        this._nearClip = a;
        this._projMatDirty = !0
    };
    c.prototype.setOrthoHeight = function(a) {
        this._orthoHeight = a
    };
    c.prototype.setProjection = 
    function(a) {
        this._projection = a;
        this._projMatDirty = !0
    };
    c.prototype.setRenderTarget = function(a) {
        this._renderTarget = a;
        this._projMatDirty = !0
    };
    c.prototype.setLookAtNode = function(a) {
        this._lookAtNode = a
    };
    c.prototype.getLookAtNode = function() {
        return this._lookAtNode
    };
    c.prototype.setUpNode = function(a) {
        this._upNode = a
    };
    c.prototype.getUpNode = function() {
        return this._upNode
    };
    return {CameraNode: c}
}());
pc.scene.LightType = {DIRECTIONAL: 0,POINT: 1,SPOT: 2};
pc.extend(pc.scene, function() {
    var b = function() {
        this._type = pc.scene.LightType.DIRECTIONAL;
        this._color = pc.math.vec3.create(0.8, 0.8, 0.8);
        this._intensity = 1;
        this._enabled = this._castShadows = !1;
        this._attenuationEnd = this._attenuationStart = 10;
        this._innerConeAngle = 40;
        this._outerConeAngle = 45;
        this._finalColor = pc.math.vec3.create(0.8, 0.8, 0.8);
        this._position = [];
        this._direction = [];
        this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
        this._outerConeAngleCos = Math.cos(this._outerConeAngle * Math.PI / 180);
        this._shadowCamera = null;
        this._shadowMatrix = pc.math.mat4.create();
        this._shadowHeight = this._shadowWidth = 1024;
        this._shadowBias = -5E-4
    }, b = pc.inherits(b, pc.scene.GraphNode);
    b.prototype._cloneInternal = function(a) {
        b._super._cloneInternal.call(this, a);
        a.setType(this.getType());
        a.setColor(pc.math.vec3.clone(this.getColor()));
        a.setIntensity(this.getIntensity());
        a.setCastShadows(this.getCastShadows());
        a.setEnabled(this.getEnabled());
        a.setAttenuationStart(this.getAttenuationStart());
        a.setAttenuationEnd(this.getAttenuationEnd());
        a.setInnerConeAngle(this.getInnerConeAngle());
        a.setOuterConeAngle(this.getOuterConeAngle())
    };
    b.prototype.clone = function() {
        var a = new pc.scene.LightNode;
        this._cloneInternal(a);
        return a
    };
    b.prototype.getAttenuationEnd = function() {
        return this._attenuationEnd
    };
    b.prototype.getAttenuationStart = function() {
        return this._attenuationStart
    };
    b.prototype.getCastShadows = function() {
        return this._castShadows
    };
    b.prototype.getColor = function() {
        return this._color
    };
    b.prototype.getEnabled = function() {
        return this._enabled
    };
    b.prototype.getInnerConeAngle = 
    function() {
        return this._innerConeAngle
    };
    b.prototype.getIntensity = function() {
        return this._intensity
    };
    b.prototype.getOuterConeAngle = function() {
        return this._outerConeAngle
    };
    b.prototype.getType = function() {
        return this._type
    };
    b.prototype.setAttenuationEnd = function(a) {
        this._attenuationEnd = a
    };
    b.prototype.setAttenuationStart = function(a) {
        this._attenuationStart = a
    };
    b.prototype._createShadowMap = function() {
        var a = new pc.gfx.FrameBuffer(this._shadowWidth, this._shadowHeight, !0), b = a.getTexture();
        b.minFilter = pc.gfx.FILTER_NEAREST;
        b.magFilter = pc.gfx.FILTER_NEAREST;
        b.addressU = pc.gfx.ADDRESS_CLAMP_TO_EDGE;
        b.addressV = pc.gfx.ADDRESS_CLAMP_TO_EDGE;
        return a
    };
    b.prototype._createShadowCamera = function() {
        if (!this._shadowCamera) {
            var a = this._createShadowMap(), b = pc.gfx.Device.getCurrent().extDepthTexture ? pc.gfx.CLEARFLAG_DEPTH : pc.gfx.CLEARFLAG_COLOR | pc.gfx.CLEARFLAG_DEPTH, d = new pc.scene.CameraNode;
            d.setRenderTarget(new pc.gfx.RenderTarget(a));
            d.setClearOptions({color: [1, 1, 1, 1],depth: 1,flags: b});
            return d
        }
    };
    b.prototype.setShadowBias = function(a) {
        this._shadowBias = 
        a
    };
    b.prototype.setShadowResolution = function(a, b) {
        if (a !== this._shadowWidth && b !== this._shadowHeight && (this._shadowWidth = a, this._shadowHeight = b, this._shadowCamera)) {
            var d = this._createShadowMap();
            this._shadowCamera.setRenderTarget(new pc.gfx.RenderTarget(d))
        }
    };
    b.prototype.setCastShadows = function(a) {
        this._shadowCamera = (this._castShadows = a) && this._type !== pc.scene.LightType.POINT ? this._createShadowCamera() : null
    };
    b.prototype.setColor = function() {
        1 === arguments.length ? pc.math.vec3.set(this._color, arguments[0][0], 
        arguments[0][1], arguments[0][2]) : 3 === arguments.length && pc.math.vec3.set(this._color, arguments[0], arguments[1], arguments[2]);
        pc.math.vec3.scale(this._color, this._intensity, this._finalColor)
    };
    b.prototype.setEnabled = function(a) {
        this._enabled = a
    };
    b.prototype.setInnerConeAngle = function(a) {
        this._innerConeAngle = a;
        this._innerConeAngleCos = Math.cos(a * Math.PI / 180)
    };
    b.prototype.setIntensity = function(a) {
        this._intensity = a;
        pc.math.vec3.scale(this._color, a, this._finalColor)
    };
    b.prototype.setOuterConeAngle = function(a) {
        this._outerConeAngle = 
        a;
        this._outerConeAngleCos = Math.cos(a * Math.PI / 180)
    };
    b.prototype.setType = function(a) {
        this._type !== a && (this._type = a, this._castShadows && a !== pc.scene.LightType.POINT && (this._shadowCamera = this._createShadowCamera()))
    };
    return {LightNode: b}
}());
pc.extend(pc.scene, function() {
    var b = 0, a = function() {
        this.name = null;
        this.id = b++;
        this._parameters = {};
        this._state = {};
        this._program = null;
        this._programs = {};
        this.blendType = pc.scene.BLEND_NONE
    };
    Object.defineProperty(a.prototype, "blendType", {get: function() {
            return this._state.blendModes ? this._state.blendModes.srcBlend === pc.gfx.BLENDMODE_ONE && this._state.blendModes.dstBlend === pc.gfx.BLENDMODE_ZERO ? pc.scene.BLEND_NONE : this._state.blendModes.srcBlend === pc.gfx.BLENDMODE_SRC_ALPHA && this._state.blendModes.dstBlend === 
            pc.gfx.BLENDMODE_ONE_MINUS_SRC_ALPHA ? pc.scene.BLEND_NORMAL : this._state.blendModes.srcBlend === pc.gfx.BLENDMODE_ONE && this._state.blendModes.dstBlend === pc.gfx.BLENDMODE_ONE ? pc.scene.BLEND_ADDITIVE : pc.scene.BLEND_NORMAL : pc.scene.BLEND_NONE
        },set: function(a) {
            switch (a) {
                case pc.scene.BLEND_NONE:
                    this._state.blend = !1;
                    this._state.blendModes = {srcBlend: pc.gfx.BLENDMODE_ONE,dstBlend: pc.gfx.BLENDMODE_ZERO};
                    break;
                case pc.scene.BLEND_NORMAL:
                    this._state.blend = !0;
                    this._state.blendModes = {srcBlend: pc.gfx.BLENDMODE_SRC_ALPHA,
                        dstBlend: pc.gfx.BLENDMODE_ONE_MINUS_SRC_ALPHA};
                    break;
                case pc.scene.BLEND_ADDITIVE:
                    this._state.blend = !0, this._state.blendModes = {srcBlend: pc.gfx.BLENDMODE_ONE,dstBlend: pc.gfx.BLENDMODE_ONE}
            }
        }});
    a.prototype.getName = function() {
        return this.name
    };
    a.prototype.setName = function(a) {
        this.name = a
    };
    a.prototype.clearParameters = function() {
        this._parameters = {};
        this._programs = {}
    };
    a.prototype.getParameters = function() {
        return this._parameters
    };
    a.prototype.getParameter = function(a) {
        return this._parameters[a]
    };
    a.prototype.setParameter = 
    function(a, b) {
        var e = pc.gfx.Device.getCurrent(), g = this._parameters[a];
        g ? g._data = b : (this._parameters[a] = {_scopeId: e.scope.resolve(a),_data: b}, this._programs = {})
    };
    a.prototype.deleteParameter = function(a) {
        this._parameters[a] && (delete this._parameters[a], this._programs = {})
    };
    a.prototype.setParameters = function() {
        for (var a in this._parameters) {
            var b = this._parameters[a];
            b._scopeId.setValue(b._data)
        }
    };
    a.prototype.getProgram = function() {
        return this._program
    };
    a.prototype.setProgram = function(a) {
        this._program = a
    };
    a.prototype.getState = function() {
        return this._state
    };
    a.prototype.setState = function(a) {
        this._state = a
    };
    return {Material: a}
}());
pc.extend(pc.scene, function() {
    var b;
    b = pc.inherits(function() {
        this.color = pc.math.vec4.create(1, 1, 1, 1);
        this.colorMap = null;
        this.update()
    }, pc.scene.Material);
    b.prototype.update = function() {
        this.clearParameters();
        this.setParameter("uColor", this.color);
        this.colorMap && this.setParameter("texture_diffuseMap", this.colorMap);
        this.transparent = 1 > this.color[3];
        this.colorMap && this.colorMap.format === pc.gfx.PIXELFORMAT_R8_G8_B8_A8 && (this.transparent = !0)
    };
    b.prototype.getProgram = function() {
        var a = this._programs["static"];
        if (a)
            return a;
        a = pc.gfx.Device.getCurrent().getProgramLibrary().getProgram("basic", {skin: !1});
        return this._programs["static"] = a
    };
    return {BasicMaterial: b}
}());
pc.extend(pc.scene, function() {
    var b;
    b = pc.inherits(function() {
    }, pc.scene.Material);
    b.prototype.getProgram = function(a) {
        var b = a.getGeometry().isSkinned() ? "skin" : "static", d = this._programs[b];
        if (d)
            return d;
        d = pc.gfx.Device.getCurrent();
        a = {skin: a.getGeometry().isSkinned()};
        d = d.getProgramLibrary().getProgram("depth", a);
        return this._programs[b] = d
    };
    return {DepthMaterial: b}
}());
pc.extend(pc.scene, function() {
    var b;
    b = pc.inherits(function() {
        this.ambient = pc.math.vec3.create(0.7, 0.7, 0.7);
        this.diffuse = pc.math.vec3.create(0.7, 0.7, 0.7);
        this.diffuseMapTransform = this.diffuseMap = null;
        this.specular = pc.math.vec3.create(0, 0, 0);
        this.specularMapTransform = this.specularMap = null;
        this.shininess = 25;
        this.glossMapTransform = this.glossMap = null;
        this.emissive = pc.math.vec3.create(0, 0, 0);
        this.emissiveMapTransform = this.emissiveMap = null;
        this.opacity = 1;
        this.heightMapTransform = this.heightMap = this.normalMapTransform = 
        this.normalMap = this.opacityMapTransform = this.opacityMap = null;
        this.bumpMapFactor = 1;
        this.reflectionMap = null;
        this.reflectivity = 1;
        this.lightMap = null;
        this.update()
    }, pc.scene.Material);
    b.prototype.update = function() {
        this.clearParameters();
        this.setParameter("material_ambient", this.ambient);
        this.diffuseMap ? (this.setParameter("texture_diffuseMap", this.diffuseMap), this.diffuseMapTransform && this.setParameter("texture_diffuseMapTransform", this.diffuseMapTransform)) : this.setParameter("material_diffuse", this.diffuse);
        this.specularMap ? (this.setParameter("texture_specularMap", this.specularMap), this.specularMapTransform && this.setParameter("texture_specularMapTransform", this.specularMapTransform)) : this.setParameter("material_specular", this.specular);
        this.glossMap ? (this.setParameter("texture_glossMap", this.glossMap), this.glossMapTransform && this.setParameter("texture_glossMapTransform", this.glossMapTransform)) : this.setParameter("material_shininess", this.shininess);
        this.emissiveMap ? (this.setParameter("texture_emissiveMap", 
        this.emissiveMap), this.emissiveMapTransform && this.setParameter("texture_emissiveMapTransform", this.emissiveMapTransform)) : this.setParameter("material_emissive", this.emissive);
        this.opacityMap ? (this.setParameter("texture_opacityMap", this.opacityMap), this.opacityMapTransform && this.setParameter("texture_opacityMapTransform", this.opacityMapTransform)) : this.setParameter("material_opacity", this.opacity);
        this.normalMap && (this.setParameter("texture_normalMap", this.normalMap), this.normalMapTransform && this.setParameter("texture_normalMapTransform", 
        this.normalMapTransform));
        this.heightMap && (this.setParameter("texture_heightMap", this.heightMap), this.heightMapTransform && this.setParameter("texture_heightMapTransform", this.heightMapTransform));
        (this.normalMap || this.heightMap) && this.setParameter("material_bumpMapFactor", this.bumpMapFactor);
        this.reflectionMap && (this.reflectionMap._cubemap ? this.setParameter("texture_cubeMap", this.reflectionMap) : this.setParameter("texture_sphereMap", this.reflectionMap), this.setParameter("material_reflectionFactor", 
        this.reflectivity));
        this.lightMap && this.setParameter("texture_lightMap", this.lightMap)
    };
    b.prototype.getProgram = function(a) {
        var b = pc.scene.Scene.current, d, e = 0, g = 0, f = 0, j = 0, k = 0, l = 0;
        if (b) {
            for (d = 0; d < b._globalLights.length; d++)
                b._globalLights[d].getCastShadows() ? j++ : e++;
            for (d = 0; d < b._localLights[0].length; d++)
                b._localLights[0][d].getCastShadows() ? k++ : g++;
            for (d = 0; d < b._localLights[1].length; d++)
                b._localLights[1][d].getCastShadows() ? l++ : f++
        }
        d = null !== a.skin;
        var a = pc.gfx.Device.getCurrent(), m = a.getCurrentState(), 
        b = "";
        d && (b += "skin_");
        m.fog && (b += "fog_");
        m.alphaTest && (b += "atst_");
        var b = b + (e + "dir_" + g + "pnt_" + f + "spt" + j + "sdir_" + k + "spnt_" + l + "sspt"), h = this._programs[b];
        if (h)
            return h;
        h = this.getParameters();
        e = {alphaTest: m.alphaTest,fog: m.fog,skin: d,numDirs: e,numSDirs: j,numPnts: g,numSPnts: k,numSpts: f,numSSpts: l,diffuseMap: void 0 !== h.texture_diffuseMap,diffuseMapTransform: void 0 !== h.texture_diffuseMapTransform,specularMap: void 0 !== h.texture_specularMap,specularMapTransform: void 0 !== h.texture_specularMapTransform,specularFactorMap: void 0 !== 
            h.texture_specularFactorMap,specularFactorMapTransform: void 0 !== h.texture_specularFactorMapTransform,glossMap: void 0 !== h.texture_glossMap,glossMapTransform: void 0 !== h.texture_glossMapTransform,emissiveMap: void 0 !== h.texture_emissiveMap,emissiveMapTransform: void 0 !== h.texture_emissiveMapTransform,opacityMap: void 0 !== h.texture_opacityMap,opacityMapTransform: void 0 !== h.texture_opacityMapTransform,normalMap: void 0 !== h.texture_normalMap,normalMapTransform: void 0 !== h.texture_normalMapTransform,heightMap: void 0 !== 
            h.texture_heightMap,heightMapTransform: void 0 !== h.texture_heightMapTransform,sphereMap: void 0 !== h.texture_sphereMap,cubeMap: void 0 !== h.texture_cubeMap,lightMap: void 0 !== h.texture_lightMap};
        h = a.getProgramLibrary().getProgram("phong", e);
        return this._programs[b] = h
    };
    return {PhongMaterial: b}
}());
pc.extend(pc.scene, function() {
    var b;
    b = pc.inherits(function() {
        this.color = pc.math.vec4.create(0, 0, 0, 1);
        this.update()
    }, pc.scene.Material);
    b.prototype.update = function() {
        this.clearParameters();
        this.setParameter("uColor", this.color);
        this.transparent = !1
    };
    b.prototype.getProgram = function(a) {
        var b = a.getGeometry().isSkinned() ? "skin" : "static", d = this._programs[b];
        if (d)
            return d;
        d = pc.gfx.Device.getCurrent();
        a = {skin: a.getGeometry().isSkinned()};
        d = d.getProgramLibrary().getProgram("pick", a);
        return this._programs[b] = 
        d
    };
    return {PickMaterial: b}
}());
pc.extend(pc.scene, function() {
    var b = function(a, b, d) {
        this.node = a;
        this.mesh = b;
        this.material = d;
        this.layer = pc.scene.LAYER_WORLD;
        this.renderStyle = pc.scene.RENDERSTYLE_SOLID;
        this.castShadow = !1;
        this.receiveShadow = !0;
        this.key = 0;
        this.updateKey();
        this.skinInstance = null;
        this.aabb = new pc.shape.Aabb
    };
    b.prototype = {syncAabb: function() {
            this.aabb.setFromTransformedAabb(this.mesh.aabb, this.node.worldTransform)
        },updateKey: function() {
            var a = this.material;
            this.key = (this.layer & 7) << 28 | (a.blendType & 3) << 26 | 0 | (a.id & 33554431) << 
            0
        }};
    return {Command: function(a, b, d) {
            this.key = (a & 7) << 28 | (b & 3) << 26 | 33554432;
            this.command = d
        },Mesh: function() {
            this.vertexBuffer = null;
            this.indexBuffer = [null];
            this.primitive = [{type: 0,base: 0,count: 0}];
            this.aabb = this.skin = null
        },MeshInstance: b}
}());
pc.extend(pc.scene, function() {
    var b = function(a) {
        this.skin = a;
        this.bones = [];
        a = a.inverseBindPose.length;
        this.matrixPalette = new ArrayBuffer(64 * a);
        this.matrixPaletteF32 = new Float32Array(this.matrixPalette);
        this.matrixPaletteEntryF32 = [];
        for (var b = 0; b < a; b++)
            this.matrixPaletteEntryF32[b] = new Float32Array(this.matrixPalette, 64 * b, 16)
    };
    b.prototype = {updateMatrixPalette: function() {
            for (var a = this.bones.length - 1; 0 <= a; a--)
                pc.math.mat4.multiply(this.bones[a].worldTransform, this.skin.inverseBindPose[a], this.matrixPaletteEntryF32[a])
        }};
    return {Skin: function(a, b) {
            this.inverseBindPose = a;
            this.boneNames = b
        },SkinInstance: b}
}());
pc.extend(pc.scene, function() {
    function b() {
        this.vertexData = [];
        this.boneWeights = [];
        this.boneIndices = []
    }
    function a() {
        this.indexCount = this.indexStart = this.vertexCount = this.vertexStart = this.partition = 0;
        this.boneIndices = [];
        this.vertices = [];
        this.indices = [];
        this.indexMap = {}
    }
    a.prototype = {addVertex: function(a, b) {
            var e = -1;
            if (void 0 !== this.indexMap[b])
                e = this.indexMap[b], this.indices.push(e);
            else {
                for (e = 0; 4 > e; e++)
                    0 !== a.boneWeights[e] && (a.boneIndices[e] = this.getBoneRemap(a.boneIndices[e]));
                e = this.vertices.length;
                this.indices.push(e);
                this.vertices.push(a);
                this.indexMap[b] = e
            }
        },addPrimitive: function(a, b, e) {
            for (var g = [], f = 0, j = a.length, k = 0; k < j; k++)
                for (var l = 0; 4 > l; l++)
                    if (0 < a[k].boneWeights[l]) {
                        for (var m = a[k].boneIndices[l], h = !0, n = 0; n < f; n++)
                            if (g[n] == m) {
                                h = !1;
                                break
                            }
                        h && (g[f] = m, m = this.getBoneRemap(m), f += -1 === m ? 1 : 0)
                    }
            if (this.boneIndices.length + f > e)
                return !1;
            for (k = 0; k < f; k++)
                this.boneIndices.push(g[k]);
            for (k = 0; k < j; k++)
                this.addVertex(a[k], b[k]);
            return !0
        },getBoneRemap: function(a) {
            for (var b = 0; b < this.boneIndices.length; b++)
                if (this.boneIndices[b] === 
                a)
                    return b;
            return -1
        }};
    return {partitionSkin: function(c, d, e, g, f) {
            for (var j = [], k = [], l = [], m = function(a) {
                for (var c = new b, e = 0; e < d.length; e++) {
                    var g = d[e].lock(), f = d[e].getFormat(), j = f.size;
                    c.vertexData.push(g.slice(a * j, a * j + j));
                    for (g = 0; g < f.elements.length; g++)
                        "vertex_boneIndices" === f.elements[g].scopeId.name && (c.boneIndices = new Uint8Array(c.vertexData[e], f.elements[g].offset, 4)), "vertex_boneWeights" === f.elements[g].scopeId.name && (c.boneWeights = new Float32Array(c.vertexData[e], f.elements[g].offset, 4))
                }
                return c
            }, 
            h = 0, n = new Uint16Array(e.lock()), r = 0; r < g.length; r++) {
                for (var s = g[r], v = s.primitive[0], u = v.base; u < v.base + v.count; ) {
                    e = n[u++];
                    k[0] = m(e);
                    l[0] = e;
                    e = n[u++];
                    k[1] = m(e);
                    l[1] = e;
                    e = n[u++];
                    k[2] = m(e);
                    l[2] = e;
                    for (var x = !1, w = h; w < j.length; w++)
                        if (e = j[w], e.addPrimitive(k, l, c)) {
                            x = !0;
                            break
                        }
                    x || (e = new a, e.material = s._material, e.addPrimitive(k, l, c), j.push(e))
                }
                h = j.length
            }
            l = [];
            s = [];
            for (c = 0; c < j.length; c++)
                if (e = j[c], e.vertices.length && e.indices.length) {
                    r = l.length;
                    k = e.vertices.length;
                    m = s.length;
                    h = e.indices.length;
                    e.partition = c;
                    e.vertexStart = 
                    r;
                    e.vertexCount = k;
                    e.indexStart = m;
                    e.indexCount = h;
                    n = 0;
                    for (v = r; n < k; )
                        l[v++] = e.vertices[n++];
                    n = 0;
                    for (v = m; n < h; )
                        s[v++] = e.indices[n++] + r
                }
            k = [];
            for (r = 0; r < d.length; r++) {
                e = new pc.gfx.VertexBuffer(d[r].getFormat(), l.length);
                c = e.lock();
                c = new Uint8Array(c);
                for (m = 0; m < l.length; m++)
                    c.set(new Uint8Array(l[m].vertexData[r]), m * e.getFormat().size);
                e.unlock();
                k.push(e)
            }
            r = [];
            for (c = 0; c < j.length; c++)
                e = j[c], r = r.concat(s.splice(0, e.indexCount));
            l = new pc.gfx.IndexBuffer(pc.gfx.INDEXFORMAT_UINT16, r.length);
            (new Uint16Array(l.lock())).set(r);
            l.unlock();
            m = [];
            for (c = h = 0; c < j.length; c++) {
                e = j[c];
                s = [];
                n = [];
                for (r = 0; r < e.boneIndices.length; r++)
                    s.push(f.inverseBindPose[e.boneIndices[r]]), n.push(f.boneNames[e.boneIndices[r]]);
                r = new pc.scene.Skin(s, n);
                s = new pc.scene.Mesh;
                s.vertexBuffer = k[0];
                s.indexBuffer[0] = l;
                s.primitive[0].type = pc.gfx.PRIMITIVE_TRIANGLES;
                s.primitive[0].base = h;
                s.primitive[0].count = e.indexCount;
                s.primitive[0].indexed = !0;
                s.skin = r;
                s.aabb = g[0].aabb;
                s._material = e.material;
                m.push(s);
                h += e.indexCount
            }
            return m
        }}
}());
pc.extend(pc.scene, function() {
    var b = function() {
        this.textures = [];
        this.materials = [];
        this.skins = [];
        this.skinInstances = [];
        this.meshInstances = [];
        this.cameras = [];
        this.lights = [];
        this.graph = null
    };
    b.prototype.getGraph = function() {
        return this.graph
    };
    b.prototype.setGraph = function(a) {
        this.graph = a
    };
    b.prototype.getCameras = function() {
        return this.cameras
    };
    b.prototype.setCameras = function(a) {
        this.cameras = a
    };
    b.prototype.getLights = function() {
        return this.lights
    };
    b.prototype.setLights = function(a) {
        this.lights = a
    };
    b.prototype.getTextures = 
    function() {
        return this.textures
    };
    b.prototype.setTextures = function(a) {
        this.textures = a
    };
    b.prototype.getMaterials = function() {
        return this.materials
    };
    b.prototype.setMaterials = function(a) {
        this.materials = a
    };
    b.prototype.clone = function() {
        var a = new pc.scene.Model;
        a.textures = this.textures.slice(0);
        a.materials = this.materials.slice(0);
        a.skins = this.skins.slice(0);
        for (var b = 0; b < a.skins.length; b++)
            a.skinInstances.push(new pc.scene.SkinInstance(a.skins[b]));
        var d = [], e = [], g = function(b) {
            var c = b.clone();
            d.push(b);
            e.push(c);
            b instanceof pc.scene.CameraNode ? a.cameras.push(c) : b instanceof pc.scene.LightNode && a.lights.push(c);
            for (var b = b.getChildren(), f = 0; f < b.length; f++)
                c.addChild(g(b[f]));
            return c
        };
        a.graph = g(this.graph);
        for (b = 0; b < this.meshInstances.length; b++) {
            var f = this.meshInstances[b], j = d.indexOf(f.node), j = new pc.scene.MeshInstance(e[j], f.mesh, f.material);
            a.meshInstances.push(j);
            f.skinInstance && (f = this.skinInstances.indexOf(f.skinInstance), j.skinInstance = a.skinInstances[f])
        }
        a.resolveBoneNames();
        a.getGraph().syncHierarchy();
        f = a.meshInstances;
        for (b = 0; b < f.length; b++)
            f[b].syncAabb();
        return a
    };
    b.prototype.resolveBoneNames = function() {
        var a, b, d = this.skins, e = this.skinInstances, g = this.getGraph();
        for (a = 0; a < d.length; a++) {
            var f = d[a], j = e[a];
            j.bones = [];
            for (b = 0; b < f.boneNames.length; b++) {
                var k = g.findByName(f.boneNames[b]);
                j.bones.push(k)
            }
        }
    };
    b.prototype.generateWireframe = function() {
        var a, b, d, e, g, f, j, k, l, m, h = [];
        for (a = 0; a < this.meshInstances.length; a++)
            f = this.meshInstances[a].mesh, -1 === h.indexOf(f) && h.push(f);
        var n = [[0, 1], [1, 2], [2, 0]];
        for (a = 0; a < h.length; a++) {
            f = h[a];
            j = f.primitive[pc.scene.RENDERSTYLE_SOLID].base;
            k = f.primitive[pc.scene.RENDERSTYLE_SOLID].count;
            l = f.indexBuffer[pc.scene.RENDERSTYLE_SOLID];
            m = new Uint16Array(l.lock());
            var r = {}, s = [];
            for (b = j; b < j + k; b += 3)
                for (d = 0; 3 > d; d++) {
                    e = m[b + n[d][0]];
                    g = m[b + n[d][1]];
                    var v = e > g ? g << 16 | e : e << 16 | g;
                    void 0 === r[v] && (r[v] = 0, s.push(e, g))
                }
            l.unlock();
            b = new pc.gfx.IndexBuffer(pc.gfx.INDEXFORMAT_UINT16, s.length);
            d = new Uint16Array(b.lock());
            d.set(s);
            b.unlock();
            f.primitive[pc.scene.RENDERSTYLE_WIREFRAME] = 
            {type: pc.gfx.PRIMITIVE_LINES,base: 0,count: s.length,indexed: !0};
            f.indexBuffer[pc.scene.RENDERSTYLE_WIREFRAME] = b
        }
    };
    return {Model: b}
}());
pc.extend(pc.scene, function() {
    var b = function(a, b) {
        var d = pc.gfx.Device.getCurrent().getProgramLibrary();
        this.pickProgStatic = d.getProgram("pick", {skin: !1});
        this.pickProgSkin = d.getProgram("pick", {skin: !0});
        this.pickColor = new Float32Array(4);
        this.scene = null;
        this._clearOptions = {color: [1, 1, 1, 1],depth: 1,flags: pc.gfx.CLEARFLAG_COLOR | pc.gfx.CLEARFLAG_DEPTH};
        this.setDimensions(a, b)
    };
    b.prototype.getHeight = function() {
        return this._height
    };
    b.prototype.getPickBuffer = function() {
        return this._pickBufferTarget.getFrameBuffer()
    };
    b.prototype.getSelection = function(a) {
        a.width = a.width || 1;
        a.height = a.height || 1;
        this._pickBufferTarget.bind();
        var b = new ArrayBuffer(4 * a.width * a.height), d = new Uint8Array(b), e = pc.gfx.Device.getCurrent().gl;
        e.readPixels(a.x, a.y, a.width, a.height, e.RGBA, e.UNSIGNED_BYTE, d);
        d = [];
        for (e = 0; e < a.width * a.height; e++) {
            var g = new Uint8Array(b, 4 * e, 4), g = g[0] << 16 | g[1] << 8 | g[2];
            16777215 !== g && (g = this.scene.meshInstances[g], -1 === d.indexOf(g) && d.push(g))
        }
        return d
    };
    b.prototype.getWidth = function() {
        return this._width
    };
    b.prototype.prepare = 
    function(a, b) {
        this.scene = b;
        var d = a.getRenderTarget(), e = a.getClearOptions();
        a.setRenderTarget(this._pickBufferTarget);
        a.setClearOptions(this._clearOptions);
        a.frameBegin();
        var g, f, j, k = b.meshInstances, l = k.length, m = pc.gfx.Device.getCurrent(), h = m.scope.resolve("matrix_model"), n = m.scope.resolve("matrix_pose[0]"), r = m.scope.resolve("uColor");
        for (g = 0; g < l; g++)
            j = k[g], f = j.mesh, h.setValue(j.node.worldTransform), j.skinInstance && n.setValue(j.skinInstance.matrixPaletteF32), this.pickColor[0] = (g >> 16 & 255) / 255, this.pickColor[1] = 
            (g >> 8 & 255) / 255, this.pickColor[2] = (g & 255) / 255, this.pickColor[3] = 1, r.setValue(this.pickColor), m.setProgram(f.skin ? this.pickProgSkin : this.pickProgStatic), m.setVertexBuffer(f.vertexBuffer, 0), m.setIndexBuffer(f.indexBuffer[pc.scene.RENDERSTYLE_SOLID]), m.draw(f.primitive[pc.scene.RENDERSTYLE_SOLID]);
        a.frameEnd();
        a.setRenderTarget(d);
        a.setClearOptions(e)
    };
    b.prototype.setDimensions = function(a, b) {
        this._width = a;
        this._height = b;
        var d = new pc.gfx.FrameBuffer(this._width, this._height, !0), e = d.getTexture();
        e.minFilter = 
        pc.gfx.FILTER_NEAREST;
        e.magFilter = pc.gfx.FILTER_NEAREST;
        e.addressU = pc.gfx.ADDRESS_CLAMP_TO_EDGE;
        e.addressV = pc.gfx.ADDRESS_CLAMP_TO_EDGE;
        this._pickBufferTarget = new pc.gfx.RenderTarget(d)
    };
    return {Picker: b}
}());
pc.scene.procedural = {};
pc.scene.procedural.calculateTangents = function(b, a, c, d) {
    var e = d.length / 3, g = b.length / 3, f, j, k, l, m, h, n, r, s, v, u, x, w, G, y, z, A, B, C, M, H = pc.math.vec3.create(0, 0, 0), I = pc.math.vec3.create(0, 0, 0);
    l = pc.math.vec3.create(0, 0, 0);
    m = pc.math.vec3.create(0, 0, 0);
    h = pc.math.vec3.create(0, 0, 0);
    n = pc.math.vec2.create(0, 0);
    r = pc.math.vec2.create(0, 0);
    s = pc.math.vec2.create(0, 0);
    var D, E = new Float32Array(3 * g), F = new Float32Array(3 * g), N = [];
    for (D = 0; D < e; D++)
        f = d[3 * D], j = d[3 * D + 1], k = d[3 * D + 2], pc.math.vec3.set(l, b[3 * f], b[3 * f + 1], b[3 * f + 2]), 
        pc.math.vec3.set(m, b[3 * j], b[3 * j + 1], b[3 * j + 2]), pc.math.vec3.set(h, b[3 * k], b[3 * k + 1], b[3 * k + 2]), pc.math.vec2.set(n, c[2 * f], c[2 * f + 1]), pc.math.vec2.set(r, c[2 * j], c[2 * j + 1]), pc.math.vec2.set(s, c[2 * k], c[2 * k + 1]), v = m[0] - l[0], u = h[0] - l[0], x = m[1] - l[1], w = h[1] - l[1], G = m[2] - l[2], y = h[2] - l[2], z = r[0] - n[0], A = s[0] - n[0], B = r[1] - n[1], C = s[1] - n[1], M = 1 / (z * C - A * B), pc.math.vec3.set(H, (C * v - B * u) * M, (C * x - B * w) * M, (C * G - B * y) * M), pc.math.vec3.set(I, (z * u - A * v) * M, (z * w - A * x) * M, (z * y - A * G) * M), E[3 * f + 0] += H[0], E[3 * f + 1] += H[1], E[3 * f + 2] += H[2], E[3 * j + 0] += H[0], 
        E[3 * j + 1] += H[1], E[3 * j + 2] += H[2], E[3 * k + 0] += H[0], E[3 * k + 1] += H[1], E[3 * k + 2] += H[2], F[3 * f + 0] += I[0], F[3 * f + 1] += I[1], F[3 * f + 2] += I[2], F[3 * j + 0] += I[0], F[3 * j + 1] += I[1], F[3 * j + 2] += I[2], F[3 * k + 0] += I[0], F[3 * k + 1] += I[1], F[3 * k + 2] += I[2];
    b = pc.math.vec3.create(0, 0, 0);
    B = pc.math.vec3.create(0, 0, 0);
    C = pc.math.vec3.create(0, 0, 0);
    c = pc.math.vec3.create(0, 0, 0);
    for (D = 0; D < g; D++)
        pc.math.vec3.set(b, a[3 * D], a[3 * D + 1], a[3 * D + 2]), pc.math.vec3.set(B, E[3 * D], E[3 * D + 1], E[3 * D + 2]), pc.math.vec3.set(C, F[3 * D], F[3 * D + 1], F[3 * D + 2]), d = pc.math.vec3.dot(b, B), 
        pc.math.vec3.scale(b, d, c), pc.math.vec3.subtract(B, c, c), pc.math.vec3.normalize(c, c), N[4 * D] = c[0], N[4 * D + 1] = c[1], N[4 * D + 2] = c[2], pc.math.vec3.cross(b, B, c), N[4 * D + 3] = 0 > pc.math.vec3.dot(c, C) ? -1 : 1;
    return N
};
pc.scene.procedural.createMesh = function(b, a) {
    var c = a && void 0 !== a.normals ? a.normals : null, d = a && void 0 !== a.tangents ? a.tangents : null, e = a && void 0 !== a.uvs ? a.uvs : null, g = a && void 0 !== a.indices ? a.indices : null, f = new pc.gfx.VertexFormat;
    f.begin();
    f.addElement(new pc.gfx.VertexElement("vertex_position", 3, pc.gfx.VertexElementType.FLOAT32));
    null !== c && f.addElement(new pc.gfx.VertexElement("vertex_normal", 3, pc.gfx.VertexElementType.FLOAT32));
    null !== d && f.addElement(new pc.gfx.VertexElement("vertex_tangent", 4, pc.gfx.VertexElementType.FLOAT32));
    null !== e && f.addElement(new pc.gfx.VertexElement("vertex_texCoord0", 2, pc.gfx.VertexElementType.FLOAT32));
    f.end();
    for (var j = b.length / 3, f = new pc.gfx.VertexBuffer(f, j), k = new pc.gfx.VertexIterator(f), l = 0; l < j; l++)
        k.element.vertex_position.set(b[3 * l], b[3 * l + 1], b[3 * l + 2]), null !== c && k.element.vertex_normal.set(c[3 * l], c[3 * l + 1], c[3 * l + 2]), null !== d && k.element.vertex_tangent.set(d[4 * l], d[4 * l + 1], d[4 * l + 2], d[4 * l + 3]), null !== e && k.element.vertex_texCoord0.set(e[2 * l], e[2 * l + 1]), k.next();
    k.end();
    c = null;
    if (d = null !== g)
        c = new pc.gfx.IndexBuffer(pc.gfx.INDEXFORMAT_UINT16, 
        g.length), (new Uint16Array(c.lock())).set(g), c.unlock();
    e = new pc.shape.Aabb;
    e.compute(b);
    k = new pc.scene.Mesh;
    k.vertexBuffer = f;
    k.indexBuffer[0] = c;
    k.primitive[0].type = pc.gfx.PRIMITIVE_TRIANGLES;
    k.primitive[0].base = 0;
    k.primitive[0].count = d ? g.length : j;
    k.primitive[0].indexed = d;
    k.aabb = e;
    return k
};
pc.scene.procedural.createTorus = function(b) {
    var a = b && void 0 !== b.tubeRadius ? b.tubeRadius : 0.2, c = b && void 0 !== b.ringRadius ? b.ringRadius : 0.3, d = b && void 0 !== b.segments ? b.segments : 30, e = b && void 0 !== b.sides ? b.sides : 20, g, f, j, k, l, m, h, n, r, s, b = [], v = [], u = [], x = [];
    for (g = 0; g <= e; g++)
        for (f = 0; f <= d; f++)
            j = Math.cos(2 * Math.PI * f / d) * (c + a * Math.cos(2 * Math.PI * g / e)), k = Math.sin(2 * Math.PI * g / e) * a, l = Math.sin(2 * Math.PI * f / d) * (c + a * Math.cos(2 * Math.PI * g / e)), m = Math.cos(2 * Math.PI * f / d) * Math.cos(2 * Math.PI * g / e), h = Math.sin(2 * Math.PI * g / e), n = Math.sin(2 * 
            Math.PI * f / d) * Math.cos(2 * Math.PI * g / e), r = g / e, s = 1 - f / d, b.push(j, k, l), v.push(m, h, n), u.push(r, s), g < e && f < d && (j = g * (d + 1) + f, k = (g + 1) * (d + 1) + f, l = g * (d + 1) + (f + 1), m = (g + 1) * (d + 1) + (f + 1), x.push(j, k, l), x.push(k, m, l));
    a = {normals: v,uvs: u,indices: x};
    pc.gfx.Device.getCurrent().precalculatedTangents && (a.tangents = pc.scene.procedural.calculateTangents(b, v, u, x));
    return pc.scene.procedural.createMesh(b, a)
};
pc.scene.procedural._createConeData = function(b, a, c, d, e, g) {
    var f, j, k, l, m, h = pc.math.vec3.create();
    k = pc.math.vec3.create();
    l = pc.math.vec3.create();
    var n, r, s = [], v = [], u = [], x = [], w;
    if (0 < c)
        for (f = 0; f <= d; f++)
            for (j = 0; j <= e; j++)
                theta = 2 * (j / e) * Math.PI - Math.PI, w = Math.sin(theta), r = Math.cos(theta), n = pc.math.vec3.create(w * b, -c / 2, r * b), m = pc.math.vec3.create(w * a, c / 2, r * a), pc.math.vec3.lerp(n, m, f / d, h), pc.math.vec3.subtract(m, n, k), pc.math.vec3.normalize(k, k), r = pc.math.vec3.create(r, 0, -w), pc.math.vec3.cross(r, k, l), pc.math.vec3.normalize(l, 
                l), s.push(h[0], h[1], h[2]), v.push(l[0], l[1], l[2]), u.push(j / e, f / d), f < d && j < e && (r = f * (e + 1) + j, w = f * (e + 1) + (j + 1), m = (f + 1) * (e + 1) + j, n = (f + 1) * (e + 1) + (j + 1), x.push(r, w, m), x.push(w, n, m));
    if (g) {
        b = Math.floor(e / 2);
        c /= 2;
        for (f = 0; f <= b; f++) {
            theta = 0.5 * f * Math.PI / b;
            w = Math.sin(theta);
            r = Math.cos(theta);
            for (h = 0; h <= e; h++)
                phi = 2 * h * Math.PI / e - Math.PI / 2, k = Math.sin(phi), g = Math.cos(phi), g *= w, j = r, k *= w, l = 1 - h / e, m = 1 - f / b, s.push(g * a, j * a + c, k * a), v.push(g, j, k), u.push(l, m)
        }
        n = (d + 1) * (e + 1);
        for (f = 0; f < b; ++f)
            for (h = 0; h < e; ++h)
                r = f * (e + 1) + h, w = r + e + 1, x.push(n + 
                r + 1, n + w, n + r), x.push(n + r + 1, n + w + 1, n + w);
        for (f = 0; f <= b; f++) {
            theta = 0.5 * Math.PI + 0.5 * f * Math.PI / b;
            w = Math.sin(theta);
            r = Math.cos(theta);
            for (h = 0; h <= e; h++)
                phi = 2 * h * Math.PI / e - Math.PI / 2, k = Math.sin(phi), g = Math.cos(phi), g *= w, j = r, k *= w, l = 1 - h / e, m = 1 - f / b, s.push(g * a, j * a - c, k * a), v.push(g, j, k), u.push(l, m)
        }
        n = (d + 1) * (e + 1) + (e + 1) * (b + 1);
        for (f = 0; f < b; ++f)
            for (h = 0; h < e; ++h)
                r = f * (e + 1) + h, w = r + e + 1, x.push(n + r + 1, n + w, n + r), x.push(n + r + 1, n + w + 1, n + w)
    } else {
        n = (d + 1) * (e + 1);
        if (0 < b)
            for (f = 0; f < e; f++)
                theta = 2 * (f / e) * Math.PI, g = Math.sin(theta), j = -c / 2, k = Math.cos(theta), 
                l = 1 - (g + 1) / 2, m = (k + 1) / 2, s.push(g * b, j, k * b), v.push(0, -1, 0), u.push(l, m), 1 < f && x.push(n, n + f, n + f - 1);
        n += e;
        if (0 < a)
            for (f = 0; f < e; f++)
                theta = 2 * (f / e) * Math.PI, g = Math.sin(theta), j = c / 2, k = Math.cos(theta), l = 1 - (g + 1) / 2, m = (k + 1) / 2, s.push(g * a, j, k * a), v.push(0, 1, 0), u.push(l, m), 1 < f && x.push(n, n + f - 1, n + f)
    }
    return {positions: s,normals: v,uvs: u,indices: x}
};
pc.scene.procedural.createCylinder = function(b) {
    var a = b && void 0 !== b.baseRadius ? b.baseRadius : 0.5, b = pc.scene.procedural._createConeData(a, a, b && void 0 !== b.height ? b.height : 1, b && void 0 !== b.heightSegments ? b.heightSegments : 5, b && void 0 !== b.capSegments ? b.capSegments : 18, !1);
    pc.gfx.Device.getCurrent().precalculatedTangents && (b.tangents = pc.scene.procedural.calculateTangents(b.positions, b.normals, b.uvs, b.indices));
    return pc.scene.procedural.createMesh(b.positions, b)
};
pc.scene.procedural.createCapsule = function(b) {
    var a = b && void 0 !== b.radius ? b.radius : 0.3, b = pc.scene.procedural._createConeData(a, a, (b && void 0 !== b.height ? b.height : 1) - 2 * a, b && void 0 !== b.heightSegments ? b.heightSegments : 1, b && void 0 !== b.sides ? b.sides : 10, !0);
    pc.gfx.Device.getCurrent().precalculatedTangents && (b.tangents = pc.scene.procedural.calculateTangents(b.positions, b.normals, b.uvs, b.indices));
    return pc.scene.procedural.createMesh(b.positions, b)
};
pc.scene.procedural.createCone = function(b) {
    b = pc.scene.procedural._createConeData(b && void 0 !== b.baseRadius ? b.baseRadius : 0.5, b && void 0 !== b.peakRadius ? b.peakRadius : 0, b && void 0 !== b.height ? b.height : 1, b && void 0 !== b.heightSegments ? b.heightSegments : 5, b && void 0 !== b.capSegments ? b.capSegments : 18, !1);
    pc.gfx.Device.getCurrent().precalculatedTangents && (b.tangents = pc.scene.procedural.calculateTangents(b.positions, b.normals, b.uvs, b.indices));
    return pc.scene.procedural.createMesh(b.positions, b)
};
pc.scene.procedural.createSphere = function(b) {
    for (var a = b && void 0 !== b.radius ? b.radius : 0.5, c = b && void 0 !== b.latitudeBands ? b.latitudeBands : 16, d = b && void 0 !== b.longitudeBands ? b.longitudeBands : 16, e, g, f, j, k, l, m, h, b = [], n = [], r = [], s = [], v = 0; v <= c; v++) {
        e = v * Math.PI / c;
        g = Math.sin(e);
        f = Math.cos(e);
        for (e = 0; e <= d; e++)
            j = 2 * e * Math.PI / d - Math.PI / 2, k = Math.sin(j), j = Math.cos(j), j *= g, l = f, k *= g, m = 1 - e / d, h = 1 - v / c, b.push(j * a, l * a, k * a), n.push(j, l, k), r.push(m, h)
    }
    for (v = 0; v < c; ++v)
        for (e = 0; e < d; ++e)
            a = v * (d + 1) + e, g = a + d + 1, s.push(a + 1, g, a), s.push(a + 
            1, g + 1, g);
    c = {normals: n,uvs: r,indices: s};
    pc.gfx.Device.getCurrent().precalculatedTangents && (c.tangents = pc.scene.procedural.calculateTangents(b, n, r, s));
    return pc.scene.procedural.createMesh(b, c)
};
pc.scene.procedural.createPlane = function(b) {
    var a = b && void 0 !== b.halfExtents ? b.halfExtents : [0.5, 0.5], c = b && void 0 !== b.widthSegments ? b.widthSegments : 5, d = b && void 0 !== b.lengthSegments ? b.lengthSegments : 5, e, g, f, j, k, l, b = [], m = [], h = [], n = [];
    for (e = 0; e <= c; e++)
        for (g = 0; g <= d; g++)
            f = -a[0] + 2 * a[0] * e / c, j = -(-a[1] + 2 * a[1] * g / d), k = e / c, l = g / d, b.push(f, 0, j), m.push(0, 1, 0), h.push(k, l), e < c && g < d && (n.push(g + e * (c + 1), g + (e + 1) * (c + 1), g + e * (c + 1) + 1), n.push(g + (e + 1) * (c + 1), g + (e + 1) * (c + 1) + 1, g + e * (c + 1) + 1));
    a = {normals: m,uvs: h,indices: n};
    pc.gfx.Device.getCurrent().precalculatedTangents && 
    (a.tangents = pc.scene.procedural.calculateTangents(b, m, h, n));
    return pc.scene.procedural.createMesh(b, a)
};
pc.scene.procedural.createBox = function(b) {
    var a = b && void 0 !== b.halfExtents ? b.halfExtents : [0.5, 0.5, 0.5], c = b && void 0 !== b.widthSegments ? b.widthSegments : 5, d = b && void 0 !== b.lengthSegments ? b.lengthSegments : 5, b = b && void 0 !== b.heightSegments ? b.heightSegments : 5, e = [pc.math.vec3.create(-a[0], -a[1], a[2]), pc.math.vec3.create(a[0], -a[1], a[2]), pc.math.vec3.create(a[0], a[1], a[2]), pc.math.vec3.create(-a[0], a[1], a[2]), pc.math.vec3.create(a[0], -a[1], -a[2]), pc.math.vec3.create(-a[0], -a[1], -a[2]), pc.math.vec3.create(-a[0], 
        a[1], -a[2]), pc.math.vec3.create(a[0], a[1], -a[2])], g = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]], f = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]], j = [], k = [], l = [], m = [], a = function(a, b, d) {
        var c, v, u, x, w = j.length / 3;
        for (u = 0; u <= b; u++)
            for (x = 0; x <= d; x++) {
                c = pc.math.vec3.create();
                v = pc.math.vec3.create();
                var G = pc.math.vec3.create(), y = pc.math.vec3.create();
                pc.math.vec3.lerp(e[g[a][0]], e[g[a][1]], u / b, c);
                pc.math.vec3.lerp(e[g[a][0]], e[g[a][2]], x / d, v);
                pc.math.vec3.subtract(v, e[g[a][0]], G);
                pc.math.vec3.add(c, 
                G, y);
                c = u / b;
                v = x / d;
                j.push(y[0], y[1], y[2]);
                k.push(f[a][0], f[a][1], f[a][2]);
                l.push(c, v);
                u < b && x < d && (m.push(w + x + u * (b + 1), w + x + (u + 1) * (b + 1), w + x + u * (b + 1) + 1), m.push(w + x + (u + 1) * (b + 1), w + x + (u + 1) * (b + 1) + 1, w + x + u * (b + 1) + 1))
            }
    };
    a(0, c, b);
    a(1, c, b);
    a(2, c, d);
    a(3, c, d);
    a(4, d, b);
    a(5, d, b);
    c = {normals: k,uvs: l,indices: m};
    pc.gfx.Device.getCurrent().precalculatedTangents && (c.tangents = pc.scene.procedural.calculateTangents(j, k, l, m));
    return pc.scene.procedural.createMesh(j, c)
};
pc.extend(pc.resources, function() {
    function b(a, b, c, f) {
        this.memory = a;
        this.dataView = "undefined" !== typeof DataView ? new DataView(a) : null;
        this.filePointer = 0;
        this.options = f;
        this.loader = b;
        this.textureCache = c
    }
    var a = function(a) {
        this._textureCache = a;
        this._jsonToPrimitiveType = {points: pc.gfx.PRIMITIVE_POINTS,lines: pc.gfx.PRIMITIVE_LINES,linestrip: pc.gfx.PRIMITIVE_LINE_STRIP,triangles: pc.gfx.PRIMITIVE_TRIANGLES,trianglestrip: pc.gfx.PRIMITIVE_TRIANGLE_STRIP};
        this._jsonToVertexElementType = {int8: pc.gfx.VertexElementType.INT8,
            uint8: pc.gfx.VertexElementType.UINT8,int16: pc.gfx.VertexElementType.INT16,uint16: pc.gfx.VertexElementType.UINT16,int32: pc.gfx.VertexElementType.INT32,uint32: pc.gfx.VertexElementType.UINT32,float32: pc.gfx.VertexElementType.FLOAT32};
        this._jsonToLightType = {directional: pc.scene.LightType.DIRECTIONAL,point: pc.scene.LightType.POINT,spot: pc.scene.LightType.SPOT};
        this._jsonToAddressMode = {repeat: pc.gfx.ADDRESS_REPEAT,clamp: pc.gfx.ADDRESS_CLAMP_TO_EDGE,mirror: pc.gfx.ADDRESS_MIRRORED_REPEAT};
        this._jsonToFilterMode = 
        {nearest: pc.gfx.FILTER_NEAREST,linear: pc.gfx.FILTER_LINEAR,nearest_mip_nearest: pc.gfx.FILTER_NEAREST_MIPMAP_NEAREST,linear_mip_nearest: pc.gfx.FILTER_LINEAR_MIPMAP_NEAREST,nearest_mip_linear: pc.gfx.FILTER_NEAREST_MIPMAP_LINEAR,linear_mip_linear: pc.gfx.FILTER_LINEAR_MIPMAP_LINEAR};
        this._jsonToProjectionType = {perspective: pc.scene.Projection.PERSPECTIVE,orthographic: pc.scene.Projection.ORTHOGRAPHIC}
    }, a = pc.inherits(a, pc.resources.ResourceHandler);
    a.prototype.load = function(a, b, c, f, j) {
        j = j || {};
        j.directory = 
        pc.path.getDirectory(a);
        c = new pc.URI(a);
        c = pc.path.getExtension(c.path);
        j.binary = ".model" === c;
        pc.net.http.get(a, function(a) {
            b(a, j)
        }.bind(this), {cache: !1})
    };
    a.prototype.open = function(a, b) {
        b = b || {};
        b.directory = b.directory || "";
        b.priority = b.priority || 1;
        b.batch = b.batch || null;
        return model = b.binary ? this._loadModelBin(a, b) : this._loadModelJson(a, b)
    };
    a.prototype.clone = function(a) {
        return a.clone()
    };
    a.prototype._setNodeData = function(a, b) {
        a.setName(b.name);
        a.addGraphId(b.uid);
        if (b.transform) {
            var c = pc.math.mat4.getTranslation(b.transform), 
            f = pc.math.mat4.toEulerXYZ(b.transform), j = pc.math.mat4.getScale(b.transform);
            a.setLocalPosition(c);
            a.setLocalEulerAngles(f);
            a.setLocalScale(j)
        } else
            a.setLocalPosition(b.position), a.setLocalEulerAngles(b.rotation), a.setLocalScale(b.scale)
    };
    a.prototype._loadNode = function(a, b, c) {
        a = new pc.scene.GraphNode;
        this._setNodeData(a, c);
        return a
    };
    a.prototype._loadCamera = function(a, b, c) {
        a = new pc.scene.CameraNode;
        this._setNodeData(a, c);
        a.setProjection(this._jsonToProjectionType[c.projection]);
        a.setNearClip(c.nearClip);
        a.setFarClip(c.farClip);
        a.setFov(c.fov);
        a.setClearOptions({color: c.clearColor || [0, 0, 0, 1],depth: 1,flags: pc.gfx.CLEARFLAG_COLOR | pc.gfx.CLEARFLAG_DEPTH});
        c.lookAt && (a._lookAtId = c.lookAt);
        c.up && (a._upId = c.up);
        return a
    };
    a.prototype._loadLight = function(a, b, c) {
        a = new pc.scene.LightNode;
        this._setNodeData(a, c);
        b = this._jsonToLightType[c.light_type];
        switch (b) {
            case pc.scene.LightType.SPOT:
                a.setInnerConeAngle(c.innerConeAngle || 40), a.setOuterConeAngle(c.outerConeAngle || 45);
            case pc.scene.LightType.POINT:
                a.setAttenuationStart(c.start || 
                0), a.setAttenuationEnd(c.end || 1);
            default:
                a.setType(b), a.setEnabled(c.enabled), a.setColor(c.color), a.setIntensity(c.intensity || 1), a.setCastShadows(c.castShadows)
        }
        return a
    };
    a.prototype._loadMesh = function(a, b, c) {
        b = new pc.scene.GraphNode;
        this._setNodeData(b, c);
        for (var c = a.geometries[c.geometry], f = 0; f < c.length; f++) {
            var j = new pc.scene.MeshInstance(b, c[f], c[f]._material);
            if (c[f].skin) {
                var k = a.skins.indexOf(c[f].skin);
                j.skinInstance = a.skinInstances[k]
            }
            a.meshInstances.push(j)
        }
        return b
    };
    a.prototype._loadTexture = 
    function(a, b, c, f) {
        var j = f.directory + "/" + c.uri, k = null;
        this._textureCache && (k = this._textureCache.getTexture(j));
        k || (a = ".png" === pc.path.getExtension(j) ? pc.gfx.PIXELFORMAT_R8_G8_B8_A8 : pc.gfx.PIXELFORMAT_R8_G8_B8, k = new pc.gfx.Texture({format: a}), k.name = c.name, k.addressU = this._jsonToAddressMode[c.addressu], k.addressV = this._jsonToAddressMode[c.addressv], k.magFilter = this._jsonToFilterMode[c.magfilter], k.minFilter = this._jsonToFilterMode[c.minfilter], this._textureCache && this._textureCache.addTexture(j, k), this._loader.request([new pc.resources.ImageRequest(j)], 
        f.priority, function(a) {
            k.setSource(a[j])
        }, function(a) {
            Object.keys(a).forEach(function(b) {
                logERROR(a[b])
            })
        }, function() {
        }, f));
        return k
    };
    a.prototype._loadMaterial = function(a, b, c) {
        b = new pc.scene.PhongMaterial;
        b.name = c.name;
        for (var f = 0; f < c.parameters.length; f++) {
            var j = c.parameters[f];
            switch (j.name) {
                case "material_ambient":
                    b.ambient = pc.math[j.type].clone(j.data);
                    break;
                case "material_diffuse":
                    b.diffuse = pc.math[j.type].clone(j.data);
                    break;
                case "texture_diffuseMap":
                    b.diffuseMap = a.getTextures()[j.data];
                    break;
                case "texture_diffuseMapTransform":
                    b.diffuseMapTransform = pc.math[j.type].clone(j.data);
                    break;
                case "material_specular":
                    b.specular = pc.math[j.type].clone(j.data);
                    break;
                case "texture_specularMap":
                    b.specularMap = a.getTextures()[j.data];
                    break;
                case "texture_specularMapTransform":
                    b.specularMapTransform = pc.math[j.type].clone(j.data);
                    break;
                case "texture_specularFactorMap":
                    b.specularFactorMap = a.getTextures()[j.data];
                    break;
                case "texture_specularFactorMapTransform":
                    b.specularFactorMapTransform = pc.math[j.type].clone(j.data);
                    break;
                case "material_shininess":
                    b.shininess = j.data;
                    break;
                case "texture_glossMap":
                    b.glossMap = a.getTextures()[j.data];
                    break;
                case "texture_glossMapTransform":
                    b.glossMapTransform = pc.math[j.type].clone(j.data);
                    break;
                case "material_emissive":
                    b.emissive = pc.math[j.type].clone(j.data);
                    break;
                case "texture_emissiveMap":
                    b.emissiveMap = a.getTextures()[j.data];
                    break;
                case "texture_emissiveMapTransform":
                    b.emissiveMapTransform = pc.math[j.type].clone(j.data);
                    break;
                case "material_opacity":
                    b.opacity = j.data;
                    1 > b.opacity && 
                    (b.blendType = pc.scene.BLEND_NORMAL);
                    break;
                case "texture_opacityMap":
                    b.opacityMap = a.getTextures()[j.data];
                    b.blendType = pc.scene.BLEND_NORMAL;
                    break;
                case "texture_opacityMapTransform":
                    b.opacityMapTransform = pc.math[j.type].clone(j.data);
                    break;
                case "texture_sphereMap":
                    b.reflectionMap = a.getTextures()[j.data];
                    break;
                case "texture_cubeMap":
                    b.reflectionMap = a.getTextures()[j.data];
                    break;
                case "material_reflectionFactor":
                    b.reflectivity = j.data;
                    break;
                case "texture_normalMap":
                    b.normalMap = a.getTextures()[j.data];
                    break;
                case "texture_normalMapTransform":
                    b.normalMapTransform = pc.math[j.type].clone(j.data);
                    break;
                case "texture_heightMap":
                    b.heightMap = a.getTextures()[j.data];
                    break;
                case "texture_heightMapTransform":
                    b.heightMapTransform = pc.math[j.type].clone(j.data);
                    break;
                case "material_bumpMapFactor":
                    b.bumpMapFactor = j.data;
                    break;
                case "texture_lightMap":
                    b.lightMap = a.getTextures()[j.data]
            }
        }
        b.update();
        return b
    };
    a.prototype._loadSubMesh = function(a, b, c) {
        a = a.getMaterials()[c.material];
        void 0 === a && logERROR("Material " + c.material + 
        " not found in model's material dictionary.");
        return {material: a,primitive: {type: this._jsonToPrimitiveType[c.primitive.type],base: c.primitive.base,count: c.primitive.count,indexed: c.primitive.indexed}}
    };
    a.prototype._loadGeometry = function(a, b, c) {
        var f = pc.gfx.Device.getCurrent();
        if (f.precalculatedTangents) {
            for (var j = null, k = null, l = null, m = null, f = 0; f < c.attributes.length; f++) {
                var h = c.attributes[f];
                "vertex_position" === h.name && (j = h.data);
                "vertex_normal" === h.name && (k = h.data);
                "vertex_tangent" === h.name && (m = h.data);
                "vertex_texCoord0" === h.name && (l = h.data)
            }
            !m && (j && k && l) && (m = pc.scene.procedural.calculateTangents(j, k, l, c.indices.data), c.attributes.push({name: "vertex_tangent",type: "float32",components: 4,data: m}))
        }
        j = new pc.gfx.VertexFormat;
        j.begin();
        for (f = 0; f < c.attributes.length; f++)
            k = c.attributes[f], j.addElement(new pc.gfx.VertexElement(k.name, k.components, this._jsonToVertexElementType[k.type]));
        j.end();
        l = c.attributes[0].data.length / c.attributes[0].components;
        j = new pc.gfx.VertexBuffer(j, l);
        m = new pc.gfx.VertexIterator(j);
        for (f = 0; f < l; f++) {
            for (h = 0; h < c.attributes.length; h++)
                switch (k = c.attributes[h], k.components) {
                    case 1:
                        m.element[k.name].set(k.data[f]);
                        break;
                    case 2:
                        m.element[k.name].set(k.data[2 * f], k.data[2 * f + 1]);
                        break;
                    case 3:
                        m.element[k.name].set(k.data[3 * f], k.data[3 * f + 1], k.data[3 * f + 2]);
                        break;
                    case 4:
                        m.element[k.name].set(k.data[4 * f], k.data[4 * f + 1], k.data[4 * f + 2], k.data[4 * f + 3])
                }
            m.next()
        }
        m.end();
        k = new pc.gfx.IndexBuffer(pc.gfx.INDEXFORMAT_UINT16, c.indices.data.length);
        (new Uint16Array(k.lock())).set(c.indices.data);
        k.unlock();
        var n;
        if (void 0 !== c.inverse_bind_pose) {
            n = [];
            for (f = 0; f < c.inverse_bind_pose.length; f++)
                n[f] = pc.math.mat4.clone(c.inverse_bind_pose[f]);
            n = new pc.scene.Skin(n, c.bone_ids)
        }
        f = c.bbox.min;
        l = c.bbox.max;
        m = new pc.shape.Aabb(pc.math.vec3.create(0.5 * (l[0] + f[0]), 0.5 * (l[1] + f[1]), 0.5 * (l[2] + f[2])), pc.math.vec3.create(0.5 * (l[0] - f[0]), 0.5 * (l[1] - f[1]), 0.5 * (l[2] - f[2])));
        l = [];
        for (f = 0; f < c.submeshes.length; f++) {
            var h = this._loadSubMesh(a, b, c.submeshes[f]), r = new pc.scene.Mesh;
            r.vertexBuffer = j;
            r.indexBuffer[0] = k;
            r.primitive[0].type = 
            h.primitive.type;
            r.primitive[0].base = h.primitive.base;
            r.primitive[0].count = h.primitive.count;
            r.primitive[0].indexed = !0;
            r.skin = n ? n : null;
            r.aabb = m;
            r._material = h.material;
            l.push(r)
        }
        if (void 0 !== c.inverse_bind_pose) {
            f = pc.gfx.Device.getCurrent();
            b = f.getBoneLimit();
            c.inverse_bind_pose.length > b && (l = pc.scene.partitionSkin(b, [j], k, l, n));
            for (f = 0; f < l.length; f++)
                n = l[f].skin, -1 === a.skins.indexOf(n) && (a.skins.push(n), c = new pc.scene.SkinInstance(n), a.skinInstances.push(c))
        }
        return l
    };
    a.prototype._loadModelJson = function(a, 
    b) {
        var c = a.model, f = new pc.scene.Model, j;
        if (c.textures) {
            var k = f.getTextures();
            for (j = 0; j < c.textures.length; j++)
                k.push(this._loadTexture(f, c, c.textures[j], b))
        }
        if (c.materials) {
            k = f.getMaterials();
            for (j = 0; j < c.materials.length; j++)
                k.push(this._loadMaterial(f, c, c.materials[j]))
        }
        f.geometries = [];
        for (j = 0; j < c.geometries.length; j++)
            f.geometries.push(this._loadGeometry(f, c, c.geometries[j]));
        var l = {camera: this._loadCamera.bind(this),light: this._loadLight.bind(this),mesh: this._loadMesh.bind(this),node: this._loadNode.bind(this)}, 
        m = function(a) {
            var b = null, d = l[a.type];
            if (void 0 !== d) {
                if (b = d(f, c, a), b instanceof pc.scene.CameraNode ? f.getCameras().push(b) : b instanceof pc.scene.LightNode && f.getLights().push(b), void 0 !== a.children)
                    for (d = 0; d < a.children.length; d++) {
                        var e = m(a.children[d]);
                        b.addChild(e)
                    }
            } else
                logERROR("Unknown graph node: " + a.type);
            return b
        }.bind(this), h = function(a) {
            if (a instanceof pc.scene.CameraNode) {
                if (a._lookAtId) {
                    var b = f.getGraph().findByGraphId(a._lookAtId);
                    a.setLookAtNode(b);
                    delete a._lookAtId
                }
                a._upId && (b = f.getGraph().findByGraphId(a._upId), 
                a.setUpNode(b), delete a._upId)
            }
            a = a.getChildren();
            for (b = 0; b < a.length; b++)
                h(a[b])
        };
        if (void 0 !== c.graph) {
            k = m(c.graph);
            f.setGraph(k);
            for (j = 0; j < f.skins.length; j++)
                for (var n = f.skins[j], r = 0; r < n.boneNames.length; r++)
                    n.boneNames[r] = k.findByGraphId(n.boneNames[r]).getName();
            f.resolveBoneNames();
            h(k)
        }
        f.getGraph().syncHierarchy();
        k = f.meshInstances;
        for (j = 0; j < k.length; j++)
            k[j].syncAabb();
        return f
    };
    b.prototype = {readF32: function(a) {
            var a = a || 1, b;
            b = 1 === a ? this.dataView ? this.dataView.getFloat32(this.filePointer, !0) : 
            (new Float32Array(this.memory, this.filePointer, 1))[0] : new Float32Array(this.memory, this.filePointer, a);
            this.filePointer += 4 * a;
            return b
        },readU8: function(a) {
            var a = a || 1, b;
            b = 1 === a ? this.dataView ? this.dataView.getUint8(this.filePointer, !0) : (new Uint8Array(this.memory, this.filePointer, 1))[0] : new Uint8Array(this.memory, this.filePointer, a);
            this.filePointer += 1 * a;
            return b
        },readU16: function(a) {
            var a = a || 1, b;
            b = 1 === a ? this.dataView ? this.dataView.getUint16(this.filePointer, !0) : (new Uint16Array(this.memory, this.filePointer, 
            1))[0] : new Uint16Array(this.memory, this.filePointer, a);
            this.filePointer += 2 * a;
            return b
        },readU32: function(a) {
            var a = a || 1, b;
            b = 1 === a ? this.dataView ? this.dataView.getUint32(this.filePointer, !0) : (new Uint32Array(this.memory, this.filePointer, 1))[0] : new Uint32Array(this.memory, this.filePointer, a);
            this.filePointer += 4 * a;
            return b
        },readString: function(a) {
            for (var b = "", c = 0; c < a; c++)
                var f = this.readU8(), b = b + String.fromCharCode(f);
            return b
        },readChunkHeader: function() {
            var a = this.readString(4), b = this.readU32(), c = this.readU32();
            return {magic: a,version: b,length: c}
        },readStringChunk: function() {
            for (var a = this.readChunkHeader(), a = this.readString(a.length); 0 !== this.filePointer % 4; )
                this.filePointer++;
            return a
        },readTextureChunk: function() {
            this.readChunkHeader();
            var a = this.readStringChunk(), b = this.readStringChunk(), c = this.readU8(), f = this.readU8(), j = this.readU8(), k = this.readU8(), l = this.options.directory + "/" + b, m = null;
            this.textureCache && (m = this.textureCache.getTexture(l));
            m || (b = ".png" === pc.path.getExtension(l) ? pc.gfx.PIXELFORMAT_R8_G8_B8_A8 : 
            pc.gfx.PIXELFORMAT_R8_G8_B8, m = new pc.gfx.Texture({format: b}), m.name = a, m.addressU = c, m.addressV = f, m.minFilter = j, m.magFilter = k, this.textureCache && this.textureCache.addTexture(l, m), this.loader.request([new pc.resources.ImageRequest(l)], this.options.priority, function(a) {
                m.setSource(a[l])
            }, function(a) {
                Object.keys(a).forEach(function(b) {
                    logERROR(a[b])
                })
            }, function() {
            }, this.options));
            return m
        },readMaterialParamChunk: function() {
            this.readChunkHeader();
            var a = this.readStringChunk(), b;
            switch (this.readU32()) {
                case pc.gfx.ShaderInputType.BOOL:
                    b = 
                    0 !== this.readU32();
                    break;
                case pc.gfx.ShaderInputType.FLOAT:
                    b = this.readF32();
                    break;
                case pc.gfx.ShaderInputType.INT:
                    b = this.readU32();
                    break;
                case pc.gfx.ShaderInputType.VEC2:
                    b = pc.math.vec2.create();
                    for (var c = 0; 2 > c; c++)
                        b[c] = this.readF32();
                    break;
                case pc.gfx.ShaderInputType.VEC3:
                    b = pc.math.vec3.create();
                    for (c = 0; 3 > c; c++)
                        b[c] = this.readF32();
                    break;
                case pc.gfx.ShaderInputType.VEC4:
                    b = pc.math.vec4.create();
                    for (c = 0; 4 > c; c++)
                        b[c] = this.readF32();
                    break;
                case pc.gfx.ShaderInputType.IVEC2:
                    b = pc.math.vec2.create();
                    for (c = 
                    0; 2 > c; c++)
                        b[c] = this.readU32();
                    break;
                case pc.gfx.ShaderInputType.IVEC3:
                    b = pc.math.vec3.create();
                    for (c = 0; 3 > c; c++)
                        b[c] = this.readU32();
                    break;
                case pc.gfx.ShaderInputType.IVEC4:
                    b = pc.math.vec4.create();
                    for (c = 0; 4 > c; c++)
                        b[c] = this.readU32();
                    break;
                case pc.gfx.ShaderInputType.BVEC2:
                    b = [];
                    for (c = 0; 2 > c; c++)
                        b.push(0 !== this.readU32());
                    break;
                case pc.gfx.ShaderInputType.BVEC3:
                    b = [];
                    for (c = 0; 3 > c; c++)
                        b.push(0 !== this.readU32());
                    break;
                case pc.gfx.ShaderInputType.BVEC4:
                    b = [];
                    for (c = 0; 4 > c; c++)
                        b.push(0 !== this.readU32());
                    break;
                case pc.gfx.ShaderInputType.MAT2:
                    b = 
                    new Float32Array(4);
                    for (c = 0; 4 > c; c++)
                        b[c] = this.readF32();
                    break;
                case pc.gfx.ShaderInputType.MAT3:
                    b = pc.math.mat3.create();
                    for (c = 0; 9 > c; c++)
                        b[c] = this.readF32();
                    break;
                case pc.gfx.ShaderInputType.MAT4:
                    b = pc.math.mat4.create();
                    for (c = 0; 16 > c; c++)
                        b[c] = this.readF32();
                    break;
                case pc.gfx.ShaderInputType.TEXTURE2D:
                case pc.gfx.ShaderInputType.TEXTURECUBE:
                    b = this.model.getTextures()[this.readU32()]
            }
            return {name: a,data: b}
        },readMaterialChunk: function() {
            this.readChunkHeader();
            var a = this.readStringChunk();
            this.readStringChunk();
            var b = this.readU32(), c = new pc.scene.PhongMaterial;
            c.name = a;
            for (a = 0; a < b; a++) {
                var f = this.readMaterialParamChunk();
                switch (f.name) {
                    case "material_ambient":
                        c.ambient = f.data;
                        break;
                    case "material_diffuse":
                        c.diffuse = f.data;
                        break;
                    case "texture_diffuseMap":
                        c.diffuseMap = f.data;
                        break;
                    case "texture_diffuseMapTransform":
                        c.diffuseMapTransform = f.data;
                        break;
                    case "material_specular":
                        c.specular = f.data;
                        break;
                    case "texture_specularMap":
                        c.specularMap = f.data;
                        break;
                    case "texture_specularMapTransform":
                        c.specularMapTransform = 
                        f.data;
                        break;
                    case "texture_specularFactorMap":
                        c.specularFactorMap = f.data;
                        break;
                    case "texture_specularFactorMapTransform":
                        c.specularFactorMapTransform = f.data;
                        break;
                    case "material_shininess":
                        c.shininess = f.data;
                        break;
                    case "texture_glossMap":
                        c.glossMap = f.data;
                        break;
                    case "texture_glossMapTransform":
                        c.glossMapTransform = f.data;
                        break;
                    case "material_emissive":
                        c.emissive = f.data;
                        break;
                    case "texture_emissiveMap":
                        c.emissiveMap = f.data;
                        break;
                    case "texture_emissiveMapTransform":
                        c.emissiveMapTransform = f.data;
                        break;
                    case "material_opacity":
                        c.opacity = f.data;
                        1 > c.opacity && (c.blendType = pc.scene.BLEND_NORMAL);
                        break;
                    case "texture_opacityMap":
                        c.opacityMap = f.data;
                        c.blendType = pc.scene.BLEND_NORMAL;
                        break;
                    case "texture_opacityMapTransform":
                        c.opacityMapTransform = f.data;
                        break;
                    case "texture_sphereMap":
                        c.reflectionMap = f.data;
                        break;
                    case "texture_cubeMap":
                        c.reflectionMap = f.data;
                        break;
                    case "material_reflectionFactor":
                        c.reflectivity = f.data;
                        break;
                    case "texture_normalMap":
                        c.normalMap = f.data;
                        break;
                    case "texture_normalMapTransform":
                        c.normalMapTransform = 
                        f.data;
                        break;
                    case "texture_heightMap":
                        c.heightMap = f.data;
                        break;
                    case "texture_heightMapTransform":
                        c.heightMapTransform = f.data;
                        break;
                    case "material_bumpMapFactor":
                        c.bumpMapFactor = f.data;
                        break;
                    case "texture_lightMap":
                        c.lightMap = f.data
                }
            }
            c.update();
            return c
        },readAabbChunk: function() {
            this.readChunkHeader();
            var a = this.readF32(), b = this.readF32(), c = this.readF32(), f = this.readF32(), j = this.readF32(), k = this.readF32(), l = pc.math.vec3.create(0.5 * (f + a), 0.5 * (j + b), 0.5 * (k + c)), a = pc.math.vec3.create(0.5 * (f - a), 0.5 * (j - b), 
            0.5 * (k - c));
            return new pc.shape.Aabb(l, a)
        },readVertexBufferChunk: function() {
            this.readChunkHeader();
            var a = this.readU32(), b = this.readU32(), c = this.readU32(), f = new pc.gfx.VertexFormat;
            f.begin();
            a & 1 && f.addElement(new pc.gfx.VertexElement("vertex_position", 3, pc.gfx.VertexElementType.FLOAT32));
            a & 2 && f.addElement(new pc.gfx.VertexElement("vertex_normal", 3, pc.gfx.VertexElementType.FLOAT32));
            pc.gfx.Device.getCurrent().precalculatedTangents && a & 1 && (a & 2 && a & 128) && f.addElement(new pc.gfx.VertexElement("vertex_tangent", 
            4, pc.gfx.VertexElementType.FLOAT32));
            a & 16 && f.addElement(new pc.gfx.VertexElement("vertex_color", 4, pc.gfx.VertexElementType.UINT8), !0);
            a & 32 && f.addElement(new pc.gfx.VertexElement("vertex_boneIndices", 4, pc.gfx.VertexElementType.UINT8));
            a & 64 && f.addElement(new pc.gfx.VertexElement("vertex_boneWeights", 4, pc.gfx.VertexElementType.FLOAT32));
            a & 128 && f.addElement(new pc.gfx.VertexElement("vertex_texCoord0", 2, pc.gfx.VertexElementType.FLOAT32));
            a & 256 && f.addElement(new pc.gfx.VertexElement("vertex_texCoord1", 
            2, pc.gfx.VertexElementType.FLOAT32));
            a & 512 && f.addElement(new pc.gfx.VertexElement("vertex_texCoord2", 2, pc.gfx.VertexElementType.FLOAT32));
            a & 1024 && f.addElement(new pc.gfx.VertexElement("vertex_texCoord3", 2, pc.gfx.VertexElementType.FLOAT32));
            a & 2048 && f.addElement(new pc.gfx.VertexElement("vertex_texCoord4", 2, pc.gfx.VertexElementType.FLOAT32));
            a & 4096 && f.addElement(new pc.gfx.VertexElement("vertex_texCoord5", 2, pc.gfx.VertexElementType.FLOAT32));
            a & 8192 && f.addElement(new pc.gfx.VertexElement("vertex_texCoord6", 
            2, pc.gfx.VertexElementType.FLOAT32));
            a & 16384 && f.addElement(new pc.gfx.VertexElement("vertex_texCoord7", 2, pc.gfx.VertexElementType.FLOAT32));
            f.end();
            var f = new pc.gfx.VertexBuffer(f, b), j = f.lock(), j = new Uint8Array(j), b = this.readU8(b * c);
            if (pc.gfx.Device.getCurrent().precalculatedTangents)
                if (0 !== (a & 1) && 0 !== (a & 2) && 0 !== (a & 128)) {
                    var k = 0;
                    a & 1 && (k += 12);
                    a & 2 && (k += 12);
                    var a = c - k, c = b.length / c, l = 0, m = 0, h, n;
                    for (h = 0; h < c; h++) {
                        for (n = 0; n < k; n++)
                            j[m++] = b[l++];
                        for (n = 0; 16 > n; n++)
                            j[m++] = 0;
                        for (n = 0; n < a; n++)
                            j[m++] = b[l++]
                    }
                } else
                    j.set(b);
            else
                j.set(b);
            f.unlock();
            return f
        },readIndexBufferChunk: function() {
            this.readChunkHeader();
            var a = this.readU32(), b = this.readU32(), c = new pc.gfx.IndexBuffer(a, b), f = c.lock();
            a === pc.gfx.INDEXFORMAT_UINT8 ? (a = this.readU8(b), f = new Uint8Array(f)) : (a = this.readU16(b), f = new Uint16Array(f));
            f.set(a);
            for (c.unlock(); 0 !== this.filePointer % 4; )
                this.filePointer++;
            return c
        },readSubMeshesChunk: function() {
            this.readChunkHeader();
            for (var a = this.readU32(), b = [], c = 0; c < a; c++) {
                var f = this.readU16(), j = this.readU8(), k = this.readU8(), 
                l = this.readU32(), m = this.readU32();
                b.push({material: this.model.getMaterials()[f],primitive: {type: j,indexed: 1 === k,base: l,count: m}})
            }
            return b
        },readGeometryChunk: function() {
            this.readChunkHeader();
            var a = this.readAabbChunk(), b = this.readVertexBufferChunk(), c = this.readIndexBufferChunk(), f = this.readSubMeshesChunk(), j = this.readU32(), k = [], l = [];
            if (0 < j) {
                for (var m = 0; m < j; m++) {
                    for (var h = pc.math.mat4.create(), n = 0; 16 > n; n++)
                        h[n] = this.readF32();
                    k.push(h)
                }
                for (m = 0; m < j; m++)
                    h = this.readStringChunk(), l.push(h)
            }
            m = pc.gfx.Device.getCurrent();
            if (m.precalculatedTangents) {
                for (var j = new Uint16Array(c.lock()), h = b.lock(), n = b.getFormat(), m = n.size, r, s, v, u, x = 0; x < n.elements.length; x++) {
                    var w = n.elements[x];
                    "vertex_position" === w.scopeId.name ? r = new Float32Array(h, w.offset) : "vertex_normal" === w.scopeId.name ? s = new Float32Array(h, w.offset) : "vertex_tangent" === w.scopeId.name ? v = new Float32Array(h, w.offset) : "vertex_texCoord0" === w.scopeId.name && (u = new Float32Array(h, w.offset))
                }
                if (r && s && u) {
                    var G = j.length / 3, h = h.byteLength / m, y, z, A, B, C, M, H, I, D, E, F, N, L, U, V, S, T, 
                    R, O = pc.math.vec3.create(0, 0, 0), P = pc.math.vec3.create(0, 0, 0);
                    B = pc.math.vec3.create(0, 0, 0);
                    C = pc.math.vec3.create(0, 0, 0);
                    M = pc.math.vec3.create(0, 0, 0);
                    H = pc.math.vec2.create(0, 0);
                    I = pc.math.vec2.create(0, 0);
                    D = pc.math.vec2.create(0, 0);
                    for (var J = new Float32Array(3 * h), K = new Float32Array(3 * h), w = 0; w < G; w++)
                        y = j[3 * w], z = j[3 * w + 1], A = j[3 * w + 2], pc.math.vec3.set(B, r[y * (m / 4)], r[y * (m / 4) + 1], r[y * (m / 4) + 2]), pc.math.vec3.set(C, r[z * (m / 4)], r[z * (m / 4) + 1], r[z * (m / 4) + 2]), pc.math.vec3.set(M, r[A * (m / 4)], r[A * (m / 4) + 1], r[A * (m / 4) + 2]), pc.math.vec2.set(H, 
                        u[y * (m / 4)], u[y * (m / 4) + 1]), pc.math.vec2.set(I, u[z * (m / 4)], u[z * (m / 4) + 1]), pc.math.vec2.set(D, u[A * (m / 4)], u[A * (m / 4) + 1]), E = C[0] - B[0], F = M[0] - B[0], N = C[1] - B[1], L = M[1] - B[1], U = C[2] - B[2], V = M[2] - B[2], S = I[0] - H[0], T = D[0] - H[0], n = I[1] - H[1], x = D[1] - H[1], R = 1 / (S * x - T * n), pc.math.vec3.set(O, (x * E - n * F) * R, (x * N - n * L) * R, (x * U - n * V) * R), pc.math.vec3.set(P, (S * F - T * E) * R, (S * L - T * N) * R, (S * V - T * U) * R), J[3 * y + 0] += O[0], J[3 * y + 1] += O[1], J[3 * y + 2] += O[2], J[3 * z + 0] += O[0], J[3 * z + 1] += O[1], J[3 * z + 2] += O[2], J[3 * A + 0] += O[0], J[3 * A + 1] += O[1], J[3 * A + 2] += O[2], K[3 * y + 0] += 
                        P[0], K[3 * y + 1] += P[1], K[3 * y + 2] += P[2], K[3 * z + 0] += P[0], K[3 * z + 1] += P[1], K[3 * z + 2] += P[2], K[3 * A + 0] += P[0], K[3 * A + 1] += P[1], K[3 * A + 2] += P[2];
                    r = pc.math.vec3.create(0, 0, 0);
                    n = pc.math.vec3.create(0, 0, 0);
                    x = pc.math.vec3.create(0, 0, 0);
                    u = pc.math.vec3.create(0, 0, 0);
                    for (w = 0; w < h; w++)
                        pc.math.vec3.set(r, s[w * (m / 4)], s[w * (m / 4) + 1], s[w * (m / 4) + 2]), pc.math.vec3.set(n, J[3 * w], J[3 * w + 1], J[3 * w + 2]), pc.math.vec3.set(x, K[3 * w], K[3 * w + 1], K[3 * w + 2]), j = pc.math.vec3.dot(r, n), pc.math.vec3.scale(r, j, u), pc.math.vec3.subtract(n, u, u), pc.math.vec3.normalize(u, 
                        u), v[w * (m / 4)] = u[0], v[w * (m / 4) + 1] = u[1], v[w * (m / 4) + 2] = u[2], pc.math.vec3.cross(r, n, u), v[w * (m / 4) + 3] = 0 > pc.math.vec3.dot(u, x) ? -1 : 1;
                    c.unlock();
                    b.unlock()
                }
            }
            s = this.model;
            var Q;
            0 < k.length && (Q = new pc.scene.Skin(k, l), s.skins.push(Q), s.skinInstances.push(new pc.scene.SkinInstance(Q)));
            l = [];
            for (m = 0; m < f.length; m++)
                s = f[m], v = new pc.scene.Mesh, v.vertexBuffer = b, v.indexBuffer[0] = c, v.primitive[0].type = s.primitive.type, v.primitive[0].base = s.primitive.base, v.primitive[0].count = s.primitive.count, v.primitive[0].indexed = !0, 
                v.skin = Q ? Q : null, v.aabb = a, v._material = s.material, l.push(v);
            s = this.model;
            if (0 < k.length) {
                m = pc.gfx.Device.getCurrent();
                a = m.getBoneLimit();
                k.length > a && (l = pc.scene.partitionSkin(a, [b], c, l, Q));
                for (m = 0; m < l.length; m++)
                    Q = l[m].skin, -1 === s.skins.indexOf(Q) && (s.skins.push(Q), b = new pc.scene.SkinInstance(Q), s.skinInstances.push(b))
            }
            return l
        },readNodeChunk: function() {
            this.readChunkHeader();
            var a = this.readU32(), b = this.readStringChunk(), c = this.readF32(), f = this.readF32(), j = this.readF32(), k = this.readF32(), l = this.readF32(), 
            m = this.readF32(), h = this.readF32(), n = this.readF32(), r = this.readF32(), s;
            switch (a) {
                case 0:
                    s = new pc.scene.GraphNode;
                    s.setName(b);
                    s.setLocalPosition(c, f, j);
                    s.setLocalEulerAngles(k, l, m);
                    s.setLocalScale(h, n, r);
                    break;
                case 1:
                    s = new pc.scene.CameraNode;
                    s.setName(b);
                    s.setLocalPosition(c, f, j);
                    s.setLocalEulerAngles(k, l, m);
                    s.setLocalScale(h, n, r);
                    j = this.readU32();
                    k = this.readF32();
                    l = this.readF32();
                    m = this.readF32();
                    a = this.readF32();
                    b = this.readF32();
                    c = this.readF32();
                    f = this.readF32();
                    s.setProjection(j);
                    s.setNearClip(k);
                    s.setFarClip(l);
                    s.setFov(m);
                    j = s.getClearOptions().color;
                    j[0] = a;
                    j[1] = b;
                    j[2] = c;
                    j[3] = f;
                    this.model.getCameras().push(s);
                    break;
                case 2:
                    s = new pc.scene.LightNode;
                    s.setName(b);
                    s.setLocalPosition(c, f, j);
                    s.setLocalEulerAngles(k, l, m);
                    s.setLocalScale(h, n, r);
                    f = this.readU16();
                    j = this.readU8();
                    k = this.readU8();
                    a = this.readF32();
                    b = this.readF32();
                    c = this.readF32();
                    l = this.readF32();
                    m = this.readF32();
                    h = this.readF32();
                    n = this.readF32();
                    r = this.readF32();
                    s.setType(f);
                    s.setEnabled(j);
                    s.setCastShadows(k);
                    s.setColor(a, b, c);
                    s.setIntensity(l);
                    s.setAttenuationStart(m);
                    s.setAttenuationEnd(h);
                    s.setInnerConeAngle(n);
                    s.setOuterConeAngle(r);
                    this.model.getLights().push(s);
                    break;
                case 3:
                    s = new pc.scene.GraphNode;
                    s.setName(b);
                    s.setLocalPosition(c, f, j);
                    s.setLocalEulerAngles(k, l, m);
                    s.setLocalScale(h, n, r);
                    a = this.model;
                    b = this.readU32();
                    b = a.geometries[b];
                    for (c = 0; c < b.length; c++)
                        f = new pc.scene.MeshInstance(s, b[c], b[c]._material), b[c].skin && (j = a.skins.indexOf(b[c].skin), f.skinInstance = a.skinInstances[j]), a.meshInstances.push(f)
            }
            return s
        },readModelChunk: function() {
            var a;
            this.model = new pc.scene.Model;
            this.readChunkHeader();
            var b = this.readU16(), c = this.readU16(), f = this.readU16(), j = this.readU16(), k = this.model.getTextures();
            for (a = 0; a < b; a++)
                k.push(this.readTextureChunk());
            b = this.model.getMaterials();
            for (a = 0; a < c; a++)
                b.push(this.readMaterialChunk());
            this.model.geometries = [];
            for (a = 0; a < f; a++)
                this.model.geometries.push(this.readGeometryChunk(this.model));
            c = [];
            for (a = 0; a < j; a++)
                c.push(this.readNodeChunk());
            j -= 1;
            f = this.readU16(2 * j);
            for (a = 0; a < j; a++)
                c[f[2 * a]].addChild(c[f[2 * a + 1]]);
            this.model.graph = c[0];
            this.model.resolveBoneNames();
            this.model.getGraph().syncHierarchy();
            j = this.model.meshInstances;
            for (a = 0; a < j.length; a++)
                j[a].syncAabb();
            return this.model
        }};
    a.prototype._loadModelBin = function(a, c) {
        return (new b(a, this._loader, this._textureCache, c)).readModelChunk()
    };
    var c;
    c = pc.inherits(function() {
    }, pc.resources.ResourceRequest);
    c.prototype.type = "model";
    return {ModelResourceHandler: a,ModelRequest: c}
}());
pc.anim = {};
pc.anim.Key = function() {
    this._quat = pc.math.quat.create(0, 0, 0, 0);
    this._pos = pc.math.vec3.create(0, 0, 0);
    this._time = 0
};
pc.anim.Node = function() {
    this._name = "";
    this._keys = []
};
pc.extend(pc.anim, function() {
    var b = function() {
        this._name = "";
        this._duration = 0;
        this._nodes = [];
        this._nodeDict = {}
    };
    b.prototype.getDuration = function() {
        return this._duration
    };
    b.prototype.getName = function() {
        return this._name
    };
    b.prototype.getNode = function(a) {
        return this._nodeDict[a]
    };
    b.prototype.getNodes = function() {
        return this._nodes
    };
    b.prototype.setDuration = function(a) {
        this._duration = a
    };
    b.prototype.setName = function(a) {
        this._name = a
    };
    b.prototype.addNode = function(a) {
        this._nodes.push(a);
        this._nodeDict[a._name] = 
        a
    };
    return {Animation: b}
}());
pc.extend(pc.anim, function() {
    function b() {
        this._written = !1;
        this._name = "";
        this._keyFrames = [];
        this._quat = pc.math.quat.create(0, 0, 0, 0);
        this._pos = pc.math.vec3.create(0, 0, 0);
        this._scale = pc.math.vec3.create(0, 0, 0);
        this._targetNode = null
    }
    b.prototype = {getTarget: function() {
            return this._targetNode
        },setTarget: function(a) {
            this._targetNode = a
        }};
    var a = function(a) {
        function d(a) {
            var c = a.getName(), j = new b;
            j._name = c;
            e._interpolatedKeys.push(j);
            e._interpolatedKeyDict[c] = j;
            e._currKeyIndices[c] = 0;
            a = a.getChildren();
            for (c = 
            0; c < a.length; c++)
                d(a[c])
        }
        this._animation = null;
        this._time = 0;
        this.looping = !0;
        this._interpolatedKeys = [];
        this._interpolatedKeyDict = {};
        this._currKeyIndices = {};
        var e = this;
        d(a)
    };
    a.prototype.addTime = function(a) {
        if (null !== this._animation && (this._time !== f || this.looping)) {
            var b = pc.math.vec3.lerp, e = pc.math.quat.slerp, g = this._animation.getNodes();
            this._time += a;
            var f = this._animation.getDuration();
            if (this._time > f) {
                this._time = this.looping ? 0 : f;
                for (a = 0; a < g.length; a++) {
                    var j = g[a], f = j._name;
                    this._currKeyIndices[f] = 0
                }
            }
            for (a = 
            0; a < g.length; a++) {
                var j = g[a], f = j._name, j = j._keys, k = this._interpolatedKeyDict[f];
                if (1 === j.length)
                    pc.math.quat.copy(j[0]._quat, k._quat), pc.math.vec3.copy(j[0]._pos, k._pos), pc.math.vec3.copy(j[0]._scale, k._scale);
                else
                    for (var l = this._currKeyIndices[f]; l < j.length - 1; l++) {
                        var m = j[l], h = j[l + 1];
                        if (m._time <= this._time && h._time >= this._time) {
                            var n = (this._time - m._time) / (h._time - m._time);
                            e(m._quat, h._quat, n, k._quat);
                            b(m._pos, h._pos, n, k._pos);
                            b(m._scale, h._scale, n, k._scale);
                            k._written = !0;
                            this._currKeyIndices[f] = 
                            l
                        }
                    }
            }
        }
    };
    a.prototype.blend = function(a, b, e) {
        for (var g = this._interpolatedKeys.length, f = 0; f < g; f++) {
            var j = a._interpolatedKeys[f], k = b._interpolatedKeys[f], l = this._interpolatedKeys[f];
            j._written && k._written ? (pc.math.quat.slerp(j._quat, b._interpolatedKeys[f]._quat, e, l._quat), pc.math.vec3.lerp(j._pos, b._interpolatedKeys[f]._pos, e, l._pos), pc.math.vec3.lerp(j._scale, k._scale, e, l._scale), l._written = !0) : j._written ? (pc.math.quat.copy(j._quat, l._quat), pc.math.vec3.copy(j._pos, l._pos), pc.math.vec3.copy(j._scale, l._scale), 
            l._written = !0) : k._written && (pc.math.quat.copy(k._quat, l._quat), pc.math.vec3.copy(k._pos, l._pos), pc.math.vec3.copy(k._scale, l._scale), l._written = !0)
        }
    };
    a.prototype.getAnimation = function() {
        return this._animation
    };
    a.prototype.getCurrentTime = function() {
        return this._time
    };
    a.prototype.setCurrentTime = function(a) {
        this._time = a;
        for (var a = this._interpolatedKeys.length, b = 0; b < a; b++)
            this._currKeyIndices[this._interpolatedKeys[b]._name] = 0
    };
    a.prototype.getNumNodes = function() {
        return this._interpolatedKeys.length
    };
    a.prototype.setAnimation = function(a) {
        this._animation = a;
        this.setCurrentTime(0)
    };
    a.prototype.setGraph = function(a) {
        for (var b = 0; b < this._interpolatedKeys.length; b++) {
            var e = a.findByName(this._interpolatedKeys[b]._name);
            this._interpolatedKeys[b].setTarget(e)
        }
    };
    a.prototype.updateGraph = function() {
        for (var a = 0; a < this._interpolatedKeys.length; a++) {
            var b = this._interpolatedKeys[a];
            if (b._written) {
                var e = b.getTarget();
                pc.math.vec3.copy(b._pos, e.localPosition);
                pc.math.quat.copy(b._quat, e.localRotation);
                pc.math.vec3.copy(b._scale, 
                e.localScale);
                e.dirtyLocal = !0;
                b._written = !1
            }
        }
    };
    a.prototype.setLooping = function(a) {
        this.looping = a
    };
    a.prototype.getLooping = function() {
        return this.looping
    };
    return {Skeleton: a}
}());
pc.extend(pc.resources, function() {
    var b;
    b = pc.inherits(function() {
    }, pc.resources.ResourceHandler);
    b.prototype.load = function(a, b, e) {
        pc.path.getDirectory(a);
        pc.net.http.get(a, function(g) {
            try {
                b(g)
            } catch (f) {
                e(pc.string.format("An error occured while loading animation from: '{0}'", a))
            }
        }.bind(this), {cache: !1})
    };
    b.prototype.open = function(a) {
        return animation = this._loadAnimation(a)
    };
    b.prototype._loadAnimation = function(a) {
        var a = a.animation, b = new pc.anim.Animation;
        b.setName(a.name);
        b.setDuration(a.duration);
        for (var e = 0; e < a.nodes.length; e++) {
            var g = new pc.anim.Node, f = a.nodes[e];
            g._name = f.name;
            for (var j = 0; j < f.keys.length; j++) {
                var k = new pc.anim.Key, l = f.keys[j], m = l.pos, h = l.rot, n = l.scale, l = l.time;
                k._pos = pc.math.vec3.create(m[0], m[1], m[2]);
                k._quat = pc.math.quat.create();
                pc.math.quat.setFromEulers(k._quat, h[0], h[1], h[2]);
                k._scale = pc.math.vec3.create(n[0], n[1], n[2]);
                k._time = l;
                g._keys.push(k)
            }
            b.addNode(g)
        }
        return b
    };
    var a;
    a = pc.inherits(function() {
    }, pc.resources.ResourceRequest);
    a.prototype.type = "animation";
    return {AnimationResourceHandler: b,
        AnimationRequest: a}
}());
pc.audio = function() {
    var b = function() {
        if (pc.audio.hasAudioContext()) {
            var a = a || webkitAudioContext;
            this.context = new a
        }
        this.listener = new pc.audio.Listener(this);
        this.volume = 1;
        this.suspended = !1;
        pc.extend(this, pc.events)
    };
    b.prototype = {createSound: function(a, b, d) {
            var e = null;
            pc.audio.Sound ? e = new pc.audio.Sound(this, a, b, d) : d();
            return e
        },playSound: function(a, b) {
            var b = b || {}, d = null;
            pc.audio.Channel && (d = new pc.audio.Channel(this, a, b), d.play());
            return d
        },playSound3d: function(a, b, d) {
            var d = d || {}, e = null;
            pc.audio.Channel3d && 
            (e = new pc.audio.Channel3d(this, a, d), e.setPosition(b), d.volume && e.setVolume(d.volume), d.loop && e.setLoop(d.loop), d.maxDistance && e.setMaxDistance(d.maxDistance), d.minDistance && e.setMinDistance(d.minDistance), d.rollOffFactor && e.setRollOffFactor(d.rollOffFactor), e.play());
            return e
        },getListener: function() {
            return this.listener
        },getVolume: function() {
            return this.volume
        },setVolume: function(a) {
            this.volume = a;
            this.fire("volumechange", a)
        },suspend: function() {
            this.suspended = !0;
            this.fire("suspend")
        },resume: function() {
            this.suspended = 
            !1;
            this.fire("resume")
        }};
    return {AudioManager: b,hasAudio: function() {
            return "undefined" !== typeof Audio
        },hasAudioContext: function() {
            return !!("undefined" !== typeof AudioContext || "undefined" !== typeof webkitAudioContext)
        },isSupported: function(a, b) {
            var d = {".ogg": "audio/ogg",".mp3": "audio/mpeg",".wav": "audio/x-wav"}, e = pc.path.getExtension(a);
            return d[e] ? (b || (b = new Audio), "" !== b.canPlayType(d[e])) : !1
        }}
}();
pc.extend(pc.audio, function() {
    var b;
    pc.audio.hasAudioContext() ? b = function(a, b, d, e) {
        //d(null); //mortimer
        //return;
        this.buffer = null;
        this.isLoaded = !1;
        a.context && pc.net.http.get(b, function(b) {
            a.context.decodeAudioData(b, function(a) {
                this.buffer = a;
                this.isLoaded = !0;
                d(this)
            }.bind(this), e)
        }.bind(this), {error: e})
    } : pc.audio.hasAudio() && (b = function(a, b, d, e) {
        this.isLoaded = !1;
        this.audio = new Audio;
        pc.audio.isSupported(b, this.audio) ? (this.audio.addEventListener("stalled", function() {
            logDEBUG("stalled: " + this.audio.src)
        }.bind(this), !1), this.audio.addEventListener("suspend", 
        function() {
            logDEBUG("suspend: " + this.audio.src)
        }.bind(this), !1), this.audio.addEventListener("abort", function() {
            logDEBUG("abort: " + this.audio.src)
        }.bind(this), !1), this.audio.addEventListener("pause", function() {
            logDEBUG("pause: " + this.audio.src)
        }.bind(this), !1), this.audio.addEventListener("canplay", function() {
            logDEBUG("canplay: " + this.audio.src)
        }.bind(this), !1), this.audio.addEventListener("progress", function() {
            logDEBUG("progress " + b)
        }.bind(this)), this.audio.addEventListener("loadstart", function() {
            logDEBUG("loadstart: " + 
            this.audio.src);
            this.isLoaded || (this.isLoaded = !0, d(this))
        }.bind(this), !1), this.audio.addEventListener("canplaythrough", function() {
            logDEBUG("canplaythrough: " + this.audio.src);
            this.isLoaded || (this.isLoaded = !0, d(this))
        }.bind(this), !1), this.audio.addEventListener("loadeddata", function() {
            logDEBUG("loadeddata: " + b);
            this.isLoaded || (this.isLoaded = !0, d(this))
        }.bind(this), !1), this.audio.addEventListener("error", function() {
            logERROR("error loading: " + b);
            e(pc.string.format("Error loading Sound from: '{0}'", b))
        }.bind(this), 
        !1), this.audio.src = b, logDEBUG("loading: " + b)) : (setTimeout(function() {
            e(pc.string.format("Audio format for {0} not supported", b))
        }, 0), this.audio = null)
    });
    return {Sound: b}
}());
pc.extend(pc.audio, function() {
    var b;
    pc.audio.hasAudioContext() ? (b = function(a) {
        this.position = pc.math.vec3.create(0, 0, 0);
        this.velocity = pc.math.vec3.create(0, 0, 0);
        this.orientation = pc.math.mat4.create();
        this.listener = a.context.listener
    }, b.prototype.getPosition = function() {
        return this.position
    }, b.prototype.setPosition = function(a) {
        pc.math.vec3.copy(a, this.position);
        this.listener.setPosition(a[0], a[1], a[2])
    }, b.prototype.getVelocity = function() {
        return this.velocity
    }, b.prototype.setVelocity = function(a) {
        pc.math.vec3.copy(a, 
        this.velocity);
        this.listener.setPosition(a[0], a[1], a[2])
    }, b.prototype.setOrientation = function(a) {
        pc.math.mat4.copy(a, this.orientation);
        this.listener.setOrientation(-a[8], -a[9], -a[10], a[4], a[5], a[6])
    }) : (b = function() {
        this.position = pc.math.vec3.create(0, 0, 0);
        this.velocity = pc.math.vec3.create(0, 0, 0);
        this.orientation = pc.math.mat4.create()
    }, b.prototype.getPosition = function() {
        return this.position
    }, b.prototype.setPosition = function(a) {
        pc.math.vec3.copy(a, this.position)
    }, b.prototype.getVelocity = function() {
        return this.velocity
    }, 
    b.prototype.setVelocity = function(a) {
        pc.math.vec3.copy(a, this.velocity)
    }, b.prototype.setOrientation = function(a) {
        pc.math.mat4.copy(a, this.orientation)
    });
    b.prototype.getOrientation = function() {
        return this.orientation
    };
    return {Listener: b}
}());
pc.extend(pc.audio, function() {
    var b;
    pc.audio.hasAudioContext() ? (b = function(a, b, d) {
        d = d || {};
        this.volume = d.volume || 1;
        this.loop = d.loop || !1;
        this.sound = b;
        this.suspended = this.paused = !1;
        this.pausedAt = this.startedAt = null;
        this.manager = a;
        this.resetTimeout = this.source = null
    }, b.prototype = {play: function() {
            if (this.source)
                throw Error("Call stop() before calling play()");
            this.source = this._createSource();
            this.startedAt = this.manager.context.currentTime;
            this.setVolume(this.volume);
            this.setLoop(this.loop);
            this.source.noteOn(0);
            this.manager.on("volumechange", this.onManagerVolumeChange, this);
            this.manager.on("suspend", this.onManagerSuspend, this);
            this.manager.on("resume", this.onManagerResume, this)
        },pause: function() {
            this.source && (null !== this.resetTimeout && clearTimeout(this.resetTimeout), this.paused = !0, this.pausedAt = (this.manager.context.currentTime - this.startedAt) % this.source.buffer.duration, this.source.noteOff(0), this.source = null)
        },unpause: function() {
            if (this.source || !this.paused)
                throw Error("Call pause() before unpausing.");
            this.source = this._createSource();
            this.setVolume(this.volume);
            this.setLoop(this.loop);
            this.startedAt -= this.pausedAt;
            var a = this.source.buffer.duration - this.pausedAt;
            this.source.noteGrainOn(0, this.pausedAt, a);
            this.resetTimeout = setTimeout(function() {
                this.getLoop() && (this.stop(), this.play())
            }.bind(this), 1E3 * a);
            this.paused = !1
        },stop: function() {
            this.source && (null !== this.resetTimeout && clearTimeout(this.resetTimeout), this.source.noteOff(0), this.source = null);
            this.manager.off("volumechange", this.onManagerVolumeChange, 
            this);
            this.manager.off("suspend", this.onManagerSuspend, this);
            this.manager.off("resume", this.onManagerResume, this)
        },setLoop: function(a) {
            this.loop = a;
            this.source && (this.source.loop = a)
        },setVolume: function(a) {
            this.volume = a;
            this.source && (this.source.gain.value = a * this.manager.getVolume())
        },isPlaying: function() {
            return !this.paused && this.source.playbackState === this.source.PLAYING_STATE
        },getDuration: function() {
            return this.source ? this.source.buffer.duration : 0
        },_createSource: function() {
            var a = this.manager.context.createBufferSource();
            a.buffer = this.sound.buffer;
            a.connect(this.manager.context.destination);
            return a
        }}) : pc.audio.hasAudio() ? (b = function(a, b, d) {
        this.volume = d.volume || 1;
        this.loop = d.loop || !1;
        this.sound = b;
        this.suspended = this.paused = !1;
        this.manager = a;
        this.source = b.audio.cloneNode(!1);
        this.source.pause()
    }, b.prototype = {play: function() {
            this.source && (this.paused = !1, this.setVolume(this.volume), this.setLoop(this.loop), this.source.play());
            this.manager.on("volumechange", this.onManagerVolumeChange, this);
            this.manager.on("suspend", this.onManagerSuspend, 
            this);
            this.manager.on("resume", this.onManagerResume, this)
        },pause: function() {
            this.source && (this.paused = !0, this.source.pause())
        },unpause: function() {
            this.source && (this.paused = !1, this.source.play())
        },stop: function() {
            this.source && (this.source.pause(), this.source.currentTime = 0);
            this.manager.off("volumechange", this.onManagerVolumeChange, this);
            this.manager.off("suspend", this.onManagerSuspend, this);
            this.manager.off("resume", this.onManagerResume, this)
        },setVolume: function(a) {
            this.volume = a;
            this.source && (this.source.volume = 
            a * this.manager.getVolume())
        },setLoop: function(a) {
            this.loop = a;
            this.source && (this.source.loop = a)
        },getDuration: function() {
            if (this.source) {
                var a = this.source.duration;
                if (a === a)
                    return a
            }
            return 0
        },isPlaying: function() {
            return !this.source.paused
        }}) : (console.warn("No support for 2D audio found"), b = function() {
    });
    pc.extend(b.prototype, {getVolume: function() {
            return this.volume
        },getLoop: function() {
            return this.loop
        },onManagerVolumeChange: function() {
            this.setVolume(this.getVolume())
        },onManagerSuspend: function() {
            this.isPlaying() && 
            !this.suspended && (this.suspended = !0, this.pause())
        },onManagerResume: function() {
            this.suspended && (this.suspended = !1, this.unpause())
        }});
    return {Channel: b}
}());
pc.extend(pc.audio, function() {
    var b;
    if (pc.audio.hasAudioContext())
        b = function(a) {
            this.position = pc.math.vec3.create();
            this.velocity = pc.math.vec3.create();
            this.panner = a.context.createPanner()
        }, b = pc.inherits(b, pc.audio.Channel), b.prototype = pc.extend(b.prototype, {getPosition: function() {
                return this.position
            },setPosition: function(a) {
                pc.math.vec3.copy(a, this.position);
                this.panner.setPosition(a[0], a[1], a[2])
            },getVelocity: function() {
                return this.velocity
            },setVelocity: function(a) {
                pc.math.vec3.copy(a, this.velocity);
                this.panner.setVelocity(a[0], a[1], a[2])
            },getMaxDistance: function() {
                return this.panner.maxDistance
            },setMaxDistance: function(a) {
                this.panner.maxDistance = a
            },getMinDistance: function() {
                return this.panner.refDistance
            },setMinDistance: function(a) {
                this.panner.refDistance = a
            },getRollOffFactor: function() {
                return this.panner.rolloffFactor
            },setRollOffFactor: function(a) {
                this.panner.rolloffFactor = a
            },_createSource: function() {
                var a = this.manager.context.createBufferSource();
                a.buffer = this.sound.buffer;
                a.disconnect(0);
                a.connect(this.panner);
                this.panner.connect(this.manager.context.destination);
                return a
            }});
    else if (pc.audio.hasAudio()) {
        var a = pc.math.vec3.create(), c;
        b = pc.inherits(function() {
            this.position = pc.math.vec3.create();
            this.velocity = pc.math.vec3.create();
            this.maxDistance = 1E4;
            this.rollOffFactor = this.minDistance = 1
        }, pc.audio.Channel);
        b.prototype = pc.extend(b.prototype, {getPosition: function() {
                return this.position
            },setPosition: function(b) {
                pc.math.vec3.copy(b, this.position);
                if (this.source) {
                    var e = this.manager.getListener().getPosition();
                    var b = this.minDistance, g = this.maxDistance, f = this.rollOffFactor;
                    a = pc.math.vec3.subtract(e, this.position, a);
                    c = pc.math.vec3.length(a);
                    c < b ? b = 1 : c > g ? b = 0 : (e = b + f * (c - b), b = 0 !== e ? b / e : 1);
                    e = this.getVolume();
                    this.source.volume = e * b
                }
            },getVelocity: function() {
                return this.velocity
            },setVelocity: function(a) {
                pc.math.vec3.copy(a, this.velocity)
            },getMaxDistance: function() {
                return this.maxDistance
            },setMaxDistance: function(a) {
                this.maxDistance = a
            },getMinDistance: function() {
                return this.minDistance
            },setMinDistance: function(a) {
                this.minDistance = 
                a
            },getRollOffFactor: function() {
                return this.rolloffFactor
            },setRollOffFactor: function(a) {
                this.rolloffFactor = a
            }})
    } else
        console.warn("No support for 3D audio found"), b = function() {
        };
    return {Channel3d: b}
}());
pc.extend(pc.resources, function() {
    var b = function(a) {
        this.manager = a
    }, b = pc.inherits(b, pc.resources.ResourceHandler);
    b.prototype.load = function(a, b, e, g) {
        this.manager.createSound(a, function(a) {
            b(a)
        }, e, g)
    };
    b.prototype.open = function(a) {
        return a
    };
    var a;
    a = pc.inherits(function() {
    }, pc.resources.ResourceRequest);
    a.prototype.type = "audio";
    return {AudioResourceHandler: b,AudioRequest: a}
}());
pc.input = {};
pc.extend(pc.input, function() {
    var b = function(a, c) {
        var d = {x: 0,y: 0};
        if (c) {
            if (c instanceof b)
                throw Error("Expected MouseEvent");
            d = pc.input.getTargetCoords(c)
        } else
            c = {};
        this.x = d.x;
        this.y = d.y;
        this.wheel = c.detail ? -1 * c.detail : c.wheelDelta ? c.wheelDelta / 120 : 0;
        pc.input.Mouse.isPointerLocked() ? (this.dx = c.movementX || c.webkitMovementX || c.mozMovementX || 0, this.dy = c.movementY || c.webkitMovementY || c.mozMovementY || 0) : (this.dx = this.x - a._lastX, this.dy = this.y - a._lastY);
        this.button = "mousedown" === c.type || "mouseup" === c.type ? 
        c.button : pc.input.MOUSEBUTTON_NONE;
        this.buttons = a._buttons.slice(0);
        this.element = c.target;
        this.ctrlKey = c.ctrlKey || !1;
        this.altKey = c.altKey || !1;
        this.shiftKey = c.shiftKey || !1;
        this.metaKey = c.metaKey || !1;
        this.event = c
    }, a = function(a) {
        this._lastY = this._lastX = 0;
        this._buttons = [!1, !1, !1];
        this._lastbuttons = [!1, !1, !1];
        this._upHandler = this._handleUp.bind(this);
        this._downHandler = this._handleDown.bind(this);
        this._moveHandler = this._handleMove.bind(this);
        this._wheelHandler = this._handleWheel.bind(this);
        this._contextMenuHandler = 
        function(a) {
            a.preventDefault()
        };
        this._element = null;
        a && this.attach(a);
        pc.extend(this, pc.events)
    };
    a.isPointerLocked = function() {
        return !!document.pointerLockElement
    };
    a.prototype = {attach: function(a) {
            this._element && this.detach();
            this._element = a;
            this._element.addEventListener("mouseup", this._upHandler, !1);
            this._element.addEventListener("mousedown", this._downHandler, !1);
            this._element.addEventListener("mousemove", this._moveHandler, !1);
            this._element.addEventListener("mousewheel", this._wheelHandler, !1);
            this._element.addEventListener("DOMMouseScroll", 
            this._wheelHandler, !1)
        },detach: function() {
            this._element.removeEventListener("mouseup", this._upHandler);
            this._element.removeEventListener("mousedown", this._downHandler);
            this._element.removeEventListener("mousemove", this._moveHandler);
            this._element.removeEventListener("mousewheel", this._wheelHandler);
            this._element.removeEventListener("DOMMouseScroll", this._wheelHandler);
            this._element = null
        },disableContextMenu: function() {
            this._element.addEventListener("contextmenu", this._contextMenuHandler)
        },enableContextMenu: function() {
            this._element.removeEventListener("contextmenu", 
            this._contextMenuHandler)
        },enablePointerLock: function(a, b) {
            var c = function() {
                a();
                document.removeEventListener("pointerlockchange", c)
            }, d = function() {
                b();
                document.removeEventListener("pointerlockerror", d)
            };
            a && document.addEventListener("pointerlockchange", c, !1);
            b && document.addEventListener("pointerlockerror", d, !1);
            this._element.requestPointerLock()
        },disablePointerLock: function(a) {
            var b = function() {
                a();
                document.removeEventListener("pointerlockchange", b)
            };
            a && document.addEventListener("pointerlockchange", 
            b, !1);
            document.exitPointerLock()
        },update: function() {
            this._lastbuttons[0] = this._buttons[0];
            this._lastbuttons[1] = this._buttons[1];
            this._lastbuttons[2] = this._buttons[2]
        },isPressed: function(a) {
            return this._buttons[a]
        },wasPressed: function(a) {
            return this._buttons[a] && !this._lastbuttons[a]
        },_handleUp: function(a) {
            this._buttons[a.button] = !1;
            this.fire(pc.input.EVENT_MOUSEUP, new b(this, a))
        },_handleDown: function(a) {
            this._buttons[a.button] = !0;
            this.fire(pc.input.EVENT_MOUSEDOWN, new b(this, a))
        },_handleMove: function(a) {
            a = 
            new b(this, a);
            this.fire(pc.input.EVENT_MOUSEMOVE, a);
            this._lastX = a.x;
            this._lastY = a.y
        },_handleWheel: function(a) {
            this.fire(pc.input.EVENT_MOUSEWHEEL, new b(this, a))
        }};
    if (!("undefined" === typeof navigator || "undefined" === typeof document)) {
        navigator.pointer = navigator.pointer || navigator.webkitPointer || navigator.mozPointer;
        var c = function() {
            var a = document.createEvent("CustomEvent");
            a.initCustomEvent("pointerlockchange", !0, !1, null);
            document.dispatchEvent(a)
        }, d = function() {
            var a = document.createEvent("CustomEvent");
            a.initCustomEvent("pointerlockerror", !0, !1, null);
            document.dispatchEvent(a)
        };
        document.addEventListener("webkitpointerlockchange", c, !1);
        document.addEventListener("webkitpointerlocklost", c, !1);
        document.addEventListener("mozpointerlockchange", c, !1);
        document.addEventListener("mozpointerlocklost", c, !1);
        document.addEventListener("webkitpointerlockerror", d, !1);
        document.addEventListener("mozpointerlockerror", d, !1);
        document.pointerLockElement || Object.defineProperty(document, "pointerLockElement", {enumerable: !0,
            configurable: !1,get: function() {
                return document.webkitPointerLockElement || document.mozPointerLockElement
            }});
        Element.prototype.requestPointerLock = Element.prototype.mozRequestPointerLock ? function() {
            this.mozRequestPointerLock()
        } : Element.prototype.requestPointerLock || Element.prototype.webkitRequestPointerLock || Element.prototype.mozRequestPointerLock;
        !Element.prototype.requestPointerLock && navigator.pointer && (Element.prototype.requestPointerLock = function() {
            document.pointerLockElement = this;
            navigator.pointer.lock(this, 
            c, d)
        });
        document.exitPointerLock = document.exitPointerLock || document.webkitExitPointerLock || document.mozExitPointerLock;
        document.exitPointerLock || (document.exitPointerLock = function() {
            navigator.pointer && (document.pointerLockElement = null, navigator.pointer.unlock())
        })
    }
    return {Mouse: a,MouseEvent: b,EVENT_MOUSEDOWN: "mousedown",EVENT_MOUSEMOVE: "mousemove",EVENT_MOUSEUP: "mouseup",EVENT_MOUSEWHEEL: "mousewheel",MOUSEBUTTON_NONE: -1,MOUSEBUTTON_LEFT: 0,MOUSEBUTTON_MIDDLE: 1,MOUSEBUTTON_RIGHT: 2,getTargetCoords: function(a) {
            for (var b = 
            {x: 0,y: 0}, c = a.currentTarget, d = 0, k = 0; c.offsetParent; )
                d += c.offsetLeft, k += c.offsetTop, c = c.offsetParent;
            b.x = a.pageX - d;
            b.y = a.pageY - k;
            return b
        }}
}());
pc.extend(pc.input, function() {
    function b(a) {
        return "string" == typeof a ? a.toUpperCase().charCodeAt(0) : a
    }
    var a = function(a, b) {
        this.key = b.keyCode;
        this.element = b.target;
        this.event = b
    }, c = {9: "Tab",13: "Enter",16: "Shift",17: "Control",18: "Alt",27: "Escape",37: "Left",38: "Up",39: "Right",40: "Down",46: "Delete",91: "Win"}, d = function(a, b) {
        b = b || {};
        this._element = null;
        this._keyDownHandler = this._handleKeyDown.bind(this);
        this._keyUpHandler = this._handleKeyUp.bind(this);
        this._keyPressHandler = this._handleKeyPress.bind(this);
        pc.extend(this, pc.events);
        this._keymap = {};
        this._lastmap = {};
        a && this.attach(a);
        this.preventDefault = b.preventDefault || !1;
        this.stopPropagation = b.stopPropagation || !1
    };
    d.prototype.attach = function(a) {
        this._element && this.detach();
        this._element = a;
        this._element.addEventListener("keydown", this._keyDownHandler, !1);
        this._element.addEventListener("keypress", this._keyPressHandler, !1);
        this._element.addEventListener("keyup", this._keyUpHandler, !1)
    };
    d.prototype.detach = function() {
        this._element.removeEventListener("keydown", 
        this._keyDownHandler);
        this._element.removeEventListener("keypress", this._keyPressHandler);
        this._element.removeEventListener("keyup", this._keyUpHandler);
        this._element = null
    };
    d.prototype.toKeyIdentifier = function(a) {
        var a = b(a), d, f;
        if (d = c[a.toString()])
            return d;
        d = a.toString(16).toUpperCase();
        f = d.length;
        for (a = 0; a < 4 - f; a++)
            d = "0" + d;
        return "U+" + d
    };
    d.prototype._handleKeyDown = function(b) {
        var c = b.keyCode || b.charCode, c = b.keyIdentifier || this.toKeyIdentifier(c);
        this._keymap[c] = !0;
        this.fire("keydown", new a(this, b));
        this.preventDefault && b.preventDefault();
        this.stopPropagation && b.stopPropagation()
    };
    d.prototype._handleKeyUp = function(b) {
        var c = b.keyCode || b.charCode, c = b.keyIdentifier || this.toKeyIdentifier(c);
        delete this._keymap[c];
        this.fire("keyup", new a(this, b));
        this.preventDefault && b.preventDefault();
        this.stopPropagation && b.stopPropagation()
    };
    d.prototype._handleKeyPress = function(b) {
        var c = b.keyCode || b.charCode;
        b.keyIdentifier || this.toKeyIdentifier(c);
        this.fire("keypress", new a(this, b));
        this.preventDefault && b.preventDefault();
        this.stopPropagation && b.stopPropagation()
    };
    d.prototype.update = function() {
        var a;
        this._lastmap = {};
        for (a in this._keymap)
            this._keymap.hasOwnProperty(a) && (this._lastmap[a] = this._keymap[a])
    };
    d.prototype.isPressed = function(a) {
        a = b(a);
        a = this.toKeyIdentifier(a);
        return !!this._keymap[a]
    };
    d.prototype.wasPressed = function(a) {
        a = b(a);
        a = this.toKeyIdentifier(a);
        return !!this._keymap[a] && !this._lastmap[a]
    };
    return {Keyboard: d,EVENT_KEYDOWN: "keydown",EVENT_KEYUP: "keyup",KEY_BACKSPACE: 8,KEY_TAB: 9,KEY_RETURN: 13,KEY_ENTER: 14,
        KEY_SHIFT: 16,KEY_CONTROL: 17,KEY_ALT: 18,KEY_PAUSE: 19,KEY_CAPS_LOCK: 20,KEY_ESCAPE: 27,KEY_SPACE: 32,KEY_PAGE_UP: 33,KEY_PAGE_DOWN: 34,KEY_END: 35,KEY_HOME: 36,KEY_LEFT: 37,KEY_UP: 38,KEY_RIGHT: 39,KEY_DOWN: 40,KEY_PRINT_SCREEN: 44,KEY_INSERT: 45,KEY_DELETE: 46,KEY_0: 48,KEY_1: 49,KEY_2: 50,KEY_3: 51,KEY_4: 52,KEY_5: 53,KEY_6: 54,KEY_7: 55,KEY_8: 56,KEY_9: 57,KEY_SEMICOLON: 59,KEY_EQUAL: 61,KEY_A: 65,KEY_B: 66,KEY_C: 67,KEY_D: 68,KEY_E: 69,KEY_F: 70,KEY_G: 71,KEY_H: 72,KEY_I: 73,KEY_J: 74,KEY_K: 75,KEY_L: 76,KEY_M: 77,KEY_N: 78,KEY_O: 79,
        KEY_P: 80,KEY_Q: 81,KEY_R: 82,KEY_S: 83,KEY_T: 84,KEY_U: 85,KEY_V: 86,KEY_W: 87,KEY_X: 88,KEY_Y: 89,KEY_Z: 90,KEY_WINDOWS: 91,KEY_CONTEXT_MENU: 93,KEY_NUMPAD_0: 96,KEY_NUMPAD_1: 97,KEY_NUMPAD_2: 98,KEY_NUMPAD_3: 99,KEY_NUMPAD_4: 100,KEY_NUMPAD_5: 101,KEY_NUMPAD_6: 102,KEY_NUMPAD_7: 103,KEY_NUMPAD_8: 104,KEY_NUMPAD_9: 105,KEY_MULTIPLY: 106,KEY_ADD: 107,KEY_SEPARATOR: 108,KEY_SUBTRACT: 109,KEY_DECIMAL: 110,KEY_DIVIDE: 111,KEY_F1: 112,KEY_F2: 113,KEY_F3: 114,KEY_F4: 115,KEY_F5: 116,KEY_F6: 117,KEY_F7: 118,KEY_F8: 119,KEY_F9: 120,KEY_F10: 121,
        KEY_F11: 122,KEY_F12: 123,KEY_COMMA: 188,KEY_PERIOD: 190,KEY_SLASH: 191,KEY_OPEN_BRACKET: 219,KEY_BACK_SLASH: 220,KEY_CLOSE_BRACKET: 221,KEY_META: 224}
}());
pc.extend(pc.input, function() {
    var b = function() {
        this.gamepadsSupported = !!navigator.webkitGetGamepads;
        this.current = [];
        this.previous = [];
        this.deadZone = 0.25
    }, a = {DEFAULT: {buttons: "PAD_FACE_1 PAD_FACE_2 PAD_FACE_3 PAD_FACE_4 PAD_L_SHOULDER_1 PAD_R_SHOULDER_1 PAD_L_SHOULDER_2 PAD_R_SHOULDER_2 PAD_SELECT PAD_START PAD_L_STICK_BUTTON PAD_R_STICK_BUTTON PAD_UP PAD_DOWN PAD_LEFT PAD_RIGHT PAD_VENDOR".split(" "),axes: ["PAD_L_STICK_X", "PAD_L_STICK_Y", "PAD_R_STICK_X", "PAD_R_STICK_Y"]},PS3: {buttons: "PAD_FACE_1 PAD_FACE_2 PAD_FACE_4 PAD_FACE_3 PAD_L_SHOULDER_1 PAD_R_SHOULDER_1 PAD_L_SHOULDER_2 PAD_R_SHOULDER_2 PAD_SELECT PAD_START PAD_L_STICK_BUTTON PAD_R_STICK_BUTTON PAD_UP PAD_DOWN PAD_LEFT PAD_RIGHT PAD_VENDOR".split(" "),
            axes: ["PAD_L_STICK_X", "PAD_L_STICK_Y", "PAD_R_STICK_X", "PAD_R_STICK_Y"]}}, c = {"Product: 0268": "PS3"};
    b.prototype = {update: function() {
            var a = this.poll(), b, c = a.length;
            for (b = 0; b < c; b++)
                this.previous[b] = this.current[b], this.current[b] = a[b]
        },poll: function() {
            var a = [];
            if (this.gamepadsSupported) {
                var b = navigator.webkitGetGamepads(), c, f = b.length;
                for (c = 0; c < f; c++)
                    b[c] && a.push({map: this.getMap(b[c]),pad: b[c]})
            }
            return a
        },getMap: function(b) {
            for (code in c)
                if (0 <= b.id.indexOf(code))
                    return a[c[code]];
            return a.DEFAULT
        },isPressed: function(a, 
        b) {
            return !this.current[a] ? !1 : this.current[a].pad.buttons[pc.input[this.current[a].map.buttons[b]]]
        },wasPressed: function(a, b) {
            if (!this.current[a])
                return !1;
            var c = pc.input[this.current[a].map.buttons[b]];
            return this.current[a].pad.buttons[c] && !this.previous[a].pad.buttons[c]
        },getAxis: function(a, b) {
            if (!this.current[a])
                return !1;
            var c = this.current[a].pad.axes[pc.input[this.current[a].map.axes[b]]];
            Math.abs(c) < this.deadZone && (c = 0);
            return c
        }};
    return {PAD_1: 0,PAD_2: 1,PAD_3: 2,PAD_4: 3,PAD_FACE_1: 0,PAD_FACE_2: 1,
        PAD_FACE_3: 2,PAD_FACE_4: 3,PAD_L_SHOULDER_1: 4,PAD_R_SHOULDER_1: 5,PAD_L_SHOULDER_2: 6,PAD_R_SHOULDER_2: 7,PAD_SELECT: 8,PAD_START: 9,PAD_L_STICK_BUTTON: 10,PAD_R_STICK_BUTTON: 11,PAD_UP: 12,PAD_DOWN: 13,PAD_LEFT: 14,PAD_RIGHT: 15,PAD_VENDOR: 16,PAD_L_STICK_X: 0,PAD_L_STICK_Y: 1,PAD_R_STICK_X: 2,PAD_R_STICK_Y: 3,GamePads: b}
}());
pc.extend(pc.input, function() {
    var b = function(b, c) {
        this.element = c.target;
        this.touches = [];
        this.changedTouches = [];
        if (c) {
            var g, f = c.touches.length;
            for (g = 0; g < f; g++)
                this.touches.push(new a(c.touches[g]));
            f = c.changedTouches.length;
            for (g = 0; g < f; g++)
                this.changedTouches.push(new a(c.changedTouches[g]))
        }
    };
    b.prototype = {getTouchById: function(a, b) {
            var c, f = b.length;
            for (c = 0; c < f; c++)
                if (b[c].id === a)
                    return b[c];
            return null
        }};
    var a = function(a) {
        var b = pc.input.getTouchTargetCoords(a);
        this.id = a.identifier;
        this.x = b.x;
        this.y = 
        b.y;
        this.target = a.target;
        this.touch = a
    }, c = function(a) {
        this._startHandler = this._handleTouchStart.bind(this);
        this._endHandler = this._handleTouchEnd.bind(this);
        this._moveHandler = this._handleTouchMove.bind(this);
        this._cancelHandler = this._handleTouchCancel.bind(this);
        this.attach(a);
        pc.extend(this, pc.events)
    };
    c.prototype = {attach: function(a) {
            this._element && this.detach();
            this._element = a;
            this._element.addEventListener("touchstart", this._startHandler, !1);
            this._element.addEventListener("touchend", this._endHandler, 
            !1);
            this._element.addEventListener("touchmove", this._moveHandler, !1);
            this._element.addEventListener("touchcancel", this._cancelHandler, !1)
        },detach: function() {
            this._element && (this._element.removeEventListener("touchstart", this._startHandler, !1), this._element.removeEventListener("touchend", this._endHandler, !1), this._element.removeEventListener("touchmove", this._moveHandler, !1), this._element.removeEventListener("touchcancel", this._cancelHandler, !1));
            this._element = null
        },_handleTouchStart: function(a) {
            this.fire("touchstart", 
            new b(this, a))
        },_handleTouchEnd: function(a) {
            this.fire("touchend", new b(this, a))
        },_handleTouchMove: function(a) {
            this.fire("touchmove", new b(this, a))
        },_handleTouchCancel: function(a) {
            this.fire("touchcancel", new b(this, a))
        }};
    return {EVENT_TOUCHSTART: "touchstart",EVENT_TOUCHEND: "touchend",EVENT_TOUCHMOVE: "touchmove",EVENT_TOUCHCANCEL: "touchcancel",getTouchTargetCoords: function(a) {
            for (var b = 0, c = 0, f = 0, j = 0, j = a.target; !(j instanceof HTMLElement); )
                j = j.parentNode;
            var f = j, k = 1, l = 1;
            "number" === typeof f.width && "number" === 
            typeof f.height && (k = f.width / f.offsetWidth, l = f.height / f.offsetHeight);
            do
                b += f.offsetLeft - f.scrollLeft, c += f.offsetTop - f.scrollTop;
            while (f = f.offsetParent);
            f = a.pageX - b;
            j = j.offsetHeight - (a.pageY - c);
            return {x: f * k,y: j * l}
        },TouchDevice: c}
}());
pc.extend(pc.input, function() {
    var b = function(a, b) {
        b = b || {};
        this._keyboard = b.keyboard || null;
        this._mouse = b.mouse || null;
        this._gamepads = b.gamepads || null;
        this._element = null;
        this._actions = {};
        this._axes = {};
        this._axesValues = {};
        a && this.attach(a)
    };
    b.prototype.attach = function(a) {
        this._element = a;
        this._keyboard && this._keyboard.attach(a);
        this._mouse && this._mouse.attach(a)
    };
    b.prototype.detach = function() {
        this._keyboard && this._keyboard.detach();
        this._mouse && this._mouse.detach();
        this._element = null
    };
    b.prototype.disableContextMenu = 
    function() {
        this._mouse || this._enableMouse();
        this._mouse.disableContextMenu()
    };
    b.prototype.enableContextMenu = function() {
        this._mouse || this._enableMouse();
        this._mouse.enableContextMenu()
    };
    b.prototype.update = function(a) {
        this._keyboard && this._keyboard.update(a);
        this._mouse && this._mouse.update(a);
        this._gamepads && this._gamepads.update(a);
        this._axesValues = {};
        for (key in this._axes)
            this._axesValues[key] = []
    };
    b.prototype.registerKeys = function(a, b) {
        this._keyboard || this._enableKeyboard();
        if (this._actions[a])
            throw Error(pc.string.format("Action: {0} already registered", 
            a));
        if ("undefined" === typeof b)
            throw Error("Invalid button");
        b.length || (b = [b]);
        this._actions[a] ? this._actions[a].push({type: pc.input.ACTION_KEYBOARD,keys: b}) : this._actions[a] = [{type: pc.input.ACTION_KEYBOARD,keys: b}]
    };
    b.prototype.registerMouse = function(a, b) {
        this._mouse || this._enableMouse();
        if ("undefined" === typeof b)
            throw Error("Invalid button");
        this._actions[a] ? this._actions[a].push({type: pc.input.ACTION_MOUSE,button: b}) : this._actions[a] = [{type: pc.input.ACTION_MOUSE,button: -b}]
    };
    b.prototype.registerPadButton = 
    function(a, b, d) {
        if ("undefined" === typeof d)
            throw Error("Invalid button");
        this._actions[a] ? this._actions[a].push({type: pc.input.ACTION_GAMEPAD,button: d,pad: b}) : this._actions[a] = [{type: pc.input.ACTION_GAMEPAD,button: d,pad: b}]
    };
    b.prototype.registerAxis = function(a) {
        var b = a.name;
        this._axes[b] || (this._axes[b] = []);
        var d = this._axes[b].push(b), a = a || {};
        a.pad = a.pad || pc.input.PAD_1;
        var e = function(e, f, j, k) {
            switch (f) {
                case "mousex":
                    e._mouse.on(pc.input.EVENT_MOUSEMOVE, function(a) {
                        e._axesValues[b][d] = a.dx / 10
                    });
                    break;
                case "mousey":
                    e._mouse.on(pc.input.EVENT_MOUSEMOVE, function(a) {
                        e._axesValues[b][d] = a.dy / 10
                    });
                    break;
                case "key":
                    e._axes[b].push(function() {
                        return e._keyboard.isPressed(k) ? j : 0
                    });
                    break;
                case "padrx":
                    e._axes[b].push(function() {
                        return e._gamepads.getAxis(a.pad, pc.input.PAD_R_STICK_X)
                    });
                    break;
                case "padry":
                    e._axes[b].push(function() {
                        return e._gamepads.getAxis(a.pad, pc.input.PAD_R_STICK_Y)
                    });
                    break;
                case "padlx":
                    e._axes[b].push(function() {
                        return e._gamepads.getAxis(a.pad, pc.input.PAD_L_STICK_X)
                    });
                    break;
                case "padly":
                    e._axes[b].push(function() {
                        return e._gamepads.getAxis(a.pad, 
                        pc.input.PAD_L_STICK_Y)
                    });
                    break;
                default:
                    throw Error("Unknown axis");
            }
        };
        e(this, a.positive, 1, a.positiveKey);
        (a.negativeKey || a.negative !== a.positive) && e(this, a.negative, -1, a.negativeKey)
    };
    b.prototype.isPressed = function(a) {
        if (!this._actions[a])
            return !1;
        for (var b, d = 0, e = this._actions[a].length, d = 0; d < e; ++d)
            switch (b = this._actions[a][d], b.type) {
                case pc.input.ACTION_KEYBOARD:
                    if (this._keyboard) {
                        var g, f = b.keys.length;
                        for (g = 0; g < f; g++)
                            if (this._keyboard.isPressed(b.keys[g]))
                                return !0
                    }
                    break;
                case pc.input.ACTION_MOUSE:
                    if (this._mouse && 
                    this._mouse.isPressed(b.button))
                        return !0;
                    break;
                case pc.input.ACTION_GAMEPAD:
                    if (this._gamepads && this._gamepads.isPressed(b.pad, b.button))
                        return !0
            }
        return !1
    };
    b.prototype.wasPressed = function(a) {
        if (!this._actions[a])
            return !1;
        for (var b = 0, d = this._actions[a].length, b = 0; b < d; ++b) {
            var e = this._actions[a][b];
            switch (e.type) {
                case pc.input.ACTION_KEYBOARD:
                    if (this._keyboard) {
                        var g, f = e.keys.length;
                        for (g = 0; g < f; g++)
                            if (this._keyboard.wasPressed(e.keys[g]))
                                return !0
                    }
                    break;
                case pc.input.ACTION_MOUSE:
                    if (this._mouse && this._mouse.wasPressed(e.button))
                        return !0;
                    break;
                case pc.input.ACTION_GAMEPAD:
                    if (this._gamepads && this._gamepads.wasPressed(e.pad, e.button))
                        return !0
            }
        }
        return !1
    };
    b.prototype.getAxis = function(a) {
        var b = 0;
        if (this._axes[a]) {
            var d, e = this._axes[a].length;
            for (d = 0; d < e; d++)
                if ("function" === pc.type(this._axes[a][d])) {
                    var g = this._axes[a][d]();
                    Math.abs(g) > Math.abs(b) && (b = g)
                } else
                    this._axesValues[a] && Math.abs(this._axesValues[a][d]) > Math.abs(b) && (b = this._axesValues[a][d])
        }
        return b
    };
    b.prototype._enableMouse = function() {
        this._mouse = new pc.input.Mouse;
        if (!this._element)
            throw Error("Controller must be attached to a DOMElement");
        this._mouse.attach(this._element)
    };
    b.prototype._enableKeyboard = function() {
        this._keyboard = new pc.input.Keyboard;
        if (!this._element)
            throw Error("Controller must be attached to a DOMElement");
        this._keyboard.attach(this._element)
    };
    return {ACTION_MOUSE: "mouse",ACTION_KEYBOARD: "keyboard",ACTION_GAMEPAD: "gamepad",AXIS_MOUSE_X: "mousex",AXIS_MOUSE_Y: "mousey",AXIS_PAD_L_X: "padlx",AXIS_PAD_L_Y: "padly",AXIS_PAD_R_X: "padrx",AXIS_PAD_R_Y: "padry",AXIS_KEY: "key",Controller: b}
}());
pc.net = function() {
    return {}
}();
pc.extend(pc.net, function() {
    var b = function() {
    };
    b.ContentType = {FORM_URLENCODED: "application/x-www-form-urlencoded",GIF: "image/gif",JPEG: "image/jpeg",JSON: "application/json",PNG: "image/png",TEXT: "text/plain",XML: "application/xml",WAV: "audio/x-wav",OGG: "audio/ogg",MP3: "audio/mpeg",BIN: "application/octet-stream"};
    b.ResponseType = {TEXT: "text",ARRAY_BUFFER: "arraybuffer",BLOB: "blob",DOCUMENT: "document"};
    b.binaryExtensions = [".model", ".wav", ".ogg", ".mp3"];
    b.prototype = {ContentType: b.ContentType,ResponseType: b.ResponseType,
        binaryExtensions: b.binaryExtensions,get: function(a, b, d, e) {
            d = d || {};
            d.success = b;
            return this.request("GET", a, d, e)
        },post: function(a, b, d, e, g) {
            e = e || {};
            e.success = b;
            e.postdata = d;
            return this.request("POST", a, e, g)
        },put: function(a, b, d, e, g) {
            e = e || {};
            e.success = b;
            e.postdata = d;
            return this.request("PUT", a, e, g)
        },del: function(a, b, d, e) {
            d = d || {};
            d.success = b;
            return this.request("DELETE", a, d, e)
        },request: function(a, c, d, e) {
            var g, f, j, k = !1, d = d || {};
            null == d.success && (d.success = function() {
            });
            null == d.error && (d.error = function() {
            });
            null == d.async && (d.async = !0);
            null == d.headers && (d.headers = {});
            if (null != d.postdata)
                if (d.postdata instanceof Document)
                    j = d.postdata;
                else if (d.postdata instanceof FormData)
                    j = d.postdata;
                else if (d.postdata instanceof Object)
                    switch (j = d.headers["Content-Type"], pc.isDefined(j) || (d.headers["Content-Type"] = b.ContentType.FORM_URLENCODED, j = d.headers["Content-Type"]), j) {
                        case b.ContentType.FORM_URLENCODED:
                            j = "";
                            f = !0;
                            for (g in d.postdata)
                                d.postdata.hasOwnProperty(g) && (f ? f = !1 : j += "&", j += escape(g) + "=" + escape(d.postdata[g]));
                            break;
                        default:
                            null == j && (d.headers["Content-Type"] = b.ContentType.JSON), j = JSON.stringify(d.postdata)
                    }
                else
                    j = d.postdata;
            e || (e = new XMLHttpRequest);
            !1 === d.cache && (f = pc.time.now(), g = new pc.URI(c), g.query = g.query ? g.query + "&ts=" + f : "ts=" + f, c = g.toString());
            d.query && (g = new pc.URI(c), f = pc.extend(g.getQuery(), d.query), g.setQuery(f), c = g.toString());
            e.open(a, c, d.async);
            e.withCredentials = !0;
            e.responseType = d.responseType || this.guessResponseType(c);
            for (var l in d.headers)
                d.headers.hasOwnProperty(l) && e.setRequestHeader(l, 
                d.headers[l]);
            e.onreadystatechange = function() {
                this.onReadyStateChange(a, c, d, e)
            }.bind(this);
            e.onerror = function() {
                this.onError(a, c, d, e);
                k = !0
            }.bind(this);
            try {
                e.send(j)
            } catch (m) {
                k || d.error(e.status, e, m)
            }
            return e
        },guessResponseType: function(a) {
            a = new pc.URI(a);
            a = pc.path.getExtension(a.path);
            return 0 <= b.binaryExtensions.indexOf(a) ? b.ResponseType.ARRAY_BUFFER : b.ResponseType.TEXT
        },isBinaryContentType: function(a) {
            return 0 <= [b.ContentType.WAV, b.ContentType.OGG, b.ContentType.MP3, b.ContentType.BIN].indexOf(a) ? 
            !0 : !1
        },onReadyStateChange: function(a, b, d, e) {
            if (4 === e.readyState)
                switch (e.status) {
                    case 0:
                        break;
                    case 200:
                    case 201:
                    case 206:
                    case 304:
                        this.onSuccess(a, b, d, e);
                        break;
                    default:
                        this.onError(a, b, d, e)
                }
        },onSuccess: function(a, c, d, e) {
            var g;
            if (a = e.getResponseHeader("Content-Type"))
                a = a.split(";"), g = a[0].trim(), a[1] && a[1].trim();
            g === this.ContentType.JSON || pc.string.endsWith(c, ".json") ? c = JSON.parse(e.responseText) : this.isBinaryContentType(g) ? c = e.response : e.responseType === b.ResponseType.DOCUMENT || g === this.ContentType.XML ? 
            c = e.responseXML : e.responseType === b.ResponseType.ARRAY_BUFFER ? (logWARNING(pc.string.format("responseType: {0} being served with Content-Type: {1}", b.ResponseType.ARRAY_BUFFER, g)), c = e.response) : c = e.responseText;
            d.success(c, e.status, e)
        },onError: function(a, b, d, e) {
            d.error(e.status, e, null)
        }};
    b.prototype.delete_ = b.prototype.del;
    return {Http: b,http: new b}
}());
pc.extend(pc.net, function() {
    var b = 0, a = function(a, b, e, g, f) {
        this.clientId = g;
        this.endpoint = a;
        this.redirectUrl = b;
        this.origin = e;
        this.scope = f;
        this.responseType = "token";
        this.accessToken = null;
        this.OAUTH_IFRAME_ID_BASE = "pc-oauth-access-token-"
    }, a = pc.inherits(a, pc.net.Http);
    a.prototype.refreshAccessToken = function(a) {
        var d = this.OAUTH_IFRAME_ID_BASE + b++, e = function(b) {
            if (b.origin === this.origin) {
                if (b.data.access_token) {
                    var g = document.getElementById(d);
                    g && g.parentNode.removeChild(g);
                    this.accessToken = b.data.access_token;
                    a(b.data.access_token)
                } else
                    b.data.error ? logERROR(b.data.error) : logWARNING("Invalid message posted to Corazon API");
                window.removeEventListener("message", e)
            }
        }.bind(this);
        window.addEventListener("message", e, !1);
        var g = {client_id: this.clientId,redirect_url: this.redirectUrl,scope: this.scope,response_type: this.responseType}, f = new pc.URI(this.endpoint);
        f.setQuery(g);
        if (g = document.getElementById(d))
            throw Error("accessToken request already in progress");
        g = document.createElement("iframe");
        g.src = f.toString();
        g.id = d;
        g.style.display = "none";
        document.body.appendChild(g)
    };
    a.prototype.request = function(a, b, e, g) {
        e.query = e.query || {};
        e.query = pc.extend(e.query, {access_token: this.accessToken});
        return pc.net.OAuth._super.request.call(this, a, b, e, g)
    };
    a.prototype.onError = function(a, b, e, g) {
        401 == g.status ? this.refreshAccessToken(function(f) {
            e.query.access_token = f;
            this.request(a, b, e, g)
        }.bind(this)) : e.error(g.status, g, null)
    };
    return {OAuth: a,oauth: new a}
}());
pc.extend(pc.net, function() {
    var b = function(a) {
        this._ws = new WebSocket(a);
        this._ws.onopen = this._handleOpen.bind(this);
        this._ws.onerror = this._handleError.bind(this);
        this._ws.onmessage = this._handleMessage.bind(this);
        this._ws.onclose = this._handleClose.bind(this)
    };
    b.prototype = {onopen: null,onerror: null,onmessage: null,get binaryType() {
            return this._ws.binaryType
        },set binaryType(a) {
            this._ws.binaryType = a
        },get readyState() {
            return this._ws.readyState
        },get bufferedAmount() {
            return this._ws.bufferedAmount
        },get extensions() {
            return this._ws.extensions
        },
        get protocol() {
            return this._ws.protocol
        },_handleOpen: function() {
            if (this.onopen)
                this.onopen()
        },_handleError: function(a) {
            if (this.onerror)
                this.onerror(a)
        },_handleMessage: function(a) {
            if (this.onmessage)
                this.onmessage(a)
        },_handleClose: function() {
            if (this.onclose)
                this.onclose()
        },send: function(a) {
            this._ws.send(a)
        }};
    return {Socket: b}
}());
pc.script = function() {
    var b = null, a = null, c = {main: function(a) {
            if (b)
                throw Error("'main' Object already registered");
            b = a
        },setLoader: function(b) {
            if (b && a)
                throw Error("pc.script already has loader object.");
            a = b
        },create: function(a, b) {
            this.fire("created", a, b)
        },start: function() {
            b()
        }};
    pc.extend(c, pc.events);
    return c
}();
pc.extend(pc.resources, function() {
    var b = function(a, b) {
        this._context = a;
        this._prefix = b || "";
        this._queue = [];
        this._pending = [];
        this._loaded = {};
        this._loading = null;
        pc.script.on("created", this._onScriptCreated, this)
    }, b = pc.inherits(b, pc.resources.ResourceHandler);
    b.prototype.load = function(a, b, e, g, f) {
        f = f || {};
        f.timeout = f.timeout || 6E4;
        var j = new pc.URI(a);
        j.path = pc.path.join(this._prefix, j.path);
        j = j.toString();
        this._loaded[j] ? !0 !== this._loaded[j] ? b(this._loaded[j]) : b(null) : this._loading ? this._queue.push({url: j.toString(),
            success: b,error: e,progress: g}) : this._addScriptTag(j.toString(), b, e, g);
        f.timeout && setTimeout(function() {
            this._loaded[j] || e(pc.string.format("Loading script {0} timed out after {1}s", j, f.timeout / 1E3))
        }.bind(this), f.timeout)
    };
    b.prototype.open = function(a) {
        return a
    };
    b.prototype._onScriptCreated = function(a, b) {
        this._pending.push({name: a,callback: b})
    };
    b.prototype._addScriptTag = function(a, b, e) {
        var g = this, f = document.getElementsByTagName("head")[0], j = document.createElement("script");
        this._loading = j;
        j.addEventListener("error", 
        function(a) {
            e(pc.string.format("Error loading script from '{0}'", a.target.src))
        });
        var k = !1;
        j.onload = j.onreadystatechange = function() {
            if (!k && (!this.readyState || "loaded" == this.readyState || "complete" == this.readyState)) {
                k = !0;
                var e = g._pending.shift();
                if (e) {
                    var f = e.callback(g._context);
                    if (f._pcScriptName)
                        throw Error("Attribute _pcScriptName is reserved on ScriptTypes for ResourceLoader use");
                    f._pcScriptName = e.name;
                    g._loaded[a] = f;
                    b(f)
                } else
                    g._loaded[a] = !0, b(null);
                g._loading = null;
                g._queue.length && (e = g._queue.shift(), 
                g._addScriptTag(e.url, e.success, e.error, e.progress))
            }
        };
        j.src = a;
        f.appendChild(j)
    };
    var a;
    a = pc.inherits(function() {
    }, pc.resources.ResourceRequest);
    a.prototype.type = "script";
    return {ScriptResourceHandler: b,ScriptRequest: a}
}());
pc.fw = {};
var editor = editor || {};
pc.extend(editor, function() {
    var b = function() {
        this.exposed = {};
        this.added = {};
        this.scripts = {};
        this.systems = []
    };
    b.prototype = {addComponentType: function() {
        },expose: function() {
        },add: function() {
        },scriptexpose: function() {
        }};
    return {LinkInterface: b,link: new b}
}());
pc.extend(editor, function() {
    var b = function() {
        this.exposed = {};
        this.added = {};
        this.scripts = {};
        this.systems = []
    };
    b.prototype.addComponentType = function(a) {
        0 > this.systems.indexOf(a) && this.systems.push(a);
        this.exposed[a] || (this.exposed[a] = {})
    };
    b.prototype.expose = function(a, b) {
        if (!b.name)
            throw Error("Missing option 'name'");
        b.options = b.options || {};
        this.exposed[a][b.name] || (this.exposed[a][b.name] = {});
        this.exposed[a][b.name] = b
    };
    b.prototype.add = function(a) {
        logASSERT(a.system, "Missing option: 'system'");
        logASSERT(a.variable, 
        "Missing option: 'variable'");
        this.added[a.system] || (this.added[a.system] = {});
        this.added[a.system][a.variable] || (this.added[a.system][a.variable] = {});
        this.added[a.system][a.variable] = a
    };
    b.prototype.scriptexpose = function(a) {
        this.scripts[a.script] = a
    };
    return {LinkInterface: b,link: new b}
}());
pc.extend(pc.fw, function() {
    return {ContentFile: function(b) {
            this.packs = b.packs || {};
            this.appProperties = b.application_properties || {};
            this.toc = b.toc || {}
        }}
}());
pc.extend(pc.fw, function() {
    return {loadPack: function(b, a, c, d, e) {
            var g = new pc.resources.PackRequest(b);
            a.loader.request(g, function(d) {
                d = d[b];
                a.root.addChild(d.hierarchy);
                pc.fw.ComponentSystem.initialize(d.hierarchy);
                c && c(d)
            }.bind(this), function(a) {
                d && d(a)
            }.bind(this), function(a) {
                e && e(a)
            }.bind(this))
        }}
}());
pc.extend(pc.fw, function() {
    return {ApplicationContext: function(b, a, c, d) {
            this.loader = b;
            this.scene = a;
            this.root = new pc.fw.Entity;
            b = d.depot ? d.depot.assets.getServer().getBaseUrl() : null;
            this.assets = new pc.fw.AssetCache(b);
            this.systems = c;
            d = d || {};
            this.controller = d.controller;
            this.keyboard = d.keyboard;
            this.mouse = d.mouse;
            this.gamepads = d.gamepads
        }}
}());
pc.extend(pc.fw, function() {
    var b, a = function(b, c) {
        this._inTools = !1;
        pc.extend(this, pc.events);
        this.content = c.content;
        this.canvas = b;
        this.fillMode = pc.fw.FillMode.KEEP_ASPECT;
        this.resolutionMode = pc.fw.ResolutionMode.FIXED;
        this.librariesLoaded = !1;
        this._link = new pc.fw.LiveLink("application");
        this._link.addDestinationWindow(window);
        this._link.listen(this._handleMessage.bind(this));
        pc.log.open();
        this.graphicsDevice = new pc.gfx.Device(b);
        pc.gfx.Device.setCurrent(this.graphicsDevice);
        pc.gfx.post.initialize();
        this.graphicsDevice.enableValidation(!1);
        var d = new pc.fw.ComponentSystemRegistry;
        this.audioManager = new pc.audio.AudioManager;
        var j = new pc.resources.ResourceLoader, k = new pc.resources.TextureCache(j);
        j.registerHandler(pc.resources.ImageRequest, new pc.resources.ImageResourceHandler);
        j.registerHandler(pc.resources.ModelRequest, new pc.resources.ModelResourceHandler(k));
        j.registerHandler(pc.resources.AnimationRequest, new pc.resources.AnimationResourceHandler);
        j.registerHandler(pc.resources.PackRequest, 
        new pc.resources.PackResourceHandler(d, c.depot));
        j.registerHandler(pc.resources.AudioRequest, new pc.resources.AudioResourceHandler(this.audioManager));
        c.displayLoader && new pc.resources.ResourceLoaderDisplay(document.body, j);
        this.context = new pc.fw.ApplicationContext(j, new pc.scene.Scene, d, c);
        j.registerHandler(pc.resources.ScriptRequest, new pc.resources.ScriptResourceHandler(this.context, c.scriptPrefix));
        new pc.fw.AnimationComponentSystem(this.context);
        new pc.fw.BloomComponentSystem(this.context);
        new pc.fw.ModelComponentSystem(this.context);
        new pc.fw.CameraComponentSystem(this.context);
        new pc.fw.CubeMapComponentSystem(this.context);
        new pc.fw.StaticCubeMapComponentSystem(this.context);
        new pc.fw.DirectionalLightComponentSystem(this.context);
        new pc.fw.PointLightComponentSystem(this.context);
        new pc.fw.SpotLightComponentSystem(this.context);
        new pc.fw.PrimitiveComponentSystem(this.context);
        new pc.fw.PackComponentSystem(this.context);
        new pc.fw.SkyboxComponentSystem(this.context);
        new pc.fw.ScriptComponentSystem(this.context);
        new pc.fw.PickComponentSystem(this.context);
        new pc.fw.AudioSourceComponentSystem(this.context, this.audioManager);
        new pc.fw.AudioListenerComponentSystem(this.context, this.audioManager);
        new pc.fw.DesignerComponentSystem(this.context);
        this.on("librariesloaded", this.onLibrariesLoaded, this);
        c.libraries && c.libraries.length ? (d = c.libraries.map(function(a) {
            return new pc.resources.ScriptRequest(a)
        }), j.request(d, function() {
            this.fire("librariesloaded", this);
            this.librariesLoaded = !0
        }.bind(this), function() {
        })) : (this.fire("librariesloaded", this), this.librariesLoaded = 
        !0);
        "undefined" !== typeof document.hidden ? (this._hiddenAttr = "hidden", document.addEventListener("visibilitychange", this.onVisibilityChange.bind(this), !1)) : "undefined" !== typeof document.mozHidden ? (this._hiddenAttr = "mozHidden", document.addEventListener("mozvisibilitychange", this.onVisibilityChange.bind(this), !1)) : "undefined" !== typeof document.msHidden ? (this._hiddenAttr = "msHidden", document.addEventListener("msvisibilitychange", this.onVisibilityChange.bind(this), !1)) : "undefined" !== typeof document.webkitHidden && 
        (this._hiddenAttr = "webkitHidden", document.addEventListener("webkitvisibilitychange", this.onVisibilityChange.bind(this), !1));
        a._applications[this.canvas.id] = this
    };
    a._applications = {};
    a.getApplication = function(b) {
        return a._applications[b]
    };
    a.prototype = {loadFromToc: function(a, b, c, d) {
            this.content || c("No content");
            var k = this.content.toc[a], b = b || function() {
            }, c = c || function() {
            }, d = d || function() {
            }, l = [];
            this.context.assets.update(k, this.context.loader);
            for (guid in k.assets) {
                var m = this.context.assets.getAsset(guid);
                l.push(this.context.loader.createFileRequest(m.getFileUrl(), m.file.type));
                m.subfiles.forEach(function(a, b) {
                    l.push(this.context.loader.createFileRequest(m.getSubAssetFileUrl(b), a.type))
                }.bind(this))
            }
            var h = function() {
                guid = k.packs[0];
                var a = new pc.resources.PackRequest(guid);
                this.context.loader.request(a, function(a) {
                    var c = a[guid];
                    this.context.root.addChild(c.hierarchy);
                    pc.fw.ComponentSystem.initialize(c.hierarchy);
                    b(a[guid])
                }.bind(this), c, d)
            }.bind(this), n = function() {
                l.length ? this.context.loader.request(l, 
                function(a) {
                    h(a)
                }.bind(this), c, d) : setTimeout(function() {
                    h([])
                }, 0)
            }.bind(this);
            if (this.librariesLoaded)
                n();
            else
                this.on("librariesloaded", function() {
                    n()
                })
        },loadPack: function(a, b, c, d) {
            var k = function() {
                var k = new pc.resources.PackRequest(a);
                this.context.loader.request(k, function(c) {
                    c = c[a];
                    this.context.root.addChild(c.hierarchy);
                    pc.fw.ComponentSystem.initialize(c.hierarchy);
                    b && b(c)
                }.bind(this), function(a) {
                    c && c(a)
                }.bind(this), function(a) {
                    d && d(a)
                }.bind(this))
            }.bind(this);
            if (this.librariesLoaded)
                k();
            else
                this.on("librariesloaded", 
                function() {
                    k()
                })
        },start: function() {
            if (this.librariesLoaded)
                this.tick();
            else
                this.on("librariesloaded", function() {
                    this.tick()
                }, this)
        },update: function(a) {
            var b = this.context;
            pc.fw.ComponentSystem.fixedUpdate(1 / 60, b, this._inTools);
            pc.fw.ComponentSystem.update(a, b, this._inTools);
            pc.fw.ComponentSystem.postUpdate(a, b, this._inTools);
            this.fire("update", a);
            b.controller && b.controller.update(a);
            b.mouse && b.mouse.update(a);
            b.keyboard && b.keyboard.update(a);
            b.gamepads && b.gamepads.update(a)
        },render: function() {
            var a = 
            this.context;
            a.root.syncHierarchy();
            pc.gfx.Device.setCurrent(this.graphicsDevice);
            var b = a.systems.camera.current;
            b && (a.systems.camera.frameBegin(), a.scene.render(b.camera.camera), a.systems.camera.frameEnd())
        },tick: function() {
            requestAnimationFrame(this.tick.bind(this), this.canvas);
            var a = (new Date).getTime(), c = (a - (b || a)) / 1E3;
            b = a;
            c = pc.math.clamp(c, 0, 0.1);
            this.update(c);
            this.render()
        },setCanvasFillMode: function(a, b, c) {
            this.fillMode = a;
            this.resizeCanvas(b, c)
        },setCanvasResolution: function(a, b, c) {
            this.resolutionMode = 
            a;
            a === pc.fw.ResolutionMode.AUTO && (b = this.canvas.clientWidth, c = this.canvas.clientHeight);
            this.canvas.width = b;
            this.canvas.height = c
        },isFullscreen: function() {
            return !!document.fullscreenElement
        },enableFullscreen: function(a, b, c) {
            var a = a || this.canvas, d = function() {
                b();
                document.removeEventListener("fullscreenchange", d)
            }, k = function() {
                c();
                document.removeEventListener("fullscreenerror", k)
            };
            b && document.addEventListener("fullscreenchange", d, !1);
            c && document.addEventListener("fullscreenerror", k, !1);
            a.requestFullscreen()
        },
        disableFullscreen: function(a) {
            var b = function() {
                a();
                document.removeEventListener("fullscreenchange", b)
            };
            a && document.addEventListener("fullscreenchange", b, !1);
            document.exitFullscreen()
        },isHidden: function() {
            return document[this._hiddenAttr]
        },onVisibilityChange: function() {
            this.isHidden() ? this.audioManager.suspend() : this.audioManager.resume()
        },resizeCanvas: function(a, b) {
            var c = window.innerWidth, d = window.innerHeight;
            if (this.fillMode === pc.fw.FillMode.KEEP_ASPECT) {
                var k = this.canvas.width / this.canvas.height;
                k > c / d ? (a = c, b = a / k) : (b = d, a = b * k)
            } else
                this.fillMode === pc.fw.FillMode.FILL_WINDOW && (a = c, b = d);
            this.canvas.style.width = a + "px";
            this.canvas.style.height = b + "px";
            this.resolutionMode === pc.fw.ResolutionMode.AUTO && this.setCanvasResolution(pc.fw.ResolutionMode.AUTO);
            return {width: a,height: b}
        },onLibrariesLoaded: function() {
            new pc.fw.Body2dComponentSystem(this.context);
            new pc.fw.CollisionRectComponentSystem(this.context);
            new pc.fw.CollisionCircleComponentSystem(this.context);
            new pc.fw.RigidBodyComponentSystem(this.context);
            new pc.fw.CollisionBoxComponentSystem(this.context);
            new pc.fw.CollisionSphereComponentSystem(this.context)
        },_handleMessage: function(a) {
            switch (a.type) {
                case pc.fw.LiveLinkMessageType.UPDATE_COMPONENT:
                    this._linkUpdateComponent(a.content.id, a.content.component, a.content.attribute, a.content.value);
                    break;
                case pc.fw.LiveLinkMessageType.UPDATE_ENTITY:
                    this._linkUpdateEntity(a.content.id, a.content.components);
                    break;
                case pc.fw.LiveLinkMessageType.UPDATE_ENTITY_TRANSFORM:
                    this._linkUpdateEntityTransform(a.content.id, 
                    a.content.position, a.content.rotation, a.content.scale);
                    break;
                case pc.fw.LiveLinkMessageType.UPDATE_ENTITY_NAME:
                    var b = this.context.root.findOne("getGuid", a.content.id);
                    b.setName(a.content.name);
                    break;
                case pc.fw.LiveLinkMessageType.REPARENT_ENTITY:
                    this._linkReparentEntity(a.content.id, a.content.newParentId, a.content.index);
                    break;
                case pc.fw.LiveLinkMessageType.CLOSE_ENTITY:
                    if (b = this.context.root.findOne("getGuid", a.content.id))
                        logDEBUG(pc.string.format("RT: Removed '{0}' from parent {1}", a.content.id, 
                        b.getParent().getGuid())), b.destroy();
                    break;
                case pc.fw.LiveLinkMessageType.OPEN_ENTITY:
                    var c = {}, d = null;
                    if (a.content.entity)
                        if (b = {application_data: {},hierarchy: a.content.entity}, b = this.context.loader.open(pc.resources.PackRequest, b), b = b.hierarchy, b.__parent) {
                            var k = this.context.root.findByGuid(b.__parent);
                            k.addChild(b)
                        } else
                            this.context.root.addChild(b);
                    if (a.content.models) {
                        for (var l = a.content.models.length, k = 0; k < l; k++)
                            b = this.context.loader.open(pc.resources.EntityRequest, a.content.models[k]), c[b.getGuid()] = 
                            b;
                        for (d in c)
                            c.hasOwnProperty(d) && (pc.resources.EntityResourceHandler.patchChildren(c[d], c), c[d].__parent ? c[c[d].__parent] || (k = this.context.root.findByGuid(c[d].__parent), k.addChild(c[d])) : this.context.root.addChild(c[d]))
                    }
            }
        },_linkUpdateComponent: function(a, b, c, d) {
            (a = this.context.root.findOne("getGuid", a)) && (b ? a[b] ? a[b][c] = d : logWARNING(pc.string.format("No component system called '{0}' exists", b)) : a[c] = d)
        },_linkUpdateEntityTransform: function(a, b, c, d) {
            if (a = this.context.root.findByGuid(a))
                a.setLocalPosition(b), 
                a.setLocalEulerAngles(c), a.setLocalScale(d), a.fire("livelink:updatetransform", b, c, d)
        },_linkReparentEntity: function(a, b) {
            var c = this.context.root.findByGuid(a), d = this.context.root.findByGuid(b);
            c.reparent(d)
        },_linkUpdateEntity: function(a, b) {
            var c, d = this.context.root.findOne("getGuid", a);
            if (d) {
                var k = this.context.systems.getComponentSystemOrder(), l, m = k.length;
                for (l = 0; l < m; l++)
                    c = k[l], b.hasOwnProperty(c) && this.context.systems.hasOwnProperty(c) && (d[c] || this.context.systems[c].addComponent(d, {}));
                for (c in this.context.systems)
                    "gizmo" === 
                    c || "pick" === c || this.context.systems.hasOwnProperty(c) && !b.hasOwnProperty(c) && d[c] && this.context.systems[c].removeComponent(d)
            }
        }};
    if ("undefined" !== typeof document) {
        var c = function() {
            var a = document.createEvent("CustomEvent");
            a.initCustomEvent("fullscreenchange", !0, !1, null);
            document.dispatchEvent(a)
        }, d = function() {
            var a = document.createEvent("CustomEvent");
            a.initCustomEvent("fullscreenerror", !0, !1, null);
            document.dispatchEvent(a)
        };
        document.addEventListener("webkitfullscreenchange", c, !1);
        document.addEventListener("mozfullscreenchange", 
        c, !1);
        document.addEventListener("webkitfullscreenerror", d, !1);
        document.addEventListener("mozfullscreenerror", d, !1);
        Element.prototype.requestFullscreen = Element.prototype.mozRequestFullScreen ? function() {
            this.mozRequestFullScreen()
        } : Element.prototype.requestFullscreen || Element.prototype.webkitRequestFullscreen || function() {
        };
        document.exitFullscreen = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen;
        document.fullscreenElement || Object.defineProperty(document, "fullscreenElement", 
        {enumerable: !0,configurable: !1,get: function() {
                return document.webkitCurrentFullScreenElement || document.webkitFullscreenElement || document.mozFullScreenElement
            }});
        document.fullscreenEnabled || Object.defineProperty(document, "fullscreenEnabled", {enumerable: !0,configurable: !1,get: function() {
                return document.webkitFullscreenEnabled || document.mozFullScreenEnabled
            }})
    }
    return {FillMode: {NONE: "NONE",FILL_WINDOW: "FILL_WINDOW",KEEP_ASPECT: "KEEP_ASPECT"},ResolutionMode: {AUTO: "AUTO",FIXED: "FIXED"},Application: a}
}());
pc.extend(pc.resources, function() {
    var b = function(a, b) {
        this._registry = a;
        this._depot = b
    }, b = pc.inherits(b, pc.resources.ResourceHandler);
    b.prototype.load = function(a, b, e, g, f) {
        f = f || {};
        a in pc.content.packs ? setTimeout(function() {
            b(pc.content.packs[a], f)
        }, 0) : this._depot.packs.getOne(a, function(a) {
            b(a, f)
        }.bind(this), function(a) {
            e(a)
        })
    };
    b.prototype.open = function(a, b) {
        return this.openPack(a, b)
    };
    b.prototype.openPack = function(a, b) {
        b = b || {};
        b.priority = b.priority || 1;
        b.batch = b.batch || null;
        return {application_data: a.application_data,
            hierarchy: this.openEntity(a.hierarchy, b)}
    };
    b.prototype.openEntity = function(a, b) {
        var e;
        e = this.openEntityHierarchy(a, b);
        e.syncHierarchy();
        return e = this.openComponentData(e, a, b)
    };
    b.prototype.openEntityHierarchy = function(a, b) {
        var e = new pc.fw.Entity;
        e.setName(a.name);
        e.setGuid(a.resource_id);
        e.setLocalPosition(a.position);
        e.setLocalEulerAngles(a.rotation);
        e.setLocalScale(a.scale);
        a.labels && a.labels.forEach(function(a) {
            e.addLabel(a)
        });
        e.__parent = a.parent;
        e.__children = a.children;
        e.name = a.name;
        e.template = 
        a.template;
        var g, f, j = a.children.length;
        for (g = 0; g < j; g++)
            f = this.openEntityHierarchy(a.children[g], b), e.addChild(f);
        return e
    };
    b.prototype.openComponentData = function(a, b, e) {
        a.setRequestBatch(e.batch);
        var g = this._registry.list(), f, j = g.length;
        for (f = 0; f < j; f++) {
            var k = b.components[g[f].id];
            k && this._registry[g[f].id].addComponent(a, k)
        }
        a.setRequestBatch(null);
        g = b.children.length;
        j = a.getChildren();
        for (f = 0; f < g; f++)
            j[f] = this.openComponentData(j[f], b.children[f], e);
        return a
    };
    var a;
    a = pc.inherits(function() {
    }, pc.resources.ResourceRequest);
    a.prototype.type = "pack";
    return {PackResourceHandler: b,PackRequest: a}
}());
pc.extend(pc.resources, function() {
    var b = function(a, b) {
        this._registry = a;
        this._depot = b
    }, b = pc.inherits(b, pc.resources.ResourceHandler);
    b.prototype.load = function(a, b, e, g, f) {
        f = f || {};
        a in pc.content.data ? setTimeout(function() {
            b(pc.content.data[a], f)
        }, 0) : this._depot.entities.getOne(a, function(a) {
            b(a, f)
        }.bind(this), function(a) {
            e(a)
        })
    };
    b.prototype.open = function(a, b) {
        var e = a.resource_id, b = b || {};
        b.priority = b.priority || 1;
        b.batch = b.batch || null;
        var g = new pc.fw.Entity;
        g.setName(a.name);
        g.setGuid(e);
        g.setLocalPosition(a.position);
        g.setLocalEulerAngles(a.rotation);
        g.setLocalScale(a.scale);
        a.labels && a.labels.forEach(function(a) {
            g.addLabel(a)
        });
        g.__parent = a.parent;
        g.__children = a.children;
        g._rev = a._rev;
        g.version = a.version;
        g.name = a.name;
        g.template = a.template;
        g.setRequestBatch(b.batch);
        var e = this._registry.getComponentSystemOrder(), f, j = e.length;
        for (f = 0; f < j; f++) {
            var k = a.components[e[f]];
            k && new this._registry[e[f]].addComponent(g, k)
        }
        g.setRequestBatch(null);
        return g
    };
    b.prototype.postOpen = function(a, d, e, g, f) {
        if (a.__children.length) {
            var j = 
            [];
            a.__children.forEach(function(a) {
                j.push(new pc.resources.EntityRequest(a))
            });
            a.setRequestBatch(f.batch);
            this._loader.request(j, f.priority, function(e) {
                b.patchChildren(a, e);
                d(a)
            }.bind(this), function(a) {
                e(a)
            }, function(a) {
                g(a)
            }, f);
            a.setRequestBatch(null)
        } else
            d(a)
    };
    b.patchChildren = function(a, b) {
        var e;
        for (i = 0; i < a.__children.length; ++i)
            e = b[a.__children[i]], a.addChild(e);
        delete a.__children
    };
    var a;
    a = pc.inherits(function() {
    }, pc.resources.ResourceRequest);
    a.prototype.type = "entity";
    return {EntityResourceHandler: b,
        EntityRequest: a}
}());
pc.extend(pc.resources, function() {
    var b = function(a) {
        this._depot = a
    }, b = pc.inherits(b, pc.resources.ResourceHandler);
    b.prototype.load = function(a, b, e, g, f) {
        a in pc.content.data ? setTimeout(function() {
            b(pc.content.data[a], f)
        }, 0) : this._depot.assets.getOne(a, function(a) {
            b(a, f)
        }.bind(this))
    };
    b.prototype.open = function(a) {
        var b = "";
        this._depot && (b = this._depot.assets.getServer().getBaseUrl());
        a = new pc.fw.Asset(b, a);
        this.registerAssetHashes(a);
        return a
    };
    b.prototype.registerAssetHashes = function(a) {
        this._loader.registerHash(a.file.hash, 
        a.getFileUrl());
        var b, e = a.subasset_files.length;
        for (b = 0; b < e; b++)
            this._loader.registerHash(a.subasset_files[b].hash, a.getSubAssetFileUrl(b))
    };
    var a;
    a = pc.inherits(function() {
    }, pc.resources.ResourceRequest);
    a.prototype.type = "asset";
    return {AssetRequest: a,AssetResourceHandler: b}
}());
pc.extend(pc.fw, function() {
    var b = function() {
    };
    b.prototype = {add: function(a, b) {
            if (this[a])
                throw Error(pc.string.format("ComponentSystem name '{0}' already registered or not allowed", a));
            this[a] = b;
            b.name = a
        },remove: function(a) {
            if (!this[a])
                throw Error(pc.string.format("No ComponentSystem named '{0}' registered", a));
            delete this[a]
        },list: function() {
            var a = Object.keys(this), b = {collisionrect: 0.5,collisioncircle: 0.5};
            a.sort(function(a, e) {
                var g = b[a] || 1, f = b[e] || 1;
                return g < f ? -1 : g > f ? 1 : 0
            });
            return a.map(function(a) {
                return this[a]
            }, 
            this)
        },getComponentSystemOrder: function() {
            var a = Object.keys(this), b = a.indexOf("collisionrect");
            a.splice(b, 1);
            a.unshift("collisionrect");
            b = a.indexOf("collisioncircle");
            a.splice(b, 1);
            a.unshift("collisioncircle");
            return a
        }};
    return {ComponentSystemRegistry: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.context = a;
        this.dataStore = {};
        this.schema = [];
        pc.extend(this, pc.events)
    };
    pc.extend(b, {initialize: function(a) {
            b.fire("initialize", a)
        },update: function(a, c, d) {
            d ? b.fire("toolsUpdate", a) : b.fire("update", a)
        },fixedUpdate: function(a) {
            b.fire("fixedUpdate", a)
        },postUpdate: function(a) {
            b.fire("postUpdate", a)
        }});
    b.prototype = {get store() {
            return this.dataStore
        },addComponent: function(a, b) {
            var d = new this.ComponentType(this, a), e = new this.DataType, b = b || {};
            this.dataStore[a.getGuid()] = 
            {entity: a,data: e};
            a[this.id] = d;
            a.c[this.id] = d;
            this.initializeComponentData(d, b, []);
            this.fire("add", a, d);
            return d
        },removeComponent: function(a) {
            var b = this.dataStore[a.getGuid()];
            delete this.dataStore[a.getGuid()];
            delete a[this.id];
            delete a.c[this.id];
            this.fire("remove", a, b.data)
        },cloneComponent: function(a, b) {
            var d = this.dataStore[a.getGuid()];
            return this.addComponent(b, d.data)
        },initializeComponentData: function(a, b, d) {
            b = b || {};
            d.forEach(function(d) {
                a[d] = "undefined" !== typeof b[d] ? b[d] : a.data[d]
            }, this)
        },
        exposeProperties: function() {
            editor.link.addComponentType(this.id);
            this.schema.forEach(function(a) {
                !1 !== a.exposed && editor.link.expose(this.id, a)
            }.bind(this))
        }};
    pc.extend(b, pc.events);
    return {ComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a, b) {
        this.system = a;
        this.entity = b;
        pc.extend(this, pc.events);
        this.buildAccessors(this.system.schema);
        this.on("set", function(a, b, c) {
            this.fire("set_" + a, a, b, c)
        })
    };
    b.prototype = {get data() {
            var a = this.system.store[this.entity.getGuid()];
            return a ? a.data : null
        },buildAccessors: function(a) {
            a.forEach(function(a) {
                a.readOnly ? Object.defineProperty(this, a.name, {get: function() {
                        return this.data[a.name]
                    }}) : Object.defineProperty(this, a.name, {get: function() {
                        return this.data[a.name]
                    },
                    set: function(b) {
                        var e = this.data[a.name];
                        this.data[a.name] = b;
                        this.fire("set", a.name, e, b)
                    }})
            }.bind(this))
        }};
    return {Component: b}
}());
pc.extend(pc.fw, function() {
    return {ComponentData: function() {
        }}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set_animations", this.onSetAnimations, this);
        this.on("set_assets", this.onSetAssets, this);
        this.on("set_loop", this.onSetLoop, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {play: function(a, b) {
            if (this.data.animations[a]) {
                var b = b || 0, d = this.data;
                d.prevAnim = d.currAnim;
                d.currAnim = a;
                d.model && (d.blending = 0 < b, d.blending ? (d.blendTime = b, d.blendTimeRemaining = b, d.fromSkel.setAnimation(d.animations[d.prevAnim]), d.fromSkel.addTime(d.skeleton.getCurrentTime()), 
                d.toSkel.setAnimation(d.animations[d.currAnim]), d.toSkel.addTime(0)) : d.skeleton.setAnimation(d.animations[d.currAnim]));
                d.playing = !0
            } else
                console.error(pc.string.format("Trying to play animation '{0}' which doesn't exist", a))
        },getAnimation: function(a) {
            return this.data.animations[a]
        },setModel: function(a) {
            var b = this.data;
            if (a) {
                var d = a.getGraph();
                b.fromSkel = new pc.anim.Skeleton(d);
                b.toSkel = new pc.anim.Skeleton(d);
                b.skeleton = new pc.anim.Skeleton(d);
                b.skeleton.setLooping(b.loop);
                b.skeleton.setGraph(d)
            }
            b.model = 
            a;
            b.animations && (b.currAnim && b.animations[b.currAnim]) && this.play(b.currAnim)
        },loadAnimationAssets: function(a) {
            if (a && a.length) {
                var b = {batch: this.entity.getRequestBatch()}, d = [], e = a.map(function(a) {
                    return this.system.context.assets.getAsset(a)
                }, this).map(function(b) {
                    if (b)
                        return d.push(b.name), new pc.resources.AnimationRequest(b.getFileUrl());
                    logERROR(pc.string.format("Trying to load animation component before assets {0} are loaded", a))
                });
                this.system.context.loader.request(e, function(a) {
                    for (var b = {}, 
                    c = 0; c < e.length; c++)
                        b[d[c]] = a[e[c].identifier];
                    this.animations = b
                }.bind(this), function() {
                }, function() {
                }, b)
            }
        },onSetAnimations: function(a) {
            var b = this.data, d = this.entity.model;
            d && (d = d.model) && this.entity.animation.setModel(d);
            for (a in b.animations) {
                b.activate && this.play(a, 0);
                break
            }
        },onSetAssets: function(a, b, d) {
            this.loadAnimationAssets(d)
        },onSetLoop: function() {
            this.data.skeleton && this.data.skeleton.setLooping(this.data.loop)
        },onSetCurrentTime: function(a, b, d) {
            this.data.skeleton.setCurrentTime(d);
            this.data.skeleton.addTime(0);
            this.data.skeleton.updateGraph()
        }});
    Object.defineProperties(b.prototype, {currentTime: {get: function() {
                return this.data.skeleton.getCurrentTime()
            },set: function(a) {
                this.data.skeleton.setCurrentTime(a);
                this.data.skeleton.addTime(0);
                this.data.skeleton.updateGraph()
            }},duration: {get: function() {
                return this.data.animations[this.data.currAnim].getDuration()
            }}});
    return {AnimationComponent: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "animation";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.AnimationComponent;
        this.DataType = pc.fw.AnimationComponentData;
        this.schema = [{name: "assets",displayName: "Asset",description: "Animation Asset",type: "asset",options: {max: 100},defaultValue: null}, {name: "speed",displayName: "Speed Factor",description: "Scale the animation playback speed",type: "number",options: {min: 0,step: 0.1},defaultValue: 1}, {name: "loop",displayName: "Loop",description: "Loop the animation back to the start on completion",
                type: "boolean",defaultValue: !0}, {name: "activate",displayName: "Activate",description: "Play the configured animation on load",type: "boolean",defaultValue: !0}, {name: "animations",exposed: !1}, {name: "skeleton",exposed: !1,readOnly: !0}, {name: "model",exposed: !1,readOnly: !0}, {name: "prevAnim",exposed: !1,readOnly: !0}, {name: "currAnim",exposed: !1,readOnly: !0}, {name: "fromSkel",exposed: !1,readOnly: !0}, {name: "toSkel",exposed: !1,readOnly: !0}, {name: "blending",exposed: !1,readOnly: !0}, {name: "blendTime",exposed: !1,readOnly: !0}, 
            {name: "blendTimeRemaining",exposed: !1,readOnly: !0}, {name: "playing",exposed: !1,readOnly: !0}];
        this.exposeProperties();
        this.on("remove", this.onRemove, this);
        this.on("update", this.onUpdate, this);
        pc.fw.ComponentSystem.on("update", this.onUpdate, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(a, c, d) {
            d = ["activate", "loop", "speed", "assets"];
            b._super.initializeComponentData.call(this, a, c, d)
        },cloneComponent: function(a, b) {
            this.addComponent(b, {});
            b.animation.data.assets = 
            pc.extend([], a.animation.assets);
            b.animation.data.speed = a.animation.speed;
            b.animation.data.loop = a.animation.loop;
            b.animation.data.activate = a.animation.activate;
            b.animation.animations = pc.extend({}, a.animation.animations)
        },onRemove: function(a, b) {
            delete b.animation;
            delete b.skeleton;
            delete b.fromSkel;
            delete b.toSkel
        },onUpdate: function(a) {
            var b = this.store, d;
            for (d in b)
                if (b.hasOwnProperty(d)) {
                    var e = b[d].data;
                    if (e.playing) {
                        var g = e.skeleton;
                        null !== g && null !== e.model && (e.blending ? (e.blendTimeRemaining -= a, 
                        0 > e.blendTimeRemaining && (e.blendTimeRemaining = 0), g.blend(e.fromSkel, e.toSkel, 1 - e.blendTimeRemaining / e.blendTime)) : (g.addTime(a * e.speed), g.getCurrentTime() === g.getAnimation().getDuration() && !e.loop && (e.playing = !1)), e.blending && 0 === e.blendTimeRemaining && (e.blending = !1, g.setAnimation(e.toSkel.getAnimation())), g.updateGraph())
                    }
                }
        }});
    return {AnimationComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    function b() {
        this.assets = null;
        this.speed = 1;
        this.activate = this.loop = !0;
        this.toSkel = this.fromSkel = this.currAnim = this.prevAnim = this.model = this.skeleton = this.animations = null;
        this.blending = !1;
        this.blendTimeRemaining = this.blendTime = 0;
        this.playing = !1
    }
    b = pc.inherits(b, pc.fw.ComponentData);
    return {AnimationComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "bloom";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.BloomComponent;
        this.DataType = pc.fw.BloomComponentData;
        this.schema = [{name: "bloomThreshold",displayName: "Bloom Threshold",description: "The luminance threshold above which blooming is applied",type: "number",options: {max: 1,min: 0,step: 0.05},defaultValue: 0.25}, {name: "blurAmount",displayName: "Blur Amount",description: "The luminance threshold above which blooming is applied",type: "number",options: {max: 10,
                    min: 1,step: 0.5},defaultValue: 4}, {name: "bloomIntensity",displayName: "Bloom Intensity",description: "TBD",type: "number",options: {max: 3,min: 0,step: 0.05},defaultValue: 1.25}, {name: "baseIntensity",displayName: "Base Intensity",description: "TBD",type: "number",options: {max: 3,min: 0,step: 0.05},defaultValue: 1}, {name: "bloomSaturation",displayName: "Bloom Saturation",description: "TBD",type: "number",options: {max: 3,min: 0,step: 0.05},defaultValue: 1}, {name: "baseSaturation",displayName: "Base Saturation",description: "TBD",
                type: "number",options: {max: 3,min: 0,step: 0.05},defaultValue: 1}];
        this.exposeProperties();
        pc.fw.ComponentSystem.on("update", this.onUpdate, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(a, c) {
            b._super.initializeComponentData.call(this, a, c, "bloomThreshold blurAmount bloomIntensity baseIntensity bloomSaturation baseSaturation".split(" "))
        },onUpdate: function() {
            var a = this.store, b;
            for (b in a)
                a.hasOwnProperty(b) && this.context.scene.enqueue("post", function(a, 
                b, c) {
                    return function() {
                        if (b.camera) {
                            var f = b.camera.camera, j = c.systems.camera.current.camera.camera;
                            b.camera.offscreen && j === f && (f = f.getRenderTarget(), j = new pc.gfx.RenderTarget(pc.gfx.FrameBuffer.getBackBuffer()), a.bloomThreshold = "string" == typeof a.bloomThreshold ? parseFloat(a.bloomThreshold) : a.bloomThreshold, a.blurAmount = "string" == typeof a.blurAmount ? parseFloat(a.blurAmount) : a.blurAmount, a.bloomIntensity = "string" == typeof a.bloomIntensity ? parseFloat(a.bloomIntensity) : a.bloomIntensity, a.baseIntensity = 
                            "string" == typeof a.baseIntensity ? parseFloat(a.baseIntensity) : a.baseIntensity, a.bloomSaturation = "string" == typeof a.bloomSaturation ? parseFloat(a.bloomSaturation) : a.bloomSaturation, a.baseSaturation = "string" == typeof a.baseSaturation ? parseFloat(a.baseSaturation) : a.baseSaturation, pc.gfx.post.bloom.render(f, j, {bloomThreshold: a.bloomThreshold,blurAmount: a.blurAmount,bloomIntensity: a.bloomIntensity,baseIntensity: a.baseIntensity,bloomSaturation: a.bloomSaturation,baseSaturation: a.baseSaturation}))
                        }
                    }
                }(a[b].data, 
                a[b].entity, this.context))
        }});
    return {BloomComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
    }, pc.fw.Component);
    return {BloomComponent: b}
}());
pc.extend(pc.fw, function() {
    function b() {
        this.bloomThreshold = 0.25;
        this.blurAmount = 4;
        this.bloomIntensity = 1.25;
        this.baseSaturation = this.bloomSaturation = this.baseIntensity = 1
    }
    b = pc.inherits(b, pc.fw.ComponentData);
    return {BloomComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "model";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.ModelComponent;
        this.DataType = pc.fw.ModelComponentData;
        this.schema = [{name: "asset",displayName: "Asset",description: "Model Asset to render",type: "asset",options: {max: 1,type: "model"},defaultValue: null}, {name: "castShadows",displayName: "Cast shadows",description: "Occlude light from shadow casting lights",type: "boolean",defaultValue: !1}, {name: "receiveShadows",displayName: "Receive shadows",description: "Receive shadows cast from occluders",
                type: "boolean",defaultValue: !0}, {name: "model",exposed: !1}];
        this.exposeProperties()
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(a, c, d) {
            d = ["asset", "castShadows", "receiveShadows"];
            b._super.initializeComponentData.call(this, a, c, d)
        },removeComponent: function(a) {
            a.model.asset = null
        },cloneComponent: function(a, b) {
            this.addComponent(b, {});
            b.model.data.asset = a.model.asset;
            b.model.data.castShadows = a.model.castShadows;
            b.model.data.receiveShadows = a.model.receiveShadows;
            b.model.model = a.model.model.clone()
        }});
    return {ModelComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set_asset", this.onSetAsset, this);
        this.on("set_castShadows", this.onSetCastShadows, this);
        this.on("set_model", this.onSetModel, this);
        this.on("set_receiveShadows", this.onSetReceiveShadows, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {setVisible: function(a) {
            if (this.data.model) {
                var b = this.system.context.scene.containsModel(this.data.model);
                a && !b ? this.system.context.scene.addModel(this.data.model) : !a && b && this.system.context.scene.removeModel(this.data.model)
            }
        },
        loadModelAsset: function(a) {
            var b = {batch: this.entity.getRequestBatch()}, d = this.system.context.assets.getAsset(a);
            if (d) {
                var e = d.getFileUrl();
                this.system.context.loader.request(new pc.resources.ModelRequest(e), function(a) {
                    a = a[e];
                    this.system.context.designer && a.generateWireframe();
                    this.model = a
                }.bind(this), function(a) {
                    Object.keys(a).forEach(function(b) {
                        logERROR(a[b])
                    })
                }, function() {
                }, b)
            } else
                logERROR(pc.string.format("Trying to load model before asset {0} is loaded.", a))
        },onSetAsset: function(a, b, d) {
            d ? this.loadModelAsset(d) : 
            this.model = null
        },onSetCastShadows: function(a, b, d) {
            if (a = this.data.model) {
                var b = this.system.context.scene, e = b.containsModel(a);
                e && b.removeModel(a);
                for (var g = a.meshInstances, f = 0; f < g.length; f++)
                    g[f].castShadow = d;
                e && b.addModel(a)
            }
        },onSetModel: function(a, b, d) {
            b && (this.system.context.scene.removeModel(b), this.entity.removeChild(b.getGraph()));
            if (d) {
                for (var a = this.data, b = d.meshInstances, e = 0; e < b.length; e++)
                    b[e].castShadow = a.castShadows, b[e].receiveShadow = a.receiveShadows;
                this.entity.addChild(d.graph);
                this.system.context.scene.addModel(d);
                d._entity = this.entity;
                this.entity.animation && this.entity.animation.setModel(d)
            }
        },onSetReceiveShadows: function(a, b, d) {
            if (void 0 !== d && (a = this.data, a.model)) {
                a = a.model.meshInstances;
                for (b = 0; b < a.length; b++)
                    a[b].receiveShadow = d
            }
        }});
    return {ModelComponent: b}
}());
pc.extend(pc.fw, function() {
    function b() {
        this.asset = null;
        this.castShadows = !1;
        this.receiveShadows = !0;
        this.model = null
    }
    b = pc.inherits(b, pc.fw.ComponentData);
    return {ModelComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "skybox";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.SkyboxComponent;
        this.DataType = pc.fw.SkyboxComponentData;
        this.schema = [{name: "posx",displayName: "POSX",description: "URL of the positive X face of skybox cubemap",type: "asset",options: {max: 1},defaultValue: null}, {name: "negx",displayName: "NEGX",description: "URL of the negative X face of skybox cubemap",type: "asset",options: {max: 1},defaultValue: null}, {name: "posy",displayName: "POSY",description: "URL of the positive Y face of skybox cubemap",
                type: "asset",options: {max: 1},defaultValue: null}, {name: "negy",displayName: "NEGY",description: "URL of the negative Y face of skybox cubemap",type: "asset",options: {max: 1},defaultValue: null}, {name: "posz",displayName: "POSZ",description: "URL of the positive Z face of skybox cubemap",type: "asset",options: {max: 1},defaultValue: null}, {name: "negz",displayName: "NEGZ",description: "URL of the negative Z face of skybox cubemap",type: "asset",options: {max: 1},defaultValue: null}, {name: "model",exposed: !1,readOnly: !0}, 
            {name: "assets",exposed: !1,readOnly: !0}];
        this.exposeProperties();
        pc.fw.ComponentSystem.on("update", this.onUpdate, this);
        pc.fw.ComponentSystem.on("toolsUpdate", this.onUpdate, this);
        this.on("remove", this.onRemove, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(c, d) {
            b._super.initializeComponentData.call(this, c, d, a)
        },onUpdate: function() {
            var a = this.store, b;
            for (b in a)
                if (a.hasOwnProperty(b)) {
                    var e = a[b].data;
                    if (e.model) {
                        var g = this.context.systems.camera.current, 
                        g = 0.5 * (g.camera.nearClip + g.camera.farClip), e = e.model.meshInstances[0];
                        e.node.setLocalScale(g, g, g);
                        e.node.syncHierarchy()
                    }
                }
        },onRemove: function(a, b) {
            b.model && (this.context.scene.removeModel(b.model), a.removeChild(b.model.getGraph()), b.model = null)
        }});
    var a = "posx negx posy negy posz negz".split(" ");
    return {SkyboxComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set", this.onSet, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {onSet: function(b, d, e) {
            function g(b, c) {
                if (c) {
                    var d = a.indexOf(b), e = this.entity.skybox.assets;
                    this.entity.getRequestBatch();
                    this.data.model = null;
                    if (c)
                        if (e[d] = this.system.context.assets.getAsset(c), e[d]) {
                            if (this.data.assets = e, e[0] && e[1] && e[2] && e[3] && e[4] && e[5]) {
                                var f = e.map(function(a) {
                                    return a.getFileUrl()
                                }), d = this.data, g = this.entity, e = this.system.context, r = new pc.gfx.Texture({format: pc.gfx.PIXELFORMAT_R8_G8_B8,
                                    cubemap: !0});
                                r.minFilter = pc.gfx.FILTER_LINEAR_MIPMAP_LINEAR;
                                r.magFilter = pc.gfx.FILTER_LINEAR;
                                r.addressU = pc.gfx.ADDRESS_CLAMP_TO_EDGE;
                                r.addressV = pc.gfx.ADDRESS_CLAMP_TO_EDGE;
                                var s = f.map(function(a) {
                                    return new pc.resources.ImageRequest(a)
                                }), g = {batch: g.getRequestBatch()};
                                e.loader.request(s, function(a) {
                                    var b = f.map(function(b) {
                                        return a[b]
                                    });
                                    r.setSource(b)
                                }, function() {
                                }, function() {
                                }, g);
                                e = pc.gfx.Device.getCurrent().getProgramLibrary().getProgram("skybox");
                                s = new pc.scene.Material;
                                s.setState({cull: !1,depthWrite: !1});
                                s.setProgram(e);
                                s.setParameter("texture_cubeMap", r);
                                e = new pc.scene.GraphNode;
                                g = pc.scene.procedural.createBox({halfExtents: [1, 1, 1]});
                                s = new pc.scene.MeshInstance(e, g, s);
                                s.layer = pc.scene.LAYER_SKYBOX;
                                s.updateKey();
                                g = new pc.scene.Model;
                                g.graph = e;
                                g.meshInstances = [s];
                                d.model = g;
                                this.system.context.scene.addModel(this.data.model);
                                this.entity.removeChild(this.data.model.graph)
                            }
                        } else
                            logERROR(pc.string.format("Trying to load skybox component before asset {0} has loaded", c));
                    else
                        delete e[d]
                }
            }
            var f = {posx: function(a, 
                b, c, d) {
                    g.call(this, b, d)
                },negx: function(a, b, c, d) {
                    g.call(this, b, d)
                },posy: function(a, b, c, d) {
                    g.call(this, b, d)
                },negy: function(a, b, c, d) {
                    g.call(this, b, d)
                },posz: function(a, b, c, d) {
                    g.call(this, b, d)
                },negz: function(a, b, c, d) {
                    g.call(this, b, d)
                }};
            f[b] && f[b].call(this, this.entity, b, d, e)
        }});
    var a = "posx negx posy negy posz negz".split(" ");
    return {SkyboxComponent: b}
}());
pc.extend(pc.fw, function() {
    function b() {
        this.negz = this.posz = this.negy = this.posy = this.negx = this.posx = null;
        this.assets = [];
        this.model = null
    }
    b = pc.inherits(b, pc.fw.ComponentData);
    return {SkyboxComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "camera";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.CameraComponent;
        this.DataType = pc.fw.CameraComponentData;
        this.schema = [{name: "clearColor",displayName: "Clear Color",description: "Clear Color",type: "rgba",defaultValue: "0xbabab1ff"}, {name: "projection",displayName: "Projection",description: "Projection type of camera",type: "enumeration",options: {enumerations: [{name: "Perspective",value: 0}, {name: "Orthographic",value: 1}]},defaultValue: 0}, {name: "fov",
                displayName: "Field of View",description: "Field of view in Y axis",type: "number",defaultValue: 45,options: {min: 0,max: 90}}, {name: "orthoHeight",displayName: "Ortho Height",description: "View window half extent of camera in Y axis",type: "number",defaultValue: 100}, {name: "nearClip",displayName: "Near Clip",description: "Near clipping distance",type: "number",defaultValue: 1,options: {min: 0}}, {name: "farClip",displayName: "Far Clip",description: "Far clipping distance",type: "number",defaultValue: 1E5,options: {min: 0}}, 
            {name: "activate",displayName: "Activate",description: "Activate camera when scene loads",type: "boolean",defaultValue: !0}, {name: "offscreen",displayName: "Offscreen",description: "Render to an offscreen buffer",type: "boolean",defaultValue: !1}, {name: "camera",exposed: !1}, {name: "model",exposed: !1}];
        this.exposeProperties();
        this._currentNode = this._currentEntity = null;
        this.on("remove", this.onRemove, this);
        pc.fw.ComponentSystem.on("toolsUpdate", this.toolsUpdate, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    Object.defineProperty(b.prototype, 
    "current", {get: function() {
            return this._currentEntity
        },set: function(a) {
            if (null === a)
                this._currentNode = this._currentEntity = null;
            else {
                if (!a.camera)
                    throw Error("Entity must have camera Component");
                this._currentEntity = a;
                this._currentNode = a.camera.data.camera
            }
        }});
    pc.extend(b.prototype, {initializeComponentData: function(a, c, d) {
            c = c || {};
            c.camera = new pc.scene.CameraNode;
            if (this.context.designer && !a.entity.hasLabel("pc:designer")) {
                d = new pc.scene.BasicMaterial;
                d.color = pc.math.vec4.create(1, 1, 0, 1);
                d.update();
                var e = 
                new pc.gfx.IndexBuffer(pc.gfx.INDEXFORMAT_UINT8, 24);
                (new Uint8Array(e.lock())).set([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
                e.unlock();
                var g = new pc.gfx.VertexFormat;
                g.begin();
                g.addElement(new pc.gfx.VertexElement("vertex_position", 3, pc.gfx.VertexElementType.FLOAT32));
                g.end();
                var f = new pc.gfx.VertexBuffer(g, 8, pc.gfx.BUFFER_DYNAMIC), g = new pc.scene.Mesh;
                g.vertexBuffer = f;
                g.indexBuffer[0] = e;
                g.primitive[0].type = pc.gfx.PRIMITIVE_LINES;
                g.primitive[0].base = 0;
                g.primitive[0].count = e.getNumIndices();
                g.primitive[0].indexed = !0;
                e = new pc.scene.Model;
                e.graph = c.camera;
                e.meshInstances = [new pc.scene.MeshInstance(e.graph, g, d)];
                this.context.scene.addModel(e);
                c.model = e
            }
            d = "model camera clearColor fov orthoHeight activate nearClip farClip offscreen projection".split(" ");
            b._super.initializeComponentData.call(this, a, c, d);
            !window.pc.apps.designer && (a.activate && !a.entity.hasLabel("pc:designer")) && (this.current = a.entity)
        },frameBegin: function() {
            var a = this._currentNode;
            if (a) {
                var b = pc.gfx.Device.getCurrent(), d = 
                b.canvas.width, b = b.canvas.height, e = a.getRenderTarget(), g = e.getViewport(), e = e.getFrameBuffer().getTexture();
                if (this._currentEntity.camera.data.offscreen) {
                    if (!e || g.width !== d || g.height !== b)
                        d = new pc.gfx.FrameBuffer(d, b, !0), b = d.getTexture(), b.minFilter = pc.gfx.FILTER_LINEAR, b.magFilter = pc.gfx.FILTER_LINEAR, b.addressU = pc.gfx.ADDRESS_CLAMP_TO_EDGE, b.addressV = pc.gfx.ADDRESS_CLAMP_TO_EDGE, a.setRenderTarget(new pc.gfx.RenderTarget(d))
                } else
                    e && (d = pc.gfx.FrameBuffer.getBackBuffer(), a.setRenderTarget(new pc.gfx.RenderTarget(d)));
                g = a.getRenderTarget().getViewport();
                d = g.width / g.height;
                d !== a.getAspectRatio() && a.setAspectRatio(d)
            }
        },frameEnd: function() {
        },onRemove: function(a, b) {
            this._currentEntity === a && (this.current = null);
            this.context.designer && !a.hasLabel("pc:designer") && this.context.scene.containsModel(b.model) && this.context.scene.removeModel(b.model);
            a.removeChild(b.camera);
            b.camera = null
        },toolsUpdate: function() {
            var a = this.store, b;
            for (b in a)
                if (a.hasOwnProperty(b)) {
                    var d = a[b].entity;
                    d.hasLabel("pc:designer") || this.updateGfx(d.camera)
                }
        },
        updateGfx: function(a) {
            if (a.model && a.model.meshInstances.length) {
                var b = a.model.meshInstances[0].mesh.vertexBuffer, d = a.nearClip, e = a.farClip, g = a.fov * Math.PI / 180, f = a.camera.getRenderTarget().getViewport(), f = f.width / f.height, a = a.projection, j, k;
                k = a === pc.scene.Projection.PERSPECTIVE ? Math.tan(g / 2) * d : this._orthoHeight;
                j = k * f;
                var l = new Float32Array(b.lock());
                l[0] = j;
                l[1] = -k;
                l[2] = -d;
                l[3] = j;
                l[4] = k;
                l[5] = -d;
                l[6] = -j;
                l[7] = k;
                l[8] = -d;
                l[9] = -j;
                l[10] = -k;
                l[11] = -d;
                a === pc.scene.Projection.PERSPECTIVE && (k = Math.tan(g / 2) * e, j = 
                k * f);
                l[12] = j;
                l[13] = -k;
                l[14] = -e;
                l[15] = j;
                l[16] = k;
                l[17] = -e;
                l[18] = -j;
                l[19] = k;
                l[20] = -e;
                l[21] = -j;
                l[22] = -k;
                l[23] = -e;
                b.unlock()
            }
        }});
    return {CameraComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set_camera", this.onSetCamera, this);
        this.on("set_clearColor", this.onSetClearColor, this);
        this.on("set_fov", this.onSetFov, this);
        this.on("set_orthoHeight", this.onSetOrthoHeight, this);
        this.on("set_nearClip", this.onSetNearClip, this);
        this.on("set_farClip", this.onSetFarClip, this);
        this.on("set_projection", this.onSetProjection, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {screenToWorld: function(a, b, d, e) {
            return this.data.camera.screenToWorld(a, 
            b, d, e)
        },onSetCamera: function(a, b, d) {
            b && this.entity.removeChild(b);
            this.entity.addChild(d)
        },onSetClearColor: function(a, b, d) {
            a = parseInt(d);
            this.data.camera.getClearOptions().color = [(a >> 24 & 255) / 255, (a >> 16 & 255) / 255, (a >> 8 & 255) / 255, (a & 255) / 255]
        },onSetFov: function(a, b, d) {
            this.data.camera.setFov(d)
        },onSetOrthoHeight: function(a, b, d) {
            this.data.camera.setOrthoHeight(d)
        },onSetNearClip: function(a, b, d) {
            this.data.camera.setNearClip(d)
        },onSetFarClip: function(a, b, d) {
            this.data.camera.setFarClip(d)
        },onSetProjection: function(a, 
        b, d) {
            this.data.camera.setProjection(d)
        }});
    return {CameraComponent: b}
}());
pc.extend(pc.fw, function() {
    CameraComponentData = function() {
        this.clearColor = "0xbabab1ff";
        this.nearClip = 0.1;
        this.farClip = 1E3;
        this.fov = 45;
        this.orthoHeight = 100;
        this.aspectRatio = 16 / 9;
        this.projection = pc.scene.Projection.PERSPECTIVE;
        this.activate = !0;
        this.offscreen = !1;
        this.camera = null
    };
    CameraComponentData = pc.inherits(CameraComponentData, pc.fw.ComponentData);
    return {CameraComponentData: CameraComponentData}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "cubemap";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.CubeMapComponent;
        this.DataType = pc.fw.CubeMapComponentData;
        this.schema = [{name: "buffer",exposed: !1}, {name: "cubemap",exposed: !1}, {name: "camera",exposed: !1}];
        this.exposeProperties();
        pc.fw.ComponentSystem.on("update", this.onUpdate, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(a, c) {
            c.buffer = new pc.gfx.FrameBuffer(256, 256, !0, !0);
            c.cubemap = 
            c.buffer.getTexture();
            c.cubemap.minFilter = pc.gfx.FILTER_LINEAR;
            c.cubemap.magFilter = pc.gfx.FILTER_LINEAR;
            c.cubemap.addressU = pc.gfx.ADDRESS_CLAMP_TO_EDGE;
            c.cubemap.addressV = pc.gfx.ADDRESS_CLAMP_TO_EDGE;
            c.camera = new pc.scene.CameraNode;
            c.camera.setNearClip(0.01);
            c.camera.setFarClip(100);
            c.camera.setAspectRatio(1);
            c.camera.setRenderTarget(new pc.gfx.RenderTarget(c.buffer));
            b._super.initializeComponentData.call(this, a, c, ["buffer", "cubemap", "camera"])
        },onUpdate: function() {
            var a, b, d, e = this.store;
            if (!this.renderingCubeMap) {
                this.renderingCubeMap = 
                !0;
                for (a in e)
                    e.hasOwnProperty(a) && (b = e[a].entity, d = e[a].data, this.context.scene.enqueue("first", function(a, b, c) {
                        return function() {
                            c.systems.camera.frameEnd();
                            var d;
                            b.model ? d = b.model.model : b.primitive && (d = b.primitive.model);
                            if (d) {
                                c.scene.removeModel(d);
                                for (var e = [{target: [1, 0, 0],up: [0, -1, 0]}, {target: [-1, 0, 0],up: [0, -1, 0]}, {target: [0, 1, 0],up: [0, 0, 1]}, {target: [0, -1, 0],up: [0, 0, -1]}, {target: [0, 0, 1],up: [0, -1, 0]}, {target: [0, 0, -1],up: [0, -1, 0]}], m = b.getPosition(), h = 0; 6 > h; h++) {
                                    a.buffer.setActiveBuffer(h);
                                    a.camera.setPosition(m);
                                    a.camera.lookAt(e[h].target, e[h].up);
                                    a.camera.syncHierarchy();
                                    a.camera.frameBegin();
                                    for (var n = c.scene.getModels(), r = 0; r < n.length; r++)
                                        n[r].dispatch();
                                    a.camera.frameEnd()
                                }
                                c.scene.addModel(d)
                            }
                            c.systems.camera.frameBegin(!1)
                        }
                    }(d, b, this.context)));
                this.renderingCubeMap = !1
            }
        }});
    return {CubeMapComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
    }, pc.fw.Component);
    return {CubeMapComponent: b}
}());
pc.extend(pc.fw, function() {
    CubeMapComponentData = function() {
        this.camera = null;
        this.nearClip = 1;
        this.farClip = 1E5;
        this.height = this.width = 256
    };
    CubeMapComponentData = pc.inherits(CubeMapComponentData, pc.fw.ComponentData);
    return {CubeMapComponentData: CubeMapComponentData}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "staticcubemap";
        a.systems.add(this.id, this);
        this.schema = [{name: "posx",displayName: "POSX",description: "URL of the positive X face of cubemap",type: "asset",options: {max: 1},defaultValue: null}, {name: "negx",displayName: "NEGX",description: "URL of the negative X face of cubemap",type: "asset",options: {max: 1},defaultValue: null}, {name: "posy",displayName: "POSY",description: "URL of the positive Y face of cubemap",type: "asset",options: {max: 1},defaultValue: null}, 
            {name: "negy",displayName: "NEGY",description: "URL of the negative Y face of cubemap",type: "asset",options: {max: 1},defaultValue: null}, {name: "posz",displayName: "POSZ",description: "URL of the positive Z face of cubemap",type: "asset",options: {max: 1},defaultValue: null}, {name: "negz",displayName: "NEGZ",description: "URL of the negative Z face of cubemap",type: "asset",options: {max: 1},defaultValue: null}, {name: "assets",exposed: !1}, {name: "cubemap",exposed: !1}];
        this.exposeProperties();
        this.ComponentType = pc.fw.StaticCubeMapComponent;
        this.DataType = pc.fw.StaticCubeMapComponentData
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(c, d) {
            b._super.initializeComponentData.call(this, c, d, a)
        }});
    var a = "posx negx posy negy posz negz".split(" ");
    return {StaticCubeMapComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set", this.onSet, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {onSet: function(b, e, g) {
            function f(b, d) {
                if (d) {
                    var e = a.indexOf(b), f = this.assets;
                    this.entity.getRequestBatch();
                    this.cubemap = null;
                    d ? (f[e] = this.system.context.assets.getAsset(d), this.assets = f, f[0] && (f[1] && f[2] && f[3] && f[4] && f[5]) && (e = f.map(function(a) {
                        return a.getFileUrl()
                    }), this.cubemap = c(this.entity, this.system.context, e))) : delete f[e]
                }
            }
            var j = {posx: function(a, b, c) {
                    f.call(this, 
                    a, c)
                },negx: function(a, b, c) {
                    f.call(this, a, c)
                },posy: function(a, b, c) {
                    f.call(this, a, c)
                },negy: function(a, b, c) {
                    f.call(this, a, c)
                },posz: function(a, b, c) {
                    f.call(this, a, c)
                },negz: function(a, b, c) {
                    f.call(this, a, c)
                }};
            j[b] && j[b].call(this, b, e, g)
        }});
    var a = "posx negx posy negy posz negz".split(" "), c = function(a, b, c) {
        var f = new pc.gfx.Texture({format: pc.gfx.PIXELFORMAT_R8_G8_B8,cubemap: !0});
        f.minFilter = pc.gfx.FILTER_LINEAR_MIPMAP_LINEAR;
        f.magFilter = pc.gfx.FILTER_LINEAR;
        f.addressU = pc.gfx.ADDRESS_CLAMP_TO_EDGE;
        f.addressV = 
        pc.gfx.ADDRESS_CLAMP_TO_EDGE;
        var j = c.map(function(a) {
            return new pc.resources.ImageRequest(a)
        }), a = {batch: a.getRequestBatch()};
        b.loader.request(j, function(a) {
            var b = c.map(function(b) {
                return a[b]
            });
            f.setSource(b)
        }.bind(this), function() {
        }, function() {
        }, a);
        return f
    };
    return {StaticCubeMapComponent: b}
}());
pc.extend(pc.fw, function() {
    function b() {
        this.negz = this.posz = this.negy = this.posy = this.negx = this.posx = null;
        this.assets = [];
        this.cubemap = null
    }
    b = pc.inherits(b, pc.fw.ComponentData);
    return {StaticCubeMapComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "directionallight";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.DirectionalLightComponent;
        this.DataType = pc.fw.DirectionalLightComponentData;
        this.schema = [{name: "enable",displayName: "Enable",description: "Enable or disable the light",type: "boolean",defaultValue: !0}, {name: "color",displayName: "Color",description: "Light Color",type: "rgb",defaultValue: "0xffffff"}, {name: "intensity",displayName: "Intensity",description: "Factors the light color",type: "number",
                defaultValue: 1,options: {min: 0,max: 10,step: 0.05}}, {name: "castShadows",displayName: "Cast Shadows",description: "Cast shadows from this light",type: "boolean",defaultValue: !1}, {name: "shadowResolution",displayName: "Shadow Resolution",description: "Resolution of shadowmap generated by this light",type: "enumeration",options: {enumerations: [{name: "256",value: 256}, {name: "512",value: 512}, {name: "1024",value: 1024}, {name: "2048",value: 2048}]},defaultValue: 1024}, {name: "model",exposed: !1}];
        this.exposeProperties();
        a = 
        new pc.scene.BasicMaterial;
        a.color = pc.math.vec4.create(1, 1, 0, 1);
        a.update();
        this.material = a;
        var b = new pc.gfx.VertexFormat;
        b.begin();
        b.addElement(new pc.gfx.VertexElement("vertex_position", 3, pc.gfx.VertexElementType.FLOAT32));
        b.end();
        vertexData = [0, 0, 0, 0, -8, 0, -0.5, -8, 0, 0.5, -8, 0, 0.5, -8, 0, 0, -10, 0, 0, -10, 0, -0.5, -8, 0, 0, 0, -2, 0, -8, -2, -0.25, -8, -2, 0.25, -8, -2, 0.25, -8, -2, 0, -10, -2, 0, -10, -2, -0.25, -8, -2];
        for (var d = pc.math.mat4.makeRotate(120, [0, 1, 0]), a = 0; 16 > a; a++) {
            var e = pc.math.vec3.create(vertexData[3 * (a + 8)], vertexData[3 * 
            (a + 8) + 1], vertexData[3 * (a + 8) + 2]), e = pc.math.mat4.multiplyVec3(e, 1, d);
            vertexData[3 * (a + 16)] = e[0];
            vertexData[3 * (a + 16) + 1] = e[1];
            vertexData[3 * (a + 16) + 2] = e[2]
        }
        b = new pc.gfx.VertexBuffer(b, 32);
        d = new Float32Array(b.lock());
        for (a = 0; a < vertexData.length; a++)
            d[a] = vertexData[a];
        b.unlock();
        this.vertexBuffer = b;
        a = new pc.scene.Mesh;
        a.vertexBuffer = b;
        a.indexBuffer[0] = null;
        a.primitive[0].type = pc.gfx.PRIMITIVE_LINES;
        a.primitive[0].base = 0;
        a.primitive[0].count = this.vertexBuffer.getNumVertices();
        a.primitive[0].indexed = !1;
        this.mesh = 
        a;
        this.on("remove", this.onRemove, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(a, c, d) {
            d = new pc.scene.LightNode;
            d.setName("directionallight");
            d.setType(pc.scene.LightType.DIRECTIONAL);
            var e = new pc.scene.Model;
            e.graph = d;
            e.lights = [d];
            this.context.designer && (e.meshInstances = [new pc.scene.MeshInstance(d, this.mesh, this.material)]);
            this.context.scene.addModel(e);
            a.entity.addChild(d);
            c = c || {};
            c.model = e;
            d = "model enable color intensity castShadows shadowResolution".split(" ");
            b._super.initializeComponentData.call(this, a, c, d)
        },onRemove: function(a, b) {
            a.removeChild(b.model.graph);
            this.context.scene.removeModel(b.model);
            delete b.model
        }});
    return {DirectionalLightComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set_color", this.onSetColor, this);
        this.on("set_enable", this.onSetEnable, this);
        this.on("set_intensity", this.onSetIntensity, this);
        this.on("set_castShadows", this.onSetCastShadows, this);
        this.on("set_shadowResolution", this.onSetShadowResolution, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {onSetCastShadows: function(a, b, d) {
            this.data.model.lights[0].setCastShadows(d)
        },onSetColor: function(a, b, d) {
            d && (a = parseInt(d), a = pc.math.intToBytes24(a), 
            this.data.model.lights[0].setColor([a[0] / 255, a[1] / 255, a[2] / 255]))
        },onSetEnable: function(a, b, d) {
            void 0 !== d && this.data.model.lights[0].setEnabled(d)
        },onSetIntensity: function(a, b, d) {
            void 0 !== d && this.data.model.lights[0].setIntensity(d)
        },onSetShadowResolution: function(a, b, d) {
            this.data.model.lights[0].setShadowResolution(d, d)
        }});
    return {DirectionalLightComponent: b}
}());
pc.extend(pc.fw, function() {
    function b() {
        this.enable = !0;
        this.color = "0xffffff";
        this.intensity = 1;
        this.castShadows = !1;
        this.shadowResolution = 1024;
        this.model = null
    }
    b = pc.inherits(b, pc.fw.ComponentData);
    return {DirectionalLightComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "pointlight";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.PointLightComponent;
        this.DataType = pc.fw.PointLightComponentData;
        this.schema = [{name: "enable",displayName: "Enable",description: "Enable or disable the light",type: "boolean",defaultValue: !0}, {name: "color",displayName: "Color",description: "Light Color",type: "rgb",defaultValue: "0xffffff"}, {name: "intensity",displayName: "Intensity",description: "Factors the light color",type: "number",defaultValue: 1,
                options: {min: 0,max: 10,step: 0.05}}, {name: "attenuationEnd",displayName: "Radius",description: "The distance from the light where its contribution falls to zero",type: "number",defaultValue: 10,options: {min: 0}}, {name: "model",exposed: !1}];
        this.exposeProperties();
        this.lightMat = new pc.scene.BasicMaterial;
        this.lightMat.color = new Float32Array([1, 1, 0, 1]);
        this.lightMat.update();
        this.sphereMesh = pc.scene.procedural.createSphere({radius: 0.1});
        this.on("remove", this.onRemove, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(a, c, d) {
            d = new pc.scene.LightNode;
            d.setName("pointlight");
            d.setType(pc.scene.LightType.POINT);
            var e = new pc.scene.Model;
            e.graph = d;
            e.lights = [d];
            this.context.designer && (e.meshInstances = [new pc.scene.MeshInstance(d, this.sphereMesh, this.lightMat)]);
            this.context.scene.addModel(e);
            a.entity.addChild(d);
            c.model = e;
            d = ["model", "enable", "color", "intensity", "attenuationEnd"];
            b._super.initializeComponentData.call(this, a, c, d)
        },onRemove: function(a, b) {
            a.removeChild(b.model.graph);
            this.context.scene.removeModel(b.model);
            delete b.model
        }});
    return {PointLightComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set_attenuationEnd", this.onSetAttenuationEnd, this);
        this.on("set_color", this.onSetColor, this);
        this.on("set_enable", this.onSetEnable, this);
        this.on("set_intensity", this.onSetIntensity, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {onSetAttenuationEnd: function(a, b, d) {
            this.data.model.lights[0].setAttenuationEnd(d)
        },onSetColor: function(a, b, d) {
            a = parseInt(d);
            a = pc.math.intToBytes24(a);
            this.data.model.lights[0].setColor([a[0] / 255, a[1] / 255, a[2] / 
                255])
        },onSetEnable: function(a, b, d) {
            this.data.model.lights[0].setEnabled(d)
        },onSetIntensity: function(a, b, d) {
            this.data.model.lights[0].setIntensity(d)
        }});
    return {PointLightComponent: b}
}());
pc.extend(pc.fw, function() {
    function b() {
        this.enable = !0;
        this.color = "0xffffff";
        this.intensity = 1;
        this.attenuationEnd = 10;
        this.model = null
    }
    b = pc.inherits(b, pc.fw.ComponentData);
    return {PointLightComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "spotlight";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.SpotLightComponent;
        this.DataType = pc.fw.SpotLightComponentData;
        this.schema = [{name: "enable",displayName: "Enable",description: "Enable or disable the light",type: "boolean",defaultValue: !0}, {name: "color",displayName: "Color",description: "Light color",type: "rgb",defaultValue: "0xffffff"}, {name: "intensity",displayName: "Intensity",description: "Factors the light color",type: "number",defaultValue: 1,
                options: {min: 0,max: 10,step: 0.05}}, {name: "attenuationEnd",displayName: "Attenuation End",description: "The distance from the light where its contribution falls to zero",type: "number",defaultValue: 10,options: {min: 0}}, {name: "innerConeAngle",displayName: "Inner Cone Angle",description: "Spotlight inner cone angle",type: "number",defaultValue: 40,options: {min: 0,max: 90}}, {name: "outerConeAngle",displayName: "Outer Cone Angle",description: "Spotlight outer cone angle",type: "number",defaultValue: 45,options: {min: 0,
                    max: 90}}, {name: "castShadows",displayName: "Cast Shadows",description: "Cast shadows from this light",type: "boolean",defaultValue: !1}, {name: "shadowResolution",displayName: "Shadow Resolution",description: "Resolution of shadowmap generated by this light",type: "enumeration",options: {enumerations: [{name: "256",value: 256}, {name: "512",value: 512}, {name: "1024",value: 1024}, {name: "2048",value: 2048}]},defaultValue: 1024}, {name: "model",exposed: !1}];
        this.exposeProperties();
        this.material = new pc.scene.BasicMaterial;
        var a = new pc.gfx.IndexBuffer(pc.gfx.INDEXFORMAT_UINT8, 88), b = new Uint8Array(a.lock());
        b[0] = 0;
        b[1] = 1;
        b[2] = 0;
        b[3] = 11;
        b[4] = 0;
        b[5] = 21;
        b[6] = 0;
        b[7] = 31;
        for (var d = 0; 40 > d; d++)
            b[2 * d + 8] = d + 1, b[2 * d + 9] = d + 2;
        a.unlock();
        this.indexBuffer = a;
        a = new pc.gfx.VertexFormat;
        a.begin();
        a.addElement(new pc.gfx.VertexElement("vertex_position", 3, pc.gfx.VertexElementType.FLOAT32));
        a.end();
        this.vertexFormat = a;
        this.on("remove", this.onRemove, this);
        pc.fw.ComponentSystem.on("toolsUpdate", this.toolsUpdate, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(a, c, d) {
            d = new pc.scene.LightNode;
            d.setName("spotlight");
            d.setType(pc.scene.LightType.SPOT);
            var e = new pc.scene.Model;
            e.graph = d;
            e.lights = [d];
            if (this.context.designer) {
                var g = new pc.gfx.VertexBuffer(this.vertexFormat, 42, pc.gfx.BUFFER_DYNAMIC), f = new pc.scene.Mesh;
                f.vertexBuffer = g;
                f.indexBuffer[0] = this.indexBuffer;
                f.primitive[0].type = pc.gfx.PRIMITIVE_LINES;
                f.primitive[0].base = 0;
                f.primitive[0].count = this.indexBuffer.getNumIndices();
                f.primitive[0].indexed = 
                !0;
                e.meshInstances = [new pc.scene.MeshInstance(d, f, this.material)]
            }
            this.context.scene.addModel(e);
            a.entity.addChild(d);
            c.model = e;
            d = "model enable color intensity attenuationEnd innerConeAngle outerConeAngle castShadows shadowResolution".split(" ");
            b._super.initializeComponentData.call(this, a, c, d)
        },onRemove: function(a, b) {
            a.removeChild(b.model.graph);
            this.context.scene.removeModel(b.model);
            delete b.model
        },toolsUpdate: function() {
            var a = this.store, b;
            for (b in a)
                if (a.hasOwnProperty(b)) {
                    var d = a[b].data, e = d.model.meshInstances[0].mesh.vertexBuffer, 
                    g = Math.PI * d.outerConeAngle / 180, f = d.attenuationEnd, d = -f * Math.cos(g), g = f * Math.sin(g), f = new Float32Array(e.lock());
                    f[0] = 0;
                    f[1] = 0;
                    f[2] = 0;
                    for (var j = e.getNumVertices(), k = 0; k < j - 1; k++) {
                        var l = 2 * Math.PI * (k / (j - 2)), m = g * Math.cos(l), l = g * Math.sin(l);
                        f[3 * (k + 1) + 0] = m;
                        f[3 * (k + 1) + 1] = d;
                        f[3 * (k + 1) + 2] = l
                    }
                    e.unlock()
                }
        }});
    return {SpotLightComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set_attenuationEnd", this.onSetAttenuationEnd, this);
        this.on("set_castShadows", this.onSetCastShadows, this);
        this.on("set_color", this.onSetColor, this);
        this.on("set_enable", this.onSetEnable, this);
        this.on("set_innerConeAngle", this.onSetInnerConeAngle, this);
        this.on("set_intensity", this.onSetIntensity, this);
        this.on("set_outerConeAngle", this.onSetOuterConeAngle, this);
        this.on("set_shadowResolution", this.onSetShadowResolution, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {onSetAttenuationEnd: function(a, b, d) {
            this.data.model.lights[0].setAttenuationEnd(d)
        },onSetColor: function(a, b, d) {
            a = parseInt(d);
            a = pc.math.intToBytes24(a);
            this.data.model.lights[0].setColor([a[0] / 255, a[1] / 255, a[2] / 255])
        },onSetInnerConeAngle: function(a, b, d) {
            this.data.model.lights[0].setInnerConeAngle(d)
        },onSetOuterConeAngle: function(a, b, d) {
            this.data.model.lights[0].setOuterConeAngle(d)
        },onSetEnable: function(a, b, d) {
            this.data.model.lights[0].setEnabled(d)
        },onSetIntensity: function(a, 
        b, d) {
            this.data.model.lights[0].setIntensity(d)
        },onSetCastShadows: function(a, b, d) {
            this.data.model.lights[0].setCastShadows(d)
        },onSetShadowResolution: function(a, b, d) {
            this.data.model.lights[0].setShadowResolution(d, d)
        }});
    return {SpotLightComponent: b}
}());
pc.extend(pc.fw, function() {
    function b() {
        this.enable = !0;
        this.color = "0xffffff";
        this.intensity = 1;
        this.attenuationEnd = 10;
        this.innerConeAngle = 40;
        this.outerConeAngle = 45;
        this.castShadows = !1;
        this.shadowResolution = 1024;
        this.model = null
    }
    b = pc.inherits(b, pc.fw.ComponentData);
    return {SpotLightComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "script";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.ScriptComponent;
        this.DataType = pc.fw.ScriptComponentData;
        this.schema = [{name: "urls",displayName: "URLs",description: "Attach scripts to this Entity",type: "script_urls",defaultValue: []}, {name: "instances",exposed: !1}, {name: "runInTools",description: "Allows scripts to be loaded and executed while in the tools",defaultValue: !1,exposed: !1}];
        this.exposeProperties();
        this.on("remove", this.onRemove, 
        this);
        pc.fw.ComponentSystem.on("initialize", this.onInitialize, this);
        pc.fw.ComponentSystem.on("update", this.onUpdate, this);
        pc.fw.ComponentSystem.on("fixedUpdate", this.onFixedUpdate, this);
        pc.fw.ComponentSystem.on("postUpdate", this.onPostUpdate, this);
        pc.fw.ComponentSystem.on("toolsUpdate", this.onToolsUpdate, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(a, c, d) {
            d = ["runInTools", "urls"];
            b._super.initializeComponentData.call(this, a, c, d)
        },cloneComponent: function(a, 
        b) {
            var d = this.dataStore[a.getGuid()], d = {runInTools: d.data.runInTools,urls: pc.extend([], d.data.urls)};
            return this.addComponent(b, d)
        },onRemove: function(a, b) {
            for (name in b.instances)
                b.instances.hasOwnProperty(name) && (["update", "fixedUpdate", "postUpdate", "toolsUpdate"].forEach(function(a) {
                    b.instances[name].instance[a] && this.unbind(a, b.instances[name].instance[a], b.instances[name].instance)
                }, this), b.instances[name].instance.destroy && b.instances[name].instance.destroy())
        },onInitialize: function(a) {
            this._registerInstances(a);
            if (a.script)
                for (name in a.script.data.instances)
                    a.script.data.instances.hasOwnProperty(name) && a.script.data.instances[name].instance.initialize && a.script.data.instances[name].instance.initialize();
            var a = a.getChildren(), b, d = a.length;
            for (b = 0; b < d; b++)
                if (a[b] instanceof pc.fw.Entity)
                    this.onInitialize(a[b])
        },onUpdate: function(a) {
            this.fire("update", a)
        },onFixedUpdate: function(a) {
            this.fire("fixedUpdate", a)
        },onPostUpdate: function(a) {
            this.fire("postUpdate", a)
        },onToolsUpdate: function(a) {
            this.fire("toolsUpdate", 
            a)
        },broadcast: function(a, b) {
            var d = pc.makeArray(arguments).slice(2), e, g, f, j = this.store;
            for (e in j)
                j.hasOwnProperty(e) && (g = j[e].data, g.instances[a] && (f = g.instances[a].instance[b]) && f.apply(g.instances[a].instance, d))
        },_preRegisterInstance: function(a, b, d, e) {
            a.script.data._instances = a.script.data._instances || {};
            if (a.script.data._instances[d])
                throw Error(pc.string.format("Script name collision '{0}'. Scripts from '{1}' and '{2}' {{3}}", d, b, a.script.data._instances[d].url, a.getGuid()));
            a.script.data._instances[d] = 
            {url: b,name: d,instance: e}
        },_registerInstances: function(a) {
            var b, d;
            if (a.script && a.script.data._instances) {
                a.script.instances = a.script.data._instances;
                for (d in a.script.instances) {
                    b = a.script.instances[d];
                    if (b.instance.update)
                        this.on("update", b.instance.update, b.instance);
                    if (b.instance.fixedUpdate)
                        this.on("fixedUpdate", b.instance.fixedUpdate, b.instance);
                    if (b.instance.postUpdate)
                        this.on("postUpdate", b.instance.postUpdate, b.instance);
                    if (b.instance.toolsUpdate)
                        this.on("toolsUpdate", b.instance.toolsUpdate, 
                        b.instance)
                }
                delete a.script.data._instances
            }
            a = a.getChildren();
            d = a.length;
            for (b = 0; b < d; b++)
                a[b] instanceof pc.fw.Entity && this._registerInstances(a[b])
        }});
    return {ScriptComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set_urls", this.onSetUrls, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {send: function(a, b) {
            var d = pc.makeArray(arguments).slice(2), e = this.entity.script.instances, g;
            if (e && e[a] && (g = e[a].instance[b]))
                return g.apply(e[a].instance, d)
        },onSetUrls: function(a, b, d) {
            var e = {batch: this.entity.getRequestBatch()};
            (!this.system._inTools || this.runInTools) && d.forEach(function(a, b) {
                a = d[b].trim();
                this.system.context.loader.request(new pc.resources.ScriptRequest(a), 
                function(b) {
                    if (b = b[a]) {
                        var c = new b(this.entity);
                        this.system._preRegisterInstance(this.entity, a, b._pcScriptName, c);
                        if (!e.batch)
                            this.system.onInitialize(this.entity)
                    }
                }.bind(this), function(a) {
                    Object.keys(a).forEach(function(b) {
                        logERROR(a[b])
                    })
                }, function() {
                }, e)
            }, this)
        }});
    return {ScriptComponent: b}
}());
pc.extend(pc.fw, function() {
    function b() {
        this.urls = [];
        this.instances = {};
        this._scripts = [];
        this.runInTools = !1
    }
    b = pc.inherits(b, pc.fw.ComponentData);
    return {ScriptComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "pack";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.PackComponent;
        this.DataType = pc.fw.PackComponentData;
        this.schema = []
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    return {PackComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
    }, pc.fw.Component);
    return {PackComponent: b}
}());
pc.extend(pc.fw, function() {
    function b() {
    }
    b = pc.inherits(b, pc.fw.ComponentData);
    return {PackComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "pick";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.PickComponent;
        this.DataType = pc.fw.PickComponentData;
        this.schema = [{name: "layer",exposed: !1}, {name: "shapes",exposed: !1}, {name: "material",exposed: !1}];
        this.layers = {"default": []};
        this.display = !1;
        this.on("remove", this.onRemove, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(a, c, d) {
            c.material = new pc.scene.PhongMaterial;
            d = ["material"];
            b._super.initializeComponentData.call(this, 
            a, c, d)
        },onRemove: function(a, b) {
            this.deleteShapes(b.layer, b.shapes)
        },addShape: function(a, b) {
            void 0 === this.layers[a] && (this.layers[a] = []);
            this.layers[a].push(b.model);
            this.display && this.context.scene.addModel(b.model)
        },deleteShapes: function(a, b) {
            for (var d = this.layers[a], e = 0; e < b.length; e++) {
                var g = b[e].model, f = d.indexOf(g);
                -1 !== f && d.splice(f, 1);
                this.display && this.context.scene.removeModel(g)
            }
        },getLayerModels: function(a) {
            return this.layers[a]
        }});
    return {PickComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
    }, pc.fw.Component);
    pc.extend(b.prototype, {addShape: function(a, b) {
            var d = this.data.material, e = null;
            switch (a.type) {
                case pc.shape.Type.BOX:
                    e = pc.scene.procedural.createBox({halfExtents: a.halfExtents});
                    break;
                case pc.shape.Type.SPHERE:
                    e = pc.scene.procedural.createSphere({radius: a.radius});
                    break;
                case pc.shape.Type.TORUS:
                    e = pc.scene.procedural.createTorus({tubeRadius: a.iradius,ringRadius: a.oradius})
            }
            var g = new pc.scene.GraphNode, d = new pc.scene.MeshInstance(g, 
            e, d);
            d._entity = this.entity;
            e = new pc.scene.Model;
            e.graph = g;
            e.meshInstances = [d];
            a = {shape: a,shapeName: b,model: e};
            this.data.shapes.push(a);
            this.system.addShape(this.data.layer, a)
        },deleteShapes: function() {
            this.system.deleteShapes(this.data.layer, this.data.shapes);
            this.data.shapes = []
        }});
    return {PickComponent: b}
}());
pc.extend(pc.fw, function() {
    function b() {
        this.layer = "default";
        this.shapes = [];
        this.material = null
    }
    b = pc.inherits(b, pc.fw.ComponentData);
    return {PickComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a, b) {
        this.id = "audiosource";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.AudioSourceComponent;
        this.DataType = pc.fw.AudioSourceComponentData;
        this.schema = [{name: "assets",displayName: "Assets",description: "Audio assets",type: "asset",options: {max: 100},defaultValue: []}, {name: "volume",displayName: "Volume",description: "The sound volume",type: "number",options: {max: 1,min: 0,step: 0.1},defaultValue: 1}, {name: "loop",displayName: "Loop",description: "Set whether sound loops or not",
                type: "boolean",defaultValue: !1}, {name: "activate",displayName: "Activate",description: "Play first audio sample when scene loads",type: "boolean",defaultValue: !0}, {name: "3d",displayName: "3d",description: "3d sounds are positioned in space, and their sound is dependent on listener position/orientation. Non-3d sounds are uniform aross space",type: "boolean",defaultValue: !0}, {name: "minDistance",displayName: "Min Distance",description: "Distance from listener under which the sound is at full volume",type: "number",
                defaultValue: 1,options: {min: 0}}, {name: "maxDistance",displayName: "Max Distance",description: "Distance from listener over which the sound cannot be heard",type: "number",defaultValue: 1E4,options: {min: 0}}, {name: "rollOffFactor",displayName: "Roll-off factor",description: "Strength of the roll off",type: "number",defaultValue: 1,options: {min: 0}}, {name: "sources",exposed: !1,readOnly: !0}, {name: "currentSource",exposed: !1,readOnly: !0}, {name: "channel",exposed: !1,readOnly: !0}];
        this.exposeProperties();
        this.manager = 
        b;
        pc.fw.ComponentSystem.on("initialize", this.onInitialize, this);
        pc.fw.ComponentSystem.on("update", this.onUpdate, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(a, c, d) {
            d = "assets volume loop activate 3d minDistance maxDistance rollOffFactor".split(" ");
            b._super.initializeComponentData.call(this, a, c, d);
            a.paused = !c.activate
        },onInitialize: function(a) {
            a.audiosource && a.audiosource.activate && a.audiosource.play(a.audiosource.currentSource);
            var a = a.getChildren(), 
            b, d = a.length;
            for (b = 0; b < d; b++)
                if (a[b] instanceof pc.fw.Entity)
                    this.onInitialize(a[b])
        },onUpdate: function() {
            var a = this.store, b;
            for (b in a)
                if (a.hasOwnProperty(b)) {
                    var d = a[b].entity, e = a[b].data;
                    e.channel instanceof pc.audio.Channel3d && (d = d.getPosition(), e.channel.setPosition(d))
                }
        },setVolume: function(a) {
            this.manager.setVolume(a)
        }});
    return {AudioSourceComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set_assets", this.onSetAssets, this);
        this.on("set_loop", this.onSetLoop, this);
        this.on("set_volume", this.onSetVolume, this);
        this.on("set_minDistance", this.onSetMinDistance, this);
        this.on("set_maxDistance", this.onSetMaxDistance, this);
        this.on("set_rollOffFactor", this.onSetRollOffFactor, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {play: function(a) {
            this.channel && this.stop();
            var b = this.data;
            if (b.sources[a]) {
                if (b["3d"])
                    var d = this.entity.getPosition(), 
                    d = this.system.manager.playSound3d(b.sources[a], d, b);
                else
                    d = this.system.manager.playSound(b.sources[a], b);
                b.currentSource = a;
                b.channel = d
            }
        },pause: function() {
            this.channel && this.channel.pause()
        },unpause: function() {
            this.channel && this.channel.paused && this.channel.unpause()
        },stop: function() {
            this.channel && (this.channel.stop(), this.channel = null)
        },onSetAssets: function(a, b, d) {
            var a = [], e, g = d.length;
            if (g)
                for (e = 0; e < g; e++)
                    0 > b.indexOf(d[e]) && a.push(d[e]);
            !this.system._inTools && a.length && this.loadAudioSourceAssets(a)
        },
        onSetLoop: function(a, b, d) {
            b != d && this.channel && this.channel.setLoop(d)
        },onSetVolume: function(a, b, d) {
            b != d && this.channel && this.channel.setVolume(d)
        },onSetMaxDistance: function(a, b, d) {
            b != d && this.channel instanceof pc.audio.Channel3d && this.channel.setMaxDistance(d)
        },onSetMinDistance: function(a, b, d) {
            b != d && this.channel instanceof pc.audio.Channel3d && this.channel.setMinDistance(d)
        },onSetRollOffFactor: function(a, b, d) {
            b != d && this.channel instanceof pc.audio.Channel3d && this.channel.setRollOffFactor(d)
        },loadAudioSourceAssets: function(a) {
            var b = 
            {batch: this.entity.getRequestBatch()}, d = [], e = [];
            a.map(function(a) {
                return this.system.context.assets.getAsset(a)
            }, this).forEach(function(b) {
                b ? (d.push(new pc.resources.AudioRequest(b.getFileUrl())), e.push(b.name)) : logERROR(pc.string.format("Trying to load audiosource component before assets {0} are loaded", a))
            });
            this.system.context.loader.request(d, function(a) {
                for (var f = {}, j = 0; j < d.length; j++)
                    f[e[j]] = a[d[j].identifier];
                e.length && (this.data.currentSource = e[0]);
                this.data.sources = f;
                !b.batch && this.activate && 
                this.play(e[0])
            }.bind(this), function() {
            }, function() {
            }, b)
        }});
    return {AudioSourceComponent: b}
}());
pc.fw.AudioSourceComponentData = function() {
    this.assets = [];
    this.activate = !0;
    this.volume = 1;
    this.loop = !1;
    this["3d"] = !0;
    this.minDistance = 1;
    this.maxDistance = 1E4;
    this.rollOffFactor = 1;
    this.paused = !0;
    this.sources = {};
    this.channel = this.currentSource = null
};
pc.extend(pc.fw, function() {
    var b = function(a, b) {
        this.id = "audiolistener";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.AudioListenerComponent;
        this.DataType = pc.fw.AudioListenerComponentData;
        this.schema = [];
        this.exposeProperties();
        this.manager = b;
        this.current = null;
        pc.fw.ComponentSystem.on("update", this.onUpdate, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(a, c, d) {
            b._super.initializeComponentData.call(this, a, c, d);
            a.setCurrentListener()
        },onUpdate: function() {
            if (this.current) {
                var a = 
                this.current.getPosition();
                this.manager.listener.setPosition(a);
                a = this.current.getWorldTransform();
                this.manager.listener.setOrientation(a)
            }
        }});
    return {AudioListenerComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
    }, pc.fw.Component);
    pc.extend(b.prototype, {setCurrentListener: function() {
            if (this.entity.audiolistener) {
                this.system.current = this.entity;
                var a = this.system.current.getPosition();
                this.system.manager.listener.setPosition(a)
            }
        }});
    return {AudioListenerComponent: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
    }, pc.fw.ComponentData);
    return {AudioListenerComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "primitive";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.PrimitiveComponent;
        this.DataType = pc.fw.PrimitiveComponentData;
        this.schema = [{name: "type",displayName: "Type",description: "Type of primitive",type: "enumeration",options: {enumerations: [{name: "Box",value: pc.shape.Type.BOX}, {name: "Sphere",value: pc.shape.Type.SPHERE}, {name: "Cylinder",value: pc.shape.Type.CYLINDER}, {name: "Cone",value: pc.shape.Type.CONE}]},defaultValue: "Box"}, {name: "color",
                displayName: "Color",description: "Material color",type: "rgb",defaultValue: "0xffffff"}, {name: "castShadows",displayName: "Cast shadows",description: "Occlude light from shadow casting lights",type: "boolean",defaultValue: !1}, {name: "receiveShadows",displayName: "Receive shadows",description: "Receive shadows cast from occluders",type: "boolean",defaultValue: !0}, {name: "material",exposed: !1}, {name: "model",exposed: !1}];
        this.exposeProperties();
        this.box = pc.scene.procedural.createBox({halfExtents: [0.5, 0.5, 0.5]});
        this.sphere = pc.scene.procedural.createSphere({radius: 0.5});
        this.cone = pc.scene.procedural.createCone({baseRadius: 0.5,peakRadius: 0,height: 1});
        this.cylinder = pc.scene.procedural.createCylinder({radius: 0.5,height: 1});
        this.on("remove", this.onRemove, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(a, c, d) {
            c.material = new pc.scene.PhongMaterial;
            d = ["material", "castShadows", "color", "receiveShadows", "type"];
            b._super.initializeComponentData.call(this, a, c, d)
        },
        onRemove: function(a, b) {
            b.model && (this.context.scene.removeModel(b.model), a.removeChild(b.model.getGraph()), b.model = null)
        }});
    return {PrimitiveComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set_castShadows", this.onSetCastShadows, this);
        this.on("set_color", this.onSetColor, this);
        this.on("set_model", this.onSetModel, this);
        this.on("set_receiveShadows", this.onSetReceiveShadows, this);
        this.on("set_type", this.onSetType, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {onSetType: function(a, b, d) {
            a = this.data;
            if (d) {
                b = null;
                switch (d) {
                    case pc.shape.Type.BOX:
                        b = this.system.box;
                        break;
                    case pc.shape.Type.SPHERE:
                        b = this.system.sphere;
                        break;
                    case pc.shape.Type.CONE:
                        b = 
                        this.system.cone;
                        break;
                    case pc.shape.Type.CYLINDER:
                        b = this.system.cylinder;
                        break;
                    default:
                        throw Error("Unknown shape type: " + d);
                }
                var d = new pc.scene.GraphNode, e = new pc.scene.Model;
                e.graph = d;
                e.meshInstances = [new pc.scene.MeshInstance(d, b, a.material)];
                this.system.context.designer && e.generateWireframe();
                this.model = e
            }
        },onSetCastShadows: function(a, b, d) {
            if (a = this.data.model) {
                var b = this.system.context.scene, e = b.containsModel(a);
                e && b.removeModel(a);
                for (var g = a.meshInstances, f = 0; f < g.length; f++)
                    g[f].castShadow = 
                    d;
                e && b.addModel(a)
            }
        },onSetColor: function(a, b, d) {
            a = this.data;
            b = new Float32Array([0, 0, 0]);
            d && (rgb = parseInt(d), rgb = pc.math.intToBytes24(rgb), b[0] = rgb[0] / 255, b[1] = rgb[1] / 255, b[2] = rgb[2] / 255);
            a.material.ambient = b;
            a.material.diffuse = b;
            a.material.update()
        },onSetModel: function(a, b, d) {
            b && (this.entity.removeChild(b.getGraph()), this.system.context.scene.removeModel(b), delete b._entity);
            if (d) {
                for (var a = this.data, b = d.meshInstances, e = 0; e < b.length; e++)
                    b[e].castShadow = a.castShadows, b[e].receiveShadow = a.receiveShadows;
                this.entity.addChild(d.graph);
                this.system.context.scene.addModel(d);
                d._entity = this.entity
            }
        },onSetReceiveShadows: function(a, b, d) {
            if (void 0 !== d && (a = this.data, a.model)) {
                a = a.model.meshInstances;
                for (b = 0; b < a.length; b++)
                    a[b].receiveShadow = d
            }
        }});
    return {PrimitiveComponent: b}
}());
pc.extend(pc.fw, function() {
    function b() {
        this.type = pc.shape.Type.BOX;
        this.color = "0xffffff";
        this.castShadows = !1;
        this.receiveShadows = !0;
        this.model = this.material = null
    }
    b = pc.inherits(b, pc.fw.ComponentData);
    return {PrimitiveComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        a.systems.add("designer", this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    b.prototype.createComponent = function(a, b) {
        var d = new pc.fw.DesignerComponentData;
        this.initializeComponent(a, d, b, ["fillWindow", "width", "height"]);
        return d
    };
    return {DesignerComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    DesignerComponentData = function() {
        this.fillWindow = !0;
        this.width = 800;
        this.height = 450
    };
    DesignerComponentData = pc.inherits(DesignerComponentData, pc.fw.ComponentData);
    return {DesignerComponentData: DesignerComponentData}
}());
pc.extend(pc.fw, function() {
    pc.math.mat4.create();
    pc.math.mat4.create();
    var b = pc.math.vec3.create(), a = pc.math.vec3.create();
    pc.math.vec3.create();
    var c, d, e, g, f, j = function(a) {
        "undefined" !== typeof Box2D && !d && (d = Box2D.Dynamics.b2World, e = Box2D.Common.Math.b2Vec2, g = Box2D.Dynamics.b2Body, f = Box2D.Dynamics.b2BodyDef, c = new e);
        this.id = "body2d";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.Body2dComponent;
        this.DataType = pc.fw.Body2dComponentData;
        this.schema = [{name: "static",displayName: "Static",description: "Static bodies are immovable and do not collide with other static bodies.",
                type: "boolean",defaultValue: !0}, {name: "body",exposed: !1,readOnly: !0}, {name: "bodyDef",exposed: !1,readOnly: !0}];
        this.exposeProperties();
        this._rayStart = pc.math.vec3.create();
        this._rayEnd = pc.math.vec3.create();
        this.time = 0;
        this.step = 1 / 60;
        this.xi = 0;
        this.yi = 2;
        this.ri = 1;
        d && (this.b2World = new d(new e(0, 0), !0), pc.fw.ComponentSystem.on("update", this.onUpdate, this));
        this.on("remove", this.onRemove, this)
    }, j = pc.inherits(j, pc.fw.ComponentSystem);
    pc.extend(j.prototype, {initializeComponentData: function(a, b, c) {
            c = ["static"];
            j._super.initializeComponentData.call(this, a, b, c);
            "undefined" !== typeof Box2D && this.createBody(a)
        },createBody: function(c) {
            if (c.entity.collisionrect || c.entity.collisioncircle) {
                var d = new f;
                pc.math.vec3.copy(c.entity.getPosition(), b);
                pc.math.vec3.copy(c.entity.getEulerAngles(), a);
                d.type = c.static ? g.b2_staticBody : g.b2_dynamicBody;
                d.position.Set(b[this.xi], b[this.yi]);
                var e = c._eulersToAngle(a);
                d.angle = -e * pc.math.DEG_TO_RAD;
                d.userData = c.entity;
                c.data.bodyDef = d
            }
            c.data.body && this.removeBody(c.entity, c.data.body);
            c.data.body = c.entity.collisionrect ? this.addBody(c.bodyDef, c.entity.collisionrect.fixtureDef) : c.entity.collisioncircle ? this.addBody(c.bodyDef, c.entity.collisioncircle.fixtureDef) : null
        },onRemove: function(a, b) {
            b.body && this.removeBody(a, b.body);
            b.body = null
        },to2d: function(a, b) {
            b = b || new e;
            return b.Set(a[this.xi], a[this.yi])
        },addBody: function(a, b) {
            var c = this.b2World.CreateBody(a);
            c.CreateFixture(b);
            return c
        },removeBody: function(a, b) {
            this.b2World.DestroyBody(b);
            a.body2d.body && (a.body2d.data.body = null)
        },setGravity: function(a, 
        b) {
            c.Set(a, b);
            this.b2World.SetGravity(c)
        },raycast: function(a, b, c) {
            var d = new e, f = new e;
            this.to2d(b, d);
            this.to2d(c, f);
            pc.math.vec3.copy(b, this._rayStart);
            pc.math.vec3.copy(c, this._rayEnd);
            this.b2World.RayCast(a, d, f)
        },raycastFirst: function(a, b, c) {
            var d, e = 1;
            this.raycast(function(a, b, f, g) {
                a = a.GetUserData();
                a !== c && g < e && (d = a, e = g);
                return 1
            }, a, b);
            return d
        },onUpdate: function(a) {
            var b = this.store;
            for (id in b)
                if (b.hasOwnProperty(id)) {
                    var c = b[id].entity, d = b[id].data;
                    d.body && !d.static && c.body2d.updateTransform(d.body)
                }
            for (this.time += 
            a; this.time > this.step; )
                this.b2World.Step(this.step, 6, 2), this.time -= this.step
        }});
    return {Body2dComponentSystem: j}
}());
pc.extend(pc.fw, function() {
    pc.math.mat4.create();
    pc.math.mat4.create();
    var b = pc.math.vec3.create(), a = pc.math.vec3.create();
    pc.math.vec3.create();
    var c = function(a, b) {
        this.on("set_static", this.onSetStatic, this);
        b.on("livelink:updatetransform", this.onLiveLinkUpdateTransform, this)
    }, c = pc.inherits(c, pc.fw.Component);
    pc.extend(c.prototype, {applyForce: function(a, c) {
            var g = this.entity.body2d.body;
            g && (c || (c = b, c[this.system.xi] = g.GetPosition().x, c[this.system.yi] = g.GetPosition().y), g.ApplyForce({x: a[this.system.xi],
                y: a[this.system.yi]}, {x: c[this.system.xi],y: c[this.system.yi]}))
        },applyImpulse: function(a, c) {
            var g = this.entity.body2d.body;
            g && (c || (c = b, c[this.system.xi] = g.GetPosition().x, c[this.system.yi] = g.GetPosition().y), g.ApplyImpulse({x: a[this.system.xi],y: a[this.system.yi]}, {x: c[this.system.xi],y: c[this.system.yi]}))
        },setLinearVelocity: function(a, b) {
            var c = this.entity.body2d.body;
            if (c) {
                var f = c.GetLinearVelocity();
                f.x = a;
                f.y = b;
                c.SetLinearVelocity(f)
            }
        },setAngularVelocity: function(a) {
            var b = this.entity.body2d.body;
            b && b.SetAngularVelocity(a)
        },setTransform: function(c) {
            pc.math.mat4.getTranslation(c, b);
            pc.math.mat4.toEulerXYZ(c, a);
            c = this._eulersToAngle(a);
            this.setPositionAndAngle(b[this.system.xi], b[this.system.yi], -c)
        },setPosition: function(a, b) {
            var c = this.entity.body2d.body;
            if (c) {
                c.SetAwake(!0);
                var f = c.GetPosition();
                f.x = a;
                f.y = b;
                c.SetPosition(f);
                this.updateTransform(c)
            }
        },setAngle: function(a) {
            var b = this.entity.body2d.body;
            b && (b.SetAwake(!0), b.SetAngle(a * pc.math.DEG_TO_RAD), this.updateTransform(b))
        },setPositionAndAngle: function(a, 
        b, c) {
            var f = this.entity.body2d.body;
            if (f) {
                f.SetAwake(!0);
                var j = f.GetPosition();
                j.x = a;
                j.y = b;
                f.SetPositionAndAngle(j, c * pc.math.DEG_TO_RAD);
                this.updateTransform(f)
            }
        },getAngle: function() {
            return this.entity.body2d.body.GetAngle() * pc.math.RAD_TO_DEG
        },setLinearDamping: function(a, b) {
            var c = this.entity.body2d.body;
            c && c.SetLinearDamping(b)
        },updateTransform: function(c) {
            var e = this.entity.getPosition();
            this.entity.getLocalEulerAngles();
            var g = c.GetPosition();
            b[this.system.xi] = g.x;
            b[this.system.ri] = e[1];
            b[this.system.yi] = 
            g.y;
            a[this.system.xi] = 0;
            a[this.system.ri] = -c.GetAngle() * pc.math.RAD_TO_DEG;
            a[this.system.yi] = 0;
            this.entity.setPosition(b);
            this.entity.setEulerAngles(a)
        },onSetStatic: function(a, b, c) {
            (a = this.entity.body2d.body) && (c ? a.SetType((void 0).b2_staticBody) : a.SetType((void 0).b2_dynamicBody))
        },onLiveLinkUpdateTransform: function() {
            this.setTransform(this.entity.getWorldTransform());
            this.setLinearVelocity(0, 0);
            this.setAngularVelocity(0)
        },_eulersToAngle: function(a) {
            var b = a[this.system.ri];
            179.9 < a[this.system.xi] && 
            179.9 < a[this.system.yi] && (b = 180 - a[this.system.ri]);
            return b
        }});
    return {Body2dComponent: c}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.density = 1;
        this.friction = 0.5;
        this.restitution = 0;
        this.static = !0;
        this.shape = pc.shape.Type.RECT;
        this.body = this.bodyDef = null
    }, pc.fw.ComponentData);
    return {Body2dComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b, a, c;
    pc.math.vec3.create();
    pc.math.vec3.create();
    pc.math.vec3.create(1, 1, 1);
    pc.math.mat4.create();
    var d = function(d) {
        "undefined" !== typeof Box2D && !b && (b = Box2D.Dynamics.b2World, a = Box2D.Dynamics.b2FixtureDef, c = Box2D.Collision.Shapes.b2PolygonShape);
        this.id = "collisionrect";
        d.systems.add(this.id, this);
        this.ComponentType = pc.fw.CollisionRectComponent;
        this.DataType = pc.fw.CollisionRectComponentData;
        this.schema = [{name: "density",displayName: "Density",description: "The density of the body, this determine the mass",
                type: "number",options: {min: 0,step: 0.01},defaultValue: 1}, {name: "friction",displayName: "Friction",description: "The friction when the body slides along another body",type: "number",options: {min: 0,step: 0.01},defaultValue: 0.5}, {name: "restitution",displayName: "Restitution",description: "The restitution determines the elasticity of collisions. 0 means an object doesn't bounce at all, a value of 1 will be a perfect reflection",type: "number",options: {min: 0,step: 0.01},defaultValue: 0}, {name: "x",displayName: "Size: X",
                description: "The size of the Rect in the x-axis",type: "number",options: {min: 0,step: 0.1},defaultValue: 0.5}, {name: "y",displayName: "Size: Y",description: "The size of the Rect in the y-axis",type: "number",options: {min: 0,step: 0.1},defaultValue: 0.5}, {name: "model",expose: !1}];
        this.exposeProperties();
        d = new pc.gfx.VertexFormat;
        d.begin();
        d.addElement(new pc.gfx.VertexElement("vertex_position", 3, pc.gfx.VertexElementType.FLOAT32));
        d.end();
        d = new pc.gfx.VertexBuffer(d, 4);
        (new Float32Array(d.lock())).set([-0.5, 
            0, -0.5, -0.5, 0, 0.5, 0.5, 0, 0.5, 0.5, 0, -0.5]);
        d.unlock();
        var g = new pc.gfx.IndexBuffer(pc.gfx.INDEXFORMAT_UINT8, 8);
        (new Uint8Array(g.lock())).set([0, 1, 1, 2, 2, 3, 3, 0]);
        g.unlock();
        this.mesh = new pc.scene.Mesh;
        this.mesh.vertexBuffer = d;
        this.mesh.indexBuffer[0] = g;
        this.mesh.primitive[0].type = pc.gfx.PRIMITIVE_LINES;
        this.mesh.primitive[0].base = 0;
        this.mesh.primitive[0].count = g.getNumIndices();
        this.mesh.primitive[0].indexed = !0;
        this.material = new pc.scene.BasicMaterial;
        this.material.color = pc.math.vec4.create(0, 0, 1, 1);
        this.material.update();
        this.debugRender = !1;
        this.on("remove", this.onRemove, this);
        pc.fw.ComponentSystem.on("update", this.onUpdate, this);
        pc.fw.ComponentSystem.on("toolsUpdate", this.onToolsUpdate, this)
    }, d = pc.inherits(d, pc.fw.ComponentSystem);
    d.prototype = pc.extend(d.prototype, {initializeComponentData: function(a, b, c) {
            b.model = new pc.scene.Model;
            b.model.graph = new pc.scene.GraphNode;
            b.model.meshInstances = [new pc.scene.MeshInstance(b.model.graph, this.mesh, this.material)];
            c = "density friction restitution x y model".split(" ");
            d._super.initializeComponentData.call(this, a, b, c);
            "undefined" !== typeof Box2D && (a.fixtureDef = this.createFixtureDef(a.entity, a), a.entity.body2d && this.context.systems.body2d.createBody(a.entity.body2d))
        },createFixtureDef: function(b, d) {
            var f = new a;
            f.density = d.density;
            f.friction = d.friction;
            f.restitution = d.restitution;
            f.shape = new c;
            f.shape.SetAsBox(d.x, d.y);
            f.userData = b;
            return f
        },onRemove: function(a, b) {
            a.body2d && a.body2d.body && this.context.systems.body2d.removeBody(a, a.body2d.body);
            this.context.scene.containsModel(b.model) && 
            (this.context.scene.removeModel(b.model), this.context.root.removeChild(b.model.graph))
        },setDebugRender: function(a) {
            this.debugRender = a
        },onUpdate: function() {
            this.debugRender && this.updateDebugShapes()
        },onToolsUpdate: function() {
            this.updateDebugShapes()
        },updateDebugShapes: function() {
            var a = this.store, b = this.context.systems.body2d.xi, c = this.context.systems.body2d.yi, d = this.context.systems.body2d.ri;
            for (id in a) {
                var k = a[id].entity, l = a[id].data;
                this.context.scene.containsModel(l.model) || (this.context.scene.addModel(l.model), 
                this.context.root.addChild(l.model.graph));
                var m = [];
                m[b] = 2 * l.x;
                m[c] = 2 * l.y;
                m[d] = 1;
                l = l.model.graph;
                l.setPosition(k.getPosition());
                l.setRotation(k.getRotation());
                l.setLocalScale(m[0], m[1], m[2])
            }
        }});
    return {CollisionRectComponentSystem: d}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set_density", this.onSetDensity, this);
        this.on("set_friction", this.onSetFriction, this);
        this.on("set_restitution", this.onSetRestitution, this);
        this.on("set_x", this.onSetX, this);
        this.on("set_y", this.onSetY, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {onSetDensity: function(a, b, d) {
            this.entity.body2d && this.entity.body2d.body && (this.entity.body2d.body.GetFixtureList().SetDensity(d), this.entity.body2d.body.ResetMassData())
        },onSetFriction: function(a, 
        b, d) {
            this.entity.body2d && this.entity.body2d.body && (this.entity.body2d.body.GetFixtureList().SetFriction(d), this.entity.body2d.body.ResetMassData())
        },onSetRestitution: function(a, b, d) {
            this.entity.body2d && this.entity.body2d.body && (this.entity.body2d.body.GetFixtureList().SetRestitution(d), this.entity.body2d.body.ResetMassData())
        },onSetX: function(a, b, d) {
            if (this.entity.body2d && (a = this.entity.body2d.body))
                a.GetFixtureList().GetShape().SetAsBox(d, this.y), a.SetAwake(!0)
        },onSetY: function(a, b, d) {
            if (this.entity.body2d && 
            (a = this.entity.body2d.body))
                a.GetFixtureList().GetShape().SetAsBox(this.x, d), a.SetAwake(!0)
        }});
    return {CollisionRectComponent: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.density = 1;
        this.friction = 0.5;
        this.restitution = 0;
        this.y = this.x = 0.5
    }, pc.fw.ComponentData);
    return {CollisionRectComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b, a, c;
    pc.math.vec3.create();
    pc.math.vec3.create();
    pc.math.vec3.create(1, 1, 1);
    pc.math.mat4.create();
    var d = function(d) {
        "undefined" !== typeof Box2D && !b && (b = Box2D.Dynamics.b2World, a = Box2D.Dynamics.b2FixtureDef, c = Box2D.Collision.Shapes.b2CircleShape);
        this.id = "collisioncircle";
        d.systems.add(this.id, this);
        this.ComponentType = pc.fw.CollisionCircleComponent;
        this.DataType = pc.fw.CollisionCircleComponentData;
        this.schema = [{name: "density",displayName: "Density",description: "The density of the body, this determine the mass",
                type: "number",options: {min: 0,step: 0.01},defaultValue: 1}, {name: "friction",displayName: "Friction",description: "The friction when the body slides along another body",type: "number",options: {min: 0,step: 0.01},defaultValue: 0.5}, {name: "restitution",displayName: "Restitution",description: "The restitution determines the elasticity of collisions. 0 means an object doesn't bounce at all, a value of 1 will be a perfect reflection",type: "number",options: {min: 0,step: 0.01},defaultValue: 0}, {name: "radius",displayName: "Radius",
                description: "The size of the Rect in the x-axis",type: "number",options: {min: 0,step: 0.1},defaultValue: 1}, {name: "model",exposed: !1}];
        this.exposeProperties();
        d = new pc.gfx.VertexFormat;
        d.begin();
        d.addElement(new pc.gfx.VertexElement("vertex_position", 3, pc.gfx.VertexElementType.FLOAT32));
        d.end();
        for (var d = new pc.gfx.VertexBuffer(d, 41), g = new Float32Array(d.lock()), f = d.getNumVertices(), j = 0; j < f - 1; j++) {
            var k = 2 * Math.PI * (j / (f - 2)), l = 0.5 * Math.cos(k), k = 0.5 * Math.sin(k);
            g[3 * j + 0] = l;
            g[3 * j + 1] = 0;
            g[3 * j + 2] = k
        }
        d.unlock();
        g = new pc.gfx.IndexBuffer(pc.gfx.INDEXFORMAT_UINT8, 80);
        f = new Uint8Array(g.lock());
        for (j = 0; 40 > j; j++)
            f[2 * j + 0] = j, f[2 * j + 1] = j + 1;
        g.unlock();
        this.mesh = new pc.scene.Mesh;
        this.mesh.vertexBuffer = d;
        this.mesh.indexBuffer[0] = g;
        this.mesh.primitive[0].type = pc.gfx.PRIMITIVE_LINES;
        this.mesh.primitive[0].base = 0;
        this.mesh.primitive[0].count = g.getNumIndices();
        this.mesh.primitive[0].indexed = !0;
        this.material = new pc.scene.BasicMaterial;
        this.material.color = pc.math.vec4.create(0, 0, 1, 1);
        this.material.update();
        this.debugRender = 
        !1;
        this.on("remove", this.onRemove, this);
        pc.fw.ComponentSystem.on("update", this.onUpdate, this);
        pc.fw.ComponentSystem.on("toolsUpdate", this.onToolsUpdate, this)
    }, d = pc.inherits(d, pc.fw.ComponentSystem);
    pc.extend(d.prototype, {initializeComponentData: function(a, b, c) {
            b.model = new pc.scene.Model;
            b.model.graph = new pc.scene.GraphNode;
            b.model.meshInstances = [new pc.scene.MeshInstance(b.model.graph, this.mesh, this.material)];
            c = ["density", "friction", "restitution", "radius", "model"];
            d._super.initializeComponentData.call(this, 
            a, b, c);
            "undefined" !== typeof Box2D && (a.fixtureDef = this.createFixtureDef(a.entity, a), a.entity.body2d && this.context.systems.body2d.createBody(a.entity.body2d))
        },createFixtureDef: function(b, d) {
            var f = new a;
            f.density = d.density;
            f.friction = d.friction;
            f.restitution = d.restitution;
            f.shape = new c;
            f.shape.SetRadius(d.radius);
            f.userData = b;
            return f
        },onRemove: function(a, b) {
            a.body2d && a.body2d.body && this.context.systems.body2d.removeBody(a, a.body2d.body);
            this.context.scene.containsModel(b.model) && (this.context.scene.removeModel(b.model), 
            this.context.root.removeChild(b.model.graph))
        },setDebugRender: function(a) {
            this.debugRender = a
        },setDebugRender: function(a) {
            this.debugRender = a
        },onUpdate: function() {
            this.debugRender && this.updateDebugShapes()
        },onToolsUpdate: function() {
            this.updateDebugShapes()
        },updateDebugShapes: function() {
            var a = this.store;
            for (id in a) {
                var b = a[id].entity, c = a[id].data;
                this.context.scene.containsModel(c.model) || (this.context.scene.addModel(c.model), this.context.root.addChild(c.model.graph));
                var d = c.radius, c = c.model.graph;
                c.setPosition(b.getPosition());
                c.setRotation(b.getRotation());
                c.setLocalScale(d / 0.5, d / 0.5, d / 0.5)
            }
        }});
    return {CollisionCircleComponentSystem: d}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set_density", this.onSetDensity, this);
        this.on("set_friction", this.onSetFriction, this);
        this.on("set_restitution", this.onSetRestitution, this);
        this.on("set_radius", this.onSetRadius, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {onSetDensity: function(a, b, d) {
            if (this.entity.body2d && (a = this.entity.body2d.body))
                a.GetFixtureList().SetDensity(d), a.ResetMassData()
        },onSetFriction: function(a, b, d) {
            if (this.entity.body2d && (a = this.entity.body2d.body))
                a.GetFixtureList().SetFriction(d), 
                a.ResetMassData()
        },onSetRestitution: function(a, b, d) {
            if (this.entity.body2d && (a = this.entity.body2d.body))
                a.GetFixtureList().SetRestitution(d), a.ResetMassData()
        },onSetRadius: function() {
            if (this.entity.body2d) {
                var a = this.entity.body2d.body;
                a && (a.GetFixtureList().GetShape().SetRadius(this.radius), a.SetAwake(!0))
            }
        }});
    return {CollisionCircleComponent: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.density = 1;
        this.friction = 0.5;
        this.restitution = 0;
        this.radius = 1
    }, pc.fw.ComponentData);
    return {CollisionCircleComponentData: b}
}());
pc.extend(pc.fw, function() {
    pc.math.mat4.create();
    pc.math.mat4.create();
    pc.math.vec3.create();
    pc.math.vec3.create();
    pc.math.vec3.create();
    var b, a, c = function(a, b, c) {
        this.entity = a;
        this.point = b;
        this.normal = c
    }, d = function(a, b, c) {
        this.a = a;
        this.b = b;
        this.localPointA = new pc.math.vec3.create(c.get_m_localPointA().x(), c.get_m_localPointA().y(), c.get_m_localPointA().z());
        this.localPointB = new pc.math.vec3.create(c.get_m_localPointB().x(), c.get_m_localPointB().y(), c.get_m_localPointB().z());
        this.pointA = new pc.math.vec3.create(c.getPositionWorldOnA().x(), 
        c.getPositionWorldOnA().y(), c.getPositionWorldOnA().z());
        this.pointB = new pc.math.vec3.create(c.getPositionWorldOnB().x(), c.getPositionWorldOnB().y(), c.getPositionWorldOnB().z());
        this.normal = new pc.math.vec3.create(c.get_m_normalWorldOnB().x(), c.get_m_normalWorldOnB().y(), c.get_m_normalWorldOnB().z())
    }, e = function(c) {
        this.id = "rigidbody";
        c.systems.add(this.id, this);
        this.ComponentType = pc.fw.RigidBodyComponent;
        this.DataType = pc.fw.RigidBodyComponentData;
        this.schema = [{name: "mass",displayName: "Mass",description: "The mass of the body",
                type: "number",options: {min: 0,step: 1},defaultValue: 1}, {name: "friction",displayName: "Friction",description: "The friction when the body slides along another body",type: "number",options: {min: 0,step: 0.01},defaultValue: 0.5}, {name: "restitution",displayName: "Restitution",description: "The restitution determines the elasticity of collisions. 0 means an object doesn't bounce at all, a value of 1 will be a perfect reflection",type: "number",options: {min: 0,step: 0.01},defaultValue: 0}, {name: "bodyType",displayName: "Body Type",
                description: "The type of body determines how it moves and collides with other bodies. Dynamic is a normal body. Static will never move. Kinematic can be moved in code, but will not respond to collisions.",type: "enumeration",options: {enumerations: [{name: "Static",value: pc.fw.RIGIDBODY_TYPE_STATIC}, {name: "Dynamic",value: pc.fw.RIGIDBODY_TYPE_DYNAMIC}, {name: "Kinematic",value: pc.fw.RIGIDBODY_TYPE_KINEMATIC}]},defaultValue: pc.fw.RIGIDBODY_TYPE_STATIC}, {name: "body",exposed: !1}];
        this.exposeProperties();
        this.maxSubSteps = 
        10;
        this.fixedTimeStep = 1 / 60;
        if ("undefined" !== typeof Ammo) {
            var c = new Ammo.btDefaultCollisionConfiguration, d = new Ammo.btCollisionDispatcher(c), e = new Ammo.btDbvtBroadphase, k = new Ammo.btSequentialImpulseConstraintSolver;
            this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(d, e, k, c);
            this._ammoGravity = new Ammo.btVector3(0, -9.82, 0);
            this.dynamicsWorld.setGravity(this._ammoGravity);
            pc.fw.ComponentSystem.on("update", this.onUpdate, this);
            b = new Ammo.btVector3;
            a = new Ammo.btVector3
        }
        this.on("remove", this.onRemove, this)
    }, 
    e = pc.inherits(e, pc.fw.ComponentSystem);
    pc.extend(e.prototype, {initializeComponentData: function(a, b, c) {
            c = ["friction", "mass", "restitution", "bodyType"];
            e._super.initializeComponentData.call(this, a, b, c);
            a.createBody()
        },onRemove: function(a, b) {
            b.body && (this.removeBody(b.body), Ammo.destroy(b.body));
            b.body = null
        },addBody: function(a) {
            this.dynamicsWorld.addRigidBody(a);
            return a
        },removeBody: function(a) {
            this.dynamicsWorld.removeRigidBody(a)
        },setGravity: function(a, b, c) {
            this._ammoGravity.setValue(a, b, c);
            this.dynamicsWorld.setGravity(this._ammoGravity)
        },
        raycastFirst: function(d, e, j) {
            b.setValue(d[0], d[1], d[2]);
            a.setValue(e[0], e[1], e[2]);
            d = new Ammo.ClosestRayResultCallback(b, a);
            this.dynamicsWorld.rayTest(b, a, d);
            if (d.hasHit()) {
                var e = Module.castObject(d.get_m_collisionObject(), Ammo.btRigidBody), k = d.get_m_hitPointWorld(), l = d.get_m_hitNormalWorld();
                e && j(new c(e.entity, pc.math.vec3.create(k.x(), k.y(), k.z()), pc.math.vec3.create(l.x(), l.y(), l.z())))
            }
            Ammo.destroy(d)
        },onUpdate: function(a) {
            this.dynamicsWorld.stepSimulation(a);
            var b = this.store;
            for (id in b)
                if (b.hasOwnProperty(id)) {
                    var c = 
                    b[id].entity, e = b[id].data;
                    e.body && e.body.isActive() && (e.bodyType === pc.fw.RIGIDBODY_TYPE_DYNAMIC ? c.rigidbody.syncBodyToEntity() : e.bodyType === pc.fw.RIGIDBODY_TYPE_KINEMATIC && c.rigidbody.updateKinematic(a))
                }
            if (this.hasEvent("contact")) {
                var a = this.dynamicsWorld.getDispatcher(), l, m = a.getNumManifolds(), h, n, r;
                for (n = 0; n < m; n++) {
                    b = a.getManifoldByIndexInternal(n);
                    c = Ammo.wrapPointer(b.getBody0(), Ammo.btRigidBody).entity;
                    e = Ammo.wrapPointer(b.getBody1(), Ammo.btRigidBody).entity;
                    h = b.getNumContacts();
                    for (r = 0; r < h; r++)
                        l = 
                        b.getContactPoint(r), this.fire("contact", new d(c, e, l))
                }
            }
        }});
    return {RIGIDBODY_TYPE_STATIC: "static",RIGIDBODY_TYPE_DYNAMIC: "dynamic",RIGIDBODY_TYPE_KINEMATIC: "kinematic",RIGIDBODY_CF_STATIC_OBJECT: 1,RIGIDBODY_CF_KINEMATIC_OBJECT: 2,RIGIDBODY_ACTIVE_TAG: 1,RIGIDBODY_ISLAND_SLEEPING: 2,RIGIDBODY_WANTS_DEACTIVATION: 3,RIGIDBODY_DISABLE_DEACTIVATION: 4,RIGIDBODY_DISABLE_SIMULATION: 5,RigidBodyComponentSystem: e}
}());
pc.extend(pc.fw, function() {
    pc.math.vec3.create();
    var b = pc.math.quat.create(), a, c, d, e, g, f = function(b, f) {
        "undefined" !== typeof Ammo && !a && (a = new Ammo.btTransform, c = new Ammo.btVector3, d = new Ammo.btVector3, e = new Ammo.btQuaternion, g = new Ammo.btVector3(0, 0, 0));
        this.on("set_mass", this.onSetMass, this);
        this.on("set_friction", this.onSetFriction, this);
        this.on("set_restitution", this.onSetRestitution, this);
        this.on("set_bodyType", this.onSetBodyType, this);
        this.on("set_body", this.onSetBody, this);
        f.on("livelink:updatetransform", 
        this.onLiveLinkUpdateTransform, this);
        this.displacement = pc.math.vec3.create();
        this.linearVelocity = pc.math.vec3.create();
        this.angularVelocity = pc.math.vec3.create()
    }, f = pc.inherits(f, pc.fw.Component);
    pc.extend(f.prototype, {createBody: function() {
            var a = this.entity, b;
            a.collisionbox ? b = a.collisionbox.shape : a.collisionsphere && (b = a.collisionsphere.shape);
            if (b) {
                this.body && (this.system.removeBody(this.body), Ammo.destroy(this.body));
                var c = this.isStaticOrKinematic(), d = c ? 0 : this.mass, f = new Ammo.btVector3(0, 0, 0);
                c || 
                b.calculateLocalInertia(d, f);
                var c = a.getPosition(), g = a.getRotation();
                e.setValue(g[0], g[1], g[2], g[3]);
                g = new Ammo.btTransform;
                g.setIdentity();
                g.getOrigin().setValue(c[0], c[1], c[2]);
                g.setRotation(e);
                c = new Ammo.btDefaultMotionState(g);
                b = new Ammo.btRigidBodyConstructionInfo(d, c, b, f);
                b = new Ammo.btRigidBody(b);
                b.setRestitution(this.restitution);
                b.setFriction(this.friction);
                this.isKinematic() && (b.setCollisionFlags(b.getCollisionFlags() | pc.fw.RIGIDBODY_CF_KINEMATIC_OBJECT), b.setActivationState(pc.fw.RIGIDBODY_DISABLE_DEACTIVATION));
                b.entity = a;
                this.system.addBody(b);
                a.rigidbody.body = b;
                a.rigidbody.body.activate()
            }
        },isActive: function() {
            return this.body ? this.body.isActive() : !1
        },activate: function() {
            this.body && this.body.activate()
        },applyForce: function() {
            var a, b, e, f, h, n;
            switch (arguments.length) {
                case 1:
                    a = arguments[0][0];
                    b = arguments[0][1];
                    e = arguments[0][2];
                    break;
                case 2:
                    a = arguments[0][0];
                    b = arguments[0][1];
                    e = arguments[0][2];
                    f = arguments[1][0];
                    h = arguments[1][1];
                    n = arguments[1][2];
                    break;
                case 3:
                    a = arguments[0];
                    b = arguments[1];
                    e = arguments[2];
                    break;
                case 6:
                    a = arguments[0], b = arguments[1], e = arguments[2], f = arguments[0], h = arguments[1], n = arguments[2]
            }
            var r = this.body;
            r && (c.setValue(a, b, e), "undefined" !== typeof f ? (d.setValue(f, h, n), r.applyForce(c, d)) : r.applyForce(c, g))
        },applyImpulse: function() {
            var a, b, e, f, h, n;
            switch (arguments.length) {
                case 1:
                    a = arguments[0][0];
                    b = arguments[0][1];
                    e = arguments[0][2];
                    break;
                case 2:
                    a = arguments[0][0];
                    b = arguments[0][1];
                    e = arguments[0][2];
                    f = arguments[1][0];
                    h = arguments[1][1];
                    n = arguments[1][2];
                    break;
                case 3:
                    a = arguments[0];
                    b = arguments[1];
                    e = arguments[2];
                    break;
                case 6:
                    a = arguments[0], b = arguments[1], e = arguments[2], f = arguments[0], h = arguments[1], n = arguments[2]
            }
            var r = this.body;
            r && (c.setValue(a, b, e), "undefined" !== typeof f ? (d.setValue(f, h, n), r.applyImpulse(c, d)) : r.applyImpulse(c, g))
        },getLinearVelocity: function() {
            if (this.isKinematic())
                return this.linearVelocity;
            if (this.body) {
                var a = this.body.getLinearVelocity();
                pc.math.vec3.set(this.linearVelocity, a.x(), a.y(), a.z());
                return this.linearVelocity
            }
        },getAngularVelocity: function() {
            if (this.isKinematic())
                return this.angularVelocity;
            if (this.body) {
                var a = this.body.getAngularVelocity();
                pc.math.vec3.set(this.angularVelocity, a.x(), a.y(), a.z());
                return this.angularVelocity
            }
        },setLinearVelocity: function(a, b, d) {
            if (this.isKinematic())
                pc.math.vec3.set(this.linearVelocity, a, b, d);
            else {
                var e = this.body;
                e && (c.setValue(a, b, d), e.setLinearVelocity(c))
            }
        },setAngularVelocity: function(a, b, d) {
            if (this.isKinematic())
                pc.math.vec3.set(this.angularVelocity, a, b, d);
            else {
                var e = this.body;
                e && (c.setValue(a, b, d), e.setAngularVelocity(c))
            }
        },setLinearFactor: function(a, 
        b, c) {
            this.body && this.body.setLinearFactor(a, b, c)
        },setAngularFactor: function(a) {
            this.body && this.body.setAngularFactor(a)
        },isStatic: function() {
            return this.bodyType === pc.fw.RIGIDBODY_TYPE_STATIC
        },isStaticOrKinematic: function() {
            return this.bodyType === pc.fw.RIGIDBODY_TYPE_STATIC || this.bodyType === pc.fw.RIGIDBODY_TYPE_KINEMATIC
        },isKinematic: function() {
            return this.bodyType === pc.fw.RIGIDBODY_TYPE_KINEMATIC
        },syncEntityToBody: function() {
            var a = this.entity.getWorldTransform(), c = this.body;
            if (c) {
                var d = pc.math.mat4.getTranslation(a);
                pc.math.mat4.toQuat(a, b);
                a = c.getWorldTransform();
                a.getOrigin().setValue(d[0], d[1], d[2]);
                e.setValue(b[0], b[1], b[2], b[3]);
                a.setRotation(e);
                c.activate()
            }
        },syncBodyToEntity: function() {
            var c = this.body;
            if (c.isActive() && c.getMotionState()) {
                c.getMotionState().getWorldTransform(a);
                var c = a.getOrigin(), d = a.getRotation();
                this.entity.setPosition(c.x(), c.y(), c.z());
                b[0] = d.x();
                b[1] = d.y();
                b[2] = d.z();
                b[3] = d.w();
                this.entity.setRotation(b)
            }
        },updateKinematic: function(b) {
            pc.math.vec3.scale(this.linearVelocity, b, this.displacement);
            this.entity.translate(this.displacement);
            pc.math.vec3.scale(this.angularVelocity, b, this.displacement);
            this.entity.rotate(this.displacement[0], this.displacement[1], this.displacement[2]);
            if (this.body.getMotionState()) {
                var b = this.entity.getPosition(), c = this.entity.getRotation();
                a.getOrigin().setValue(b[0], b[1], b[2]);
                e.setValue(c[0], c[1], c[2], c[3]);
                a.setRotation(e);
                this.body.getMotionState().setWorldTransform(a)
            }
        },onSetMass: function(a, b, c) {
            if (a = this.data.body)
                this.system.removeBody(a), b = new Ammo.btVector3(0, 
                0, 0), a.getCollisionShape().calculateLocalInertia(c, b), a.setMassProps(c, b), a.updateInertiaTensor(), this.system.addBody(a)
        },onSetFriction: function(a, b, c) {
            (a = this.data.body) && a.setFriction(c)
        },onSetRestitution: function(a, b, c) {
            (a = this.data.body) && a.setRestitution(c)
        },onSetBodyType: function(a, b, c) {
            c !== b && this.createBody()
        },onSetBody: function() {
            this.body && this.body.activate()
        },onLiveLinkUpdateTransform: function() {
            this.syncEntityToBody();
            this.setLinearVelocity(0, 0, 0);
            this.setAngularVelocity(0, 0, 0)
        }});
    return {RigidBodyComponent: f}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.mass = 1;
        this.friction = 0.5;
        this.restitution = 0;
        this.bodyType = pc.fw.RIGIDBODY_TYPE_STATIC;
        this.body = null
    }, pc.fw.ComponentData);
    return {RigidBodyComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "collisionbox";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.CollisionBoxComponent;
        this.DataType = pc.fw.CollisionBoxComponentData;
        this.schema = [{name: "halfExtents",displayName: "Half Extents",description: "The half-extents of the box",type: "vector",options: {min: 0,step: 0.1},defaultValue: [0.5, 0.5, 0.5]}, {name: "shape",exposed: !1}, {name: "model",exposed: !1}];
        this.exposeProperties();
        a = new pc.gfx.VertexFormat;
        a.begin();
        a.addElement(new pc.gfx.VertexElement("vertex_position", 
        3, pc.gfx.VertexElementType.FLOAT32));
        a.end();
        a = new pc.gfx.VertexBuffer(a, 8);
        (new Float32Array(a.lock())).set([-0.5, -0.5, -0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5, -0.5, -0.5, -0.5, 0.5, -0.5, -0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, -0.5]);
        a.unlock();
        var b = new pc.gfx.IndexBuffer(pc.gfx.INDEXFORMAT_UINT8, 24);
        (new Uint8Array(b.lock())).set([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        b.unlock();
        this.mesh = new pc.scene.Mesh;
        this.mesh.vertexBuffer = a;
        this.mesh.indexBuffer[0] = b;
        this.mesh.primitive[0].type = pc.gfx.PRIMITIVE_LINES;
        this.mesh.primitive[0].base = 0;
        this.mesh.primitive[0].count = b.getNumIndices();
        this.mesh.primitive[0].indexed = !0;
        this.material = new pc.scene.BasicMaterial;
        this.material.color = pc.math.vec4.create(0, 0, 1, 1);
        this.material.update();
        this.debugRender = !1;
        this.on("remove", this.onRemove, this);
        pc.fw.ComponentSystem.on("update", this.onUpdate, this);
        pc.fw.ComponentSystem.on("toolsUpdate", this.onToolsUpdate, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    b.prototype = pc.extend(b.prototype, {initializeComponentData: function(a, 
        c, d) {
            "undefined" !== typeof Ammo && (c.shape = new Ammo.btBoxShape(new Ammo.btVector3(c.halfExtents[0], c.halfExtents[1], c.halfExtents[2])));
            c.model = new pc.scene.Model;
            c.model.graph = new pc.scene.GraphNode;
            c.model.meshInstances = [new pc.scene.MeshInstance(c.model.graph, this.mesh, this.material)];
            d = ["halfExtents", "shape", "model"];
            b._super.initializeComponentData.call(this, a, c, d);
            a.entity.rigidbody && a.entity.rigidbody.createBody()
        },cloneComponent: function(a, b) {
            var d = this.dataStore[a.getGuid()], d = {halfExtents: pc.extend([], 
                d.data.halfExtents)};
            return this.addComponent(b, d)
        },onRemove: function(a, b) {
            a.rigidbody && a.rigidbody.body && this.context.systems.rigidbody.removeBody(a.rigidbody.body);
            this.context.scene.containsModel(b.model) && (this.context.root.removeChild(b.model.graph), this.context.scene.removeModel(b.model))
        },setDebugRender: function(a) {
            this.debugRender = a
        },onUpdate: function() {
            this.debugRender && this.updateDebugShapes()
        },onToolsUpdate: function() {
            this.updateDebugShapes()
        },updateDebugShapes: function() {
            var a = this.store;
            for (id in a) {
                var b = a[id].entity, d = a[id].data, e = d.halfExtents[0], g = d.halfExtents[1], f = d.halfExtents[2], j = d.model;
                this.context.scene.containsModel(d.model) || (this.context.scene.addModel(d.model), this.context.root.addChild(d.model.graph));
                d = j.graph;
                d.setPosition(b.getPosition());
                d.setRotation(b.getRotation());
                d.setLocalScale(e / 0.5, g / 0.5, f / 0.5)
            }
        }});
    return {CollisionBoxComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set_halfExtents", this.onSetHalfExtents, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {onSetHalfExtents: function() {
            this.entity.rigidbody && (this.data.shape = this.createShape(this.data.halfExtents[0], this.data.halfExtents[1], this.data.halfExtents[2]), this.entity.rigidbody.createBody())
        },createShape: function(a, b, d) {
            if ("undefined" !== typeof Ammo)
                return new Ammo.btBoxShape(new Ammo.btVector3(a, b, d))
        }});
    return {CollisionBoxComponent: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.halfExtents = [0.5, 0.5, 0.5];
        this.model = this.shape = null
    }, pc.fw.ComponentData);
    return {CollisionBoxComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.id = "collisionsphere";
        a.systems.add(this.id, this);
        this.ComponentType = pc.fw.CollisionSphereComponent;
        this.DataType = pc.fw.CollisionSphereComponentData;
        this.schema = [{name: "radius",displayName: "Radius",description: "The radius of the collision sphere",type: "number",options: {min: 0,step: 0.1},defaultValue: 0.5}, {name: "shape",exposed: !1}, {name: "model",exposed: !1}];
        this.exposeProperties();
        a = new pc.gfx.VertexFormat;
        a.begin();
        a.addElement(new pc.gfx.VertexElement("vertex_position", 
        3, pc.gfx.VertexElementType.FLOAT32));
        a.end();
        for (var a = new pc.gfx.VertexBuffer(a, 41), b = new Float32Array(a.lock()), d = a.getNumVertices(), e = 0; e < d - 1; e++) {
            var g = 2 * Math.PI * (e / (d - 2)), f = 0.5 * Math.cos(g), g = 0.5 * Math.sin(g);
            b[3 * e + 0] = f;
            b[3 * e + 1] = 0;
            b[3 * e + 2] = g
        }
        a.unlock();
        b = new pc.gfx.IndexBuffer(pc.gfx.INDEXFORMAT_UINT8, 80);
        d = new Uint8Array(b.lock());
        for (e = 0; 40 > e; e++)
            d[2 * e + 0] = e, d[2 * e + 1] = e + 1;
        b.unlock();
        this.mesh = new pc.scene.Mesh;
        this.mesh.vertexBuffer = a;
        this.mesh.indexBuffer[0] = b;
        this.mesh.primitive[0].type = pc.gfx.PRIMITIVE_LINES;
        this.mesh.primitive[0].base = 0;
        this.mesh.primitive[0].count = b.getNumIndices();
        this.mesh.primitive[0].indexed = !0;
        this.material = new pc.scene.BasicMaterial;
        this.material.color = pc.math.vec4.create(0, 0, 1, 1);
        this.material.update();
        this.debugRender = !1;
        this.on("remove", this.onRemove, this);
        pc.fw.ComponentSystem.on("update", this.onUpdate, this);
        pc.fw.ComponentSystem.on("toolsUpdate", this.onToolsUpdate, this)
    }, b = pc.inherits(b, pc.fw.ComponentSystem);
    pc.extend(b.prototype, {initializeComponentData: function(a, c, d) {
            "undefined" !== 
            typeof Ammo && (c.shape = new Ammo.btSphereShape(c.radius));
            c.model = new pc.scene.Model;
            c.model.graph = new pc.scene.GraphNode;
            c.model.meshInstances = [new pc.scene.MeshInstance(c.model.graph, this.mesh, this.material)];
            d = ["radius", "shape", "model"];
            b._super.initializeComponentData.call(this, a, c, d);
            a.entity.rigidbody && a.entity.rigidbody.createBody()
        },onRemove: function(a, b) {
            a.rigidbody && a.rigidbody.body && this.context.systems.rigidbody.removeBody(a.rigidbody.body);
            this.context.scene.containsModel(b.model) && (this.context.root.removeChild(b.model.graph), 
            this.context.scene.removeModel(b.model))
        },setDebugRender: function(a) {
            this.debugRender = a
        },onUpdate: function() {
            this.debugRender && this.updateDebugShapes()
        },onToolsUpdate: function() {
            this.updateDebugShapes()
        },updateDebugShapes: function() {
            var a = this.store;
            for (id in a) {
                var b = a[id].entity, d = a[id].data, e = d.radius, g = d.model;
                this.context.scene.containsModel(d.model) || (this.context.scene.addModel(d.model), this.context.root.addChild(d.model.graph));
                d = g.graph;
                d.setPosition(b.getPosition());
                d.setRotation(b.getRotation());
                d.setLocalScale(e / 0.5, e / 0.5, e / 0.5)
            }
        }});
    return {CollisionSphereComponentSystem: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.on("set_radius", this.onSetRadius, this)
    }, pc.fw.Component);
    pc.extend(b.prototype, {onSetRadius: function(a, b, d) {
            this.entity.rigidbody && ("undefined" !== typeof Ammo && (this.data.shape = new Ammo.btSphereShape(d)), this.entity.rigidbody.createBody())
        }});
    return {CollisionSphereComponent: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this.radius = 0.5;
        this.model = this.shape = null
    }, pc.fw.ComponentData);
    return {CollisionSphereComponentData: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this._destinations = [];
        this._callbacks = {};
        this._linkid = (a || "") + "-" + pc.guid.create();
        this._listener = null;
        this._handler = this._handleMessage.bind(this);
        window.addEventListener("message", this._handler, !1);
        pc.livelinks || (pc.livelinks = []);
        pc.livelinks.push(this)
    };
    b.prototype.detach = function() {
        this._listener = null;
        window.removeEventListener("message", this._handler, !1)
    };
    b.prototype.addDestinationWindow = function(a) {
        this._destinations.push(a)
    };
    b.prototype.removeDestinationWindow = 
    function(a) {
        var b;
        for (b = 0; b < this._destinations.length; ++b)
            if (this._destinations[b] == a) {
                this._destinations.splice(b, 1);
                break
            }
    };
    b.prototype.send = function(a, b) {
        var b = b || function() {
        }, d, e = this._destinations.length, g = [];
        for (d = 0; d < e; d++) {
            var f = this._destinations[d];
            f.closed ? g.push(f) : this._send(a, b, f, f.location.protocol + "//" + f.location.host)
        }
        e = g.length;
        for (d = 0; d < e; d++)
            this.removeDestinationWindow(g[d])
    };
    b.prototype._send = function(a, b, d, e) {
        a.senderid = this._linkid;
        this._callbacks[a.id] ? this._callbacks[a.id].count++ : 
        this._callbacks[a.id] = {count: 1,callback: b ? b.bind(this) : function() {
            }};
        var g = pc.fw.LiveLinkMessage.serialize(a);
        d === window ? pc.livelinks.forEach(function(a) {
            a._handleMessage({source: window,data: g})
        }) : d.postMessage(g, e)
    };
    b.prototype.listen = function(a) {
        if (this._listener)
            throw Error("LiveLink already listening");
        this._listener = a
    };
    b.prototype._handleMessage = function(a) {
        var b, d;
        if (b = pc.fw.LiveLinkMessage.deserialize(a.data))
            b = new pc.fw.LiveLinkMessage(b, a.source), this._linkid !== b.senderid && (b.type == pc.fw.LiveLinkMessageType.RECEIVED ? 
            b.content.received_from == this._linkid && (this._callbacks[b.content.id].count--, 0 == this._callbacks[b.content.id].count && (this._callbacks[b.content.id].callback(), delete this._callbacks[b.content.id])) : this._listener && (this._listener(b), d = new pc.fw.LiveLinkMessage, d.type = pc.fw.LiveLinkMessageType.RECEIVED, d.content = {id: b.id,received_from: b.senderid}, this._send(d, null, a.source, a.origin)))
    };
    return {LiveLink: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a, b) {
        a = a || {};
        this.type = a.type || pc.fw.LiveLinkMessageType.NO_TYPE;
        this.content = a.content || {};
        this.id = a.id || pc.guid.create();
        this.senderid = a.senderid || null;
        this.source = b || null
    };
    b.register = function(a) {
        pc.fw.LiveLinkMessageType[a] = a
    };
    b.serialize = function(a) {
        return JSON.stringify({type: a.type,content: a.content,id: a.id,senderid: a.senderid}, function(a) {
            return this[a] instanceof Float32Array ? pc.makeArray(this[a]) : this[a]
        })
    };
    b.deserialize = function(a) {
        try {
            return JSON.parse(a)
        } catch (b) {
            return null
        }
    };
    return {LiveLinkMessage: b,LiveLinkMessageRegister: {},LiveLinkMessageType: {NO_TYPE: "NO_TYPE",RECEIVED: "RECEIVED"}}
}());
pc.extend(pc.fw, function() {
    var b = function(a, b, d, e) {
        this.type = pc.fw.LiveLinkMessageType.UPDATE_COMPONENT;
        this.content = {id: a,component: b,attribute: d,value: e}
    }, b = pc.inherits(b, pc.fw.LiveLinkMessage);
    pc.fw.LiveLinkMessage.register("UPDATE_COMPONENT");
    return {LiveLinkUpdateComponentMessage: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a, b) {
        this.type = pc.fw.LiveLinkMessageType.UPDATE_ENTITY;
        this.content = {id: a,components: b}
    }, b = pc.inherits(b, pc.fw.LiveLinkMessage);
    pc.fw.LiveLinkMessage.register("UPDATE_ENTITY");
    var a = function(a, b, c, d) {
        this.type = pc.fw.LiveLinkMessageType.UPDATE_ENTITY_TRANSFORM;
        this.content = {id: a,position: b,rotation: c,scale: d}
    }, a = pc.inherits(a, pc.fw.LiveLinkMessage);
    pc.fw.LiveLinkMessage.register("UPDATE_ENTITY_TRANSFORM");
    var c = function(a, b) {
        this.type = pc.fw.LiveLinkMessageType.UPDATE_ENTITY_NAME;
        this.content = {id: a,name: b}
    }, c = pc.inherits(c, pc.fw.LiveLinkMessage);
    pc.fw.LiveLinkMessage.register("UPDATE_ENTITY_NAME");
    var d = function(a, b, c, d) {
        this.type = pc.fw.LiveLinkMessageType.REPARENT_ENTITY;
        this.content = {id: a,oldParentId: b,newParentId: c,index: d}
    }, d = pc.inherits(d, pc.fw.LiveLinkMessage);
    pc.fw.LiveLinkMessage.register("REPARENT_ENTITY");
    return {LiveLinkUpdateEntityMessage: b,LiveLinkUpdateEntityNameMessage: c,LiveLinkUpdateEntityTransformMessage: a,LiveLinkReparentEntityMessage: d}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.type = pc.fw.LiveLinkMessageType.CLOSE_ENTITY;
        this.content = {id: a}
    }, b = pc.inherits(b, pc.fw.LiveLinkMessage);
    pc.fw.LiveLinkMessage.register("CLOSE_ENTITY");
    return {LiveLinkCloseEntityMessage: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this.type = pc.fw.LiveLinkMessageType.OPEN_ENTITY;
        this.content = {entity: PCD.model.Entity.toData(a)}
    }, b = pc.inherits(b, pc.fw.LiveLinkMessage);
    pc.fw.LiveLinkMessage.register("OPEN_ENTITY");
    return {LiveLinkOpenEntityMessage: b}
}());
pc.extend(pc.fw, function() {
    var b;
    b = pc.inherits(function() {
        this._guid = pc.guid.create();
        this._batchHandle = null;
        this.c = {};
        pc.extend(this, pc.events)
    }, pc.scene.GraphNode);
    b.prototype.getGuid = function() {
        return this._guid
    };
    b.prototype.setGuid = function(a) {
        this._guid = a
    };
    b.prototype.setRequestBatch = function(a) {
        this._batchHandle = a
    };
    b.prototype.getRequestBatch = function() {
        return this._batchHandle
    };
    b.prototype.addChild = function(a) {
        if (a instanceof pc.fw.Entity && this.getRoot().findOne("getGuid", a.getGuid()))
            throw Error("GUID already exists in graph");
        pc.scene.GraphNode.prototype.addChild.call(this, a)
    };
    b.prototype.findByGuid = function(a) {
        if (this._guid === a)
            return this;
        for (var b = 0; b < this._children.length; b++)
            if (this._children[b].findByGuid) {
                var d = this._children[b].findByGuid(a);
                if (null !== d)
                    return d
            }
        return null
    };
    b.prototype.reparent = function(a) {
        var b = this.getParent();
        b && b.removeChild(this);
        a && a.addChild(this)
    };
    b.prototype.destroy = function() {
        var a = this.getParent();
        for (name in this.c)
            this.c[name].system.removeComponent(this);
        a && a.removeChild(this);
        for (var a = 
        this.getChildren(), b; b = a.shift(); )
            b instanceof pc.fw.Entity && b.destroy()
    };
    b.prototype.clone = function() {
        var a, b = new pc.fw.Entity;
        pc.fw.Entity._super._cloneInternal.call(this, b);
        for (a in this.c)
            this.c[a].system.cloneComponent(this, b);
        for (a = 0; a < this.getChildren().length; a++) {
            var d = this.getChildren()[a];
            d instanceof pc.fw.Entity && b.addChild(d.clone())
        }
        return b
    };
    b.deserialize = function(a) {
        var b = pc.json.parse(a.template), d = pc.json.parse(a.parent), e = pc.json.parse(a.children), g = pc.json.parse(a.transform), 
        f = pc.json.parse(a.components), j = pc.json.parse(a.labels);
        return {_id: a._id,resource_id: a.resource_id,_rev: a._rev,name: a.name,labels: j,template: b,parent: d,children: e,transform: g,components: f}
    };
    b.serialize = function(a) {
        var b = {_id: a._id,resource_id: a.resource_id,name: a.name,labels: pc.json.stringify(a.labels),template: pc.json.stringify(a.template),parent: pc.json.stringify(a.parent),children: pc.json.stringify(a.children),transform: pc.json.stringify(a.transform),components: pc.json.stringify(a.components)};
        a._rev && (b._rev = a._rev);
        return b
    };
    return {Entity: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a, b, d) {
        this.resourceId = a;
        pc.extend(this, b);
        this.prefix = d || ""
    };
    b.prototype.getFileUrl = function() {
        var a = this.file.url, b = "";
        this.prefix && (b = this.prefix);
        return pc.path.join(b, a)
    };
    b.prototype.getSubAssetFileUrl = function(a) {
        var a = this.subfiles[a].url, b = "";
        this.prefix && (b = this.prefix);
        return pc.path.join(b, a)
    };
    return {Asset: b}
}());
pc.extend(pc.fw, function() {
    var b = function(a) {
        this._cache = {};
        this._names = {};
        this._prefix = a || ""
    };
    b.prototype = {update: function(a, b) {
            for (resourceId in a.assets) {
                var d = this.getAsset(resourceId);
                d ? pc.extend(d, a.assets[resourceId]) : (d = new pc.fw.Asset(resourceId, a.assets[resourceId], this._prefix), this.addAsset(resourceId, d), b && (b.registerHash(d.file.hash, d.getFileUrl()), d.subfiles.forEach(function(a, g) {
                    b.registerHash(a.hash, d.getSubAssetFileUrl(g))
                })))
            }
        },addAsset: function(a, b) {
            this._cache[a] = b;
            this._names[b.name] = 
            a
        },getAsset: function(a) {
            return this._cache[a]
        },getAssetByName: function(a) {
            return (a = this._names[a]) && this._cache[a] ? this._cache[a] : null
        }};
    return {AssetCache: b}
}());
